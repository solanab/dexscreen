"""
Custom exceptions for Dexscreen API validation and error handling
"""


class DexscreenError(Exception):
    """Base exception for all Dexscreen-related errors"""
    pass


class ValidationError(DexscreenError):
    """Base exception for input validation errors"""
    pass


class InvalidAddressError(ValidationError):
    """Raised when an invalid address is provided"""
    
    def __init__(self, address: str, reason: str = "Invalid address format"):
        self.address = address
        self.reason = reason
        super().__init__(f"{reason}: '{address}'")


class InvalidChainIdError(ValidationError):
    """Raised when an invalid chain ID is provided"""
    
    def __init__(self, chain_id: str, valid_chains: list[str] = None):
        self.chain_id = chain_id
        self.valid_chains = valid_chains or []
        if self.valid_chains:
            super().__init__(f"Invalid chain ID '{chain_id}'. Valid chains: {', '.join(self.valid_chains)}")
        else:
            super().__init__(f"Invalid chain ID '{chain_id}'")


class InvalidParameterError(ValidationError):
    """Raised when a parameter has an invalid value"""
    
    def __init__(self, parameter: str, value, expected: str):
        self.parameter = parameter
        self.value = value
        self.expected = expected
        super().__init__(f"Invalid {parameter}: {value}. Expected: {expected}")


class InvalidRangeError(ValidationError):
    """Raised when a numeric parameter is outside valid range"""
    
    def __init__(self, parameter: str, value, min_value=None, max_value=None):
        self.parameter = parameter
        self.value = value
        self.min_value = min_value
        self.max_value = max_value
        
        if min_value is not None and max_value is not None:
            super().__init__(f"Invalid {parameter}: {value}. Must be between {min_value} and {max_value}")
        elif min_value is not None:
            super().__init__(f"Invalid {parameter}: {value}. Must be >= {min_value}")
        elif max_value is not None:
            super().__init__(f"Invalid {parameter}: {value}. Must be <= {max_value}")
        else:
            super().__init__(f"Invalid {parameter}: {value}")


class InvalidTypeError(ValidationError):
    """Raised when a parameter has an incorrect type"""
    
    def __init__(self, parameter: str, value, expected_type):
        self.parameter = parameter
        self.value = value
        self.expected_type = expected_type
        super().__init__(f"Invalid type for {parameter}: {type(value).__name__}. Expected: {expected_type}")


class TooManyItemsError(ValidationError):
    """Raised when too many items are provided for a list parameter"""
    
    def __init__(self, parameter: str, count: int, max_allowed: int):
        self.parameter = parameter
        self.count = count
        self.max_allowed = max_allowed
        super().__init__(f"Too many {parameter}: {count}. Maximum allowed: {max_allowed}")


class EmptyListError(ValidationError):
    """Raised when an empty list is provided where items are required"""
    
    def __init__(self, parameter: str):
        self.parameter = parameter
        super().__init__(f"Empty {parameter} list. At least one item is required")


class InvalidFilterError(ValidationError):
    """Raised when filter configuration is invalid"""
    
    def __init__(self, message: str):
        super().__init__(f"Invalid filter configuration: {message}")


class InvalidIntervalError(ValidationError):
    """Raised when polling interval is invalid"""
    
    def __init__(self, interval: float, min_interval: float = 0.1, max_interval: float = 3600.0):
        self.interval = interval
        self.min_interval = min_interval
        self.max_interval = max_interval
        super().__init__(
            f"Invalid interval: {interval}s. Must be between {min_interval}s and {max_interval}s"
        )


class InvalidCallbackError(ValidationError):
    """Raised when callback function is invalid"""
    
    def __init__(self, callback, reason: str):
        self.callback = callback
        self.reason = reason
        super().__init__(f"Invalid callback: {reason}")


class InvalidUrlError(ValidationError):
    """Raised when URL format is invalid"""
    
    def __init__(self, url: str, reason: str = "Invalid URL format"):
        self.url = url
        self.reason = reason
        super().__init__(f"{reason}: '{url}'")


class RateLimitConfigError(ValidationError):
    """Raised when rate limit configuration is invalid"""
    
    def __init__(self, message: str):
        super().__init__(f"Invalid rate limit configuration: {message}")


class HttpClientConfigError(ValidationError):
    """Raised when HTTP client configuration is invalid"""
    
    def __init__(self, message: str):
        super().__init__(f"Invalid HTTP client configuration: {message}")


# HTTP Client Exceptions
class HttpError(DexscreenError):
    """Base exception for HTTP-related errors"""
    pass


class HttpRequestError(HttpError):
    """Raised when an HTTP request fails"""
    
    def __init__(self, method: str, url: str, status_code: int = None, response_text: str = None, original_error: Exception = None):
        self.method = method
        self.url = url
        self.status_code = status_code
        self.response_text = response_text
        self.original_error = original_error
        
        # Build error message
        message = f"HTTP {method} request to '{url}' failed"
        if status_code:
            message += f" with status {status_code}"
        if response_text and len(response_text) < 200:
            message += f": {response_text}"
        if original_error:
            message += f" (original error: {type(original_error).__name__}: {original_error})"
            
        super().__init__(message)


class HttpTimeoutError(HttpError):
    """Raised when an HTTP request times out"""
    
    def __init__(self, method: str, url: str, timeout: float, original_error: Exception = None):
        self.method = method
        self.url = url
        self.timeout = timeout
        self.original_error = original_error
        
        message = f"HTTP {method} request to '{url}' timed out after {timeout}s"
        if original_error:
            message += f" (original error: {type(original_error).__name__}: {original_error})"
            
        super().__init__(message)


class HttpConnectionError(HttpError):
    """Raised when unable to establish HTTP connection"""
    
    def __init__(self, method: str, url: str, original_error: Exception = None):
        self.method = method
        self.url = url
        self.original_error = original_error
        
        message = f"Failed to connect for HTTP {method} request to '{url}'"
        if original_error:
            message += f" (original error: {type(original_error).__name__}: {original_error})"
            
        super().__init__(message)


class HttpResponseParsingError(HttpError):
    """Raised when unable to parse HTTP response (e.g., invalid JSON)"""
    
    def __init__(self, method: str, url: str, content_type: str = None, response_content: str = None, original_error: Exception = None):
        self.method = method
        self.url = url
        self.content_type = content_type
        self.response_content = response_content
        self.original_error = original_error
        
        message = f"Failed to parse response from HTTP {method} request to '{url}'"
        if content_type:
            message += f" (content-type: {content_type})"
        if original_error:
            message += f" (original error: {type(original_error).__name__}: {original_error})"
            
        super().__init__(message)


class HttpSessionError(HttpError):
    """Raised when HTTP session creation or management fails"""
    
    def __init__(self, message: str, original_error: Exception = None):
        self.original_error = original_error
        
        if original_error:
            message += f" (original error: {type(original_error).__name__}: {original_error})"
            
        super().__init__(message)