{"config":{"lang":["en","zh"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Dexscreen Documentation","text":"<p>Welcome to the Dexscreen documentation! This Python SDK provides a stable, reliable, and feature-rich interface for the Dexscreener.com API, enabling real-time DeFi data monitoring and analysis.</p> <p>\ud83c\udfaf Quick Start: New to Dexscreen? Start with our Getting Started Guide for installation and your first queries.</p>"},{"location":"#quick-navigation","title":"\ud83d\ude80 Quick Navigation","text":"Section Description Best For Getting Started Installation, setup, and your first queries New users, quick setup Query API Single query methods for fetching data One-time data fetching, API reference Streaming API Real-time subscription methods for live updates Real-time monitoring, trading bots Data Models Complete reference for all data structures Understanding API responses Filtering Advanced filtering and configuration options Optimizing subscriptions, reducing noise Examples Complete working examples for common use cases Learning by example, production patterns"},{"location":"#documentation-structure","title":"\ud83d\udcda Documentation Structure","text":""},{"location":"#getting-started","title":"\ud83c\udfaf Getting Started","text":"<ul> <li>Getting Started Guide - Installation, basic setup, and your first queries</li> <li>Examples - Complete, runnable examples for common use cases</li> </ul> <p>\ud83d\udca1 New User Path: Getting Started \u2192 Examples \u2192 Query API \u2192 Streaming API</p>"},{"location":"#api-reference","title":"\ud83d\udcd6 API Reference","text":"<ul> <li>Query API - Comprehensive guide to all query methods for one-time data fetching</li> <li>Streaming API - Real-time subscription methods for continuous updates</li> <li>Data Models - Complete reference for all data structures and types</li> <li>Filtering - Advanced filtering, rate limiting, and performance optimization</li> </ul> <p>\u26a0\ufe0f Important: Always check the Data Models reference when working with API responses.</p>"},{"location":"#quick-start","title":"\u26a1 Quick Start","text":""},{"location":"#installation","title":"Installation","text":"<p>Using uv (recommended):</p> <pre><code>uv add dexscreen\n</code></pre> <p>Using pip:</p> <pre><code>pip install dexscreen\n</code></pre>"},{"location":"#basic-usage-examples","title":"Basic Usage Examples","text":"<p>\ud83d\udcca Get Token Price:</p> <pre><code>from dexscreen import DexscreenerClient\n\nclient = DexscreenerClient()\n\n# Get all USDC pairs on Ethereum\npairs = client.get_pairs_by_token_address(\n    \"ethereum\",\n    \"0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\"  # USDC\n)\n\nif pairs:\n    # Find the most liquid pair\n    best_pair = max(pairs, key=lambda p: p.liquidity.usd if p.liquidity else 0)\n    print(f\"USDC Price: ${best_pair.price_usd:.4f}\")\n    print(f\"24h Volume: ${best_pair.volume.h24:,.0f}\")\n</code></pre> <p>\ud83d\udd04 Real-time Monitoring:</p> <pre><code>import asyncio\nfrom dexscreen import DexscreenerClient, FilterPresets\n\nasync def price_alert(pair):\n    print(f\"{pair.base_token.symbol}: ${pair.price_usd:.4f}\")\n\nasync def main():\n    client = DexscreenerClient()\n\n    # Monitor USDC/WETH pair for price changes &gt; 0.1%\n    await client.subscribe_pairs(\n        chain_id=\"ethereum\",\n        pair_addresses=[\"0x88e6a0c2ddd26feeb64f039a2c41296fcb3f5640\"],\n        callback=price_alert,\n        filter=FilterPresets.significant_price_changes(0.001)  # 0.1%\n    )\n\n    await asyncio.sleep(60)  # Monitor for 1 minute\n    await client.close_streams()\n\nasyncio.run(main())\n</code></pre> <p>\ud83d\udcd6 Learn More: See Examples for complete, production-ready code examples.</p> <p>\ud83d\udd0d Need Help? Check our troubleshooting section below or browse the Examples for common patterns.</p>"},{"location":"#api-quick-reference","title":"\ud83d\udcca API Quick Reference","text":""},{"location":"#query-methods-full-reference","title":"\ud83d\udd0d Query Methods (Full Reference)","text":"Method Description Rate Limit Use Case <code>get_pair(address)</code> Get pair by address (any chain) 300/min Quick price check <code>get_pair_by_pair_address(chain_id, pair_address)</code> Get specific pair on specific chain 300/min Detailed pair info <code>get_pairs_by_token_address(chain_id, token_address)</code> Get all pairs for a token 300/min Token analysis <code>search_pairs(query)</code> Search pairs by name/symbol/address 300/min Token discovery <code>get_latest_token_profiles()</code> Latest token profiles 60/min New token tracking <code>get_latest_boosted_tokens()</code> Latest boosted tokens 60/min Promoted tokens"},{"location":"#streaming-methods-full-reference","title":"\ud83d\udce1 Streaming Methods (Full Reference)","text":"Method Description Best For <code>subscribe_pairs(chain_id, pair_addresses, callback)</code> Monitor specific pairs Price alerts, trading <code>subscribe_tokens(chain_id, token_addresses, callback)</code> Monitor all pairs of tokens Token monitoring <code>unsubscribe_pairs(chain_id, pair_addresses)</code> Stop monitoring pairs Dynamic management <code>unsubscribe_tokens(chain_id, token_addresses)</code> Stop monitoring tokens Dynamic management <code>get_active_subscriptions()</code> List active subscriptions Debugging, monitoring <code>close_streams()</code> Clean up all connections Cleanup, shutdown <p>\u26a0\ufe0f Rate Limits: The SDK automatically handles rate limiting with intelligent retry logic.</p>"},{"location":"#key-features","title":"\ud83d\udd11 Key Features","text":""},{"location":"#core-functionality","title":"\u2728 Core Functionality","text":"<ul> <li>\ud83c\udf10 Complete API Coverage - All Dexscreener endpoints with full feature parity</li> <li>\u26a1 Real-time Updates - HTTP-based streaming with configurable polling intervals</li> <li>\ud83c\udfaf Smart Filtering - Client-side filtering with customizable thresholds to reduce noise</li> <li>\ud83d\udd17 Multi-chain Support - Monitor multiple blockchains simultaneously with independent configurations</li> </ul>"},{"location":"#reliability-performance","title":"\ud83d\udee1\ufe0f Reliability &amp; Performance","text":"<ul> <li>\ud83d\udea6 Automatic Rate Limiting - Intelligent retry logic with exponential backoff</li> <li>\ud83d\udd75\ufe0f Browser Impersonation - Advanced anti-bot bypass using curl_cffi</li> <li>\ud83d\udd12 Type Safety - Full Pydantic model validation with comprehensive error handling</li> <li>\ud83d\udcca Batch Operations - Efficient batch processing for multiple queries</li> </ul>"},{"location":"#developer-experience","title":"\ud83c\udfa8 Developer Experience","text":"<ul> <li>\ud83d\udc0d Async/Sync Support - Both synchronous and asynchronous APIs</li> <li>\ud83d\udcdd Rich Documentation - Comprehensive guides with practical examples</li> <li>\ud83d\udd27 Flexible Configuration - Customizable filters, intervals, and callbacks</li> <li>\ud83d\udc1b Debug-Friendly - Detailed logging and error messages</li> </ul>"},{"location":"#common-use-cases","title":"\ud83d\udee0\ufe0f Common Use Cases","text":""},{"location":"#trading-defi","title":"\ud83d\udcb0 Trading &amp; DeFi","text":"<p>\ud83d\udcc8 Price Monitoring - Complete Example</p> <pre><code># Track significant price movements (1% threshold)\nawait client.subscribe_pairs(\n    chain_id=\"ethereum\",\n    pair_addresses=[\"0x88e6a0c2ddd26feeb64f039a2c41296fcb3f5640\"],\n    callback=price_alert,\n    filter=FilterPresets.significant_price_changes(0.01)\n)\n</code></pre> <p>\ud83d\udd04 Arbitrage Detection - Complete Example</p> <pre><code># Monitor USDC across multiple chains for price differences\nchains = [\"ethereum\", \"polygon\", \"arbitrum\"]\nfor chain in chains:\n    await client.subscribe_pairs(chain, usdc_pairs[chain], arbitrage_callback)\n</code></pre>"},{"location":"#analytics-research","title":"\ud83d\udcca Analytics &amp; Research","text":"<p>\ud83d\udd0d New Token Discovery - Complete Example</p> <pre><code># Monitor all pairs of a token for new DEX listings\nawait client.subscribe_tokens(\n    chain_id=\"solana\",\n    token_addresses=[\"JUPyiwrYJFskUPiHa7hkeR8VUtAeFoSYbKedZNsDvCN\"],\n    callback=new_pair_callback\n)\n</code></pre> <p>\ud83d\udcc8 Portfolio Tracking - Complete Example</p> <pre><code># Track multiple assets with custom filters per chain\nfor chain_id, config in portfolio_config.items():\n    await client.subscribe_pairs(\n        chain_id=chain_id,\n        pair_addresses=config['pairs'],\n        callback=portfolio_callback,\n        filter=config['filter']\n    )\n</code></pre>"},{"location":"#monitoring-alerts","title":"\ud83d\udea8 Monitoring &amp; Alerts","text":"<p>\u26a0\ufe0f Volume Surge Detection - Complete Example</p> <pre><code># Detect unusual trading activity\nvolume_config = FilterConfig(\n    change_fields=[\"volume.m5\", \"volume.h1\"],\n    volume_change_threshold=0.50  # 50% volume increase\n)\n</code></pre> <p>\ud83d\udca7 Liquidity Monitoring - Complete Example</p> <pre><code># Track liquidity additions/removals\nliquidity_config = FilterConfig(\n    change_fields=[\"liquidity.usd\"],\n    liquidity_change_threshold=0.10  # 10% liquidity change\n)\n</code></pre> <p>\ud83d\udd17 More Examples: Visit the Examples page for complete, production-ready implementations.</p> <p>\ud83d\udcca Performance Tips: See our performance optimization section and filtering guide for best practices.</p>"},{"location":"#best-practices","title":"Best Practices","text":""},{"location":"#performance-optimization","title":"\u26a1 Performance Optimization","text":"<ol> <li>\ud83c\udfaf Use Appropriate Intervals</li> </ol> <pre><code># High-frequency trading: 0.2s\ninterval=0.2\n\n# Portfolio monitoring: 5-10s\ninterval=5.0\n\n# Long-term alerts: 30-60s\ninterval=30.0\n</code></pre> <ol> <li>\ud83d\udd0d Apply Smart Filtering - Learn more</li> </ol> <pre><code># Only significant changes\nfilter=FilterPresets.significant_price_changes(0.01)\n\n# Rate-limited updates\nfilter=FilterPresets.rate_limited(1.0)  # Max 1/second\n</code></pre>"},{"location":"#error-handling-resource-management","title":"\ud83d\udee1\ufe0f Error Handling &amp; Resource Management","text":"<ol> <li>\ud83d\udea8 Handle Errors Gracefully</li> </ol> <pre><code>async def safe_callback(pair):\n    try:\n        await process_update(pair)\n    except Exception as e:\n        logger.error(f\"Callback error: {e}\")\n        # Don't let errors crash subscriptions\n</code></pre> <ol> <li>\ud83e\uddf9 Clean Up Resources</li> </ol> <pre><code>try:\n    await client.subscribe_pairs(...)\n    await asyncio.sleep(300)  # Run for 5 minutes\nfinally:\n    await client.close_streams()  # Always cleanup\n</code></pre>"},{"location":"#check-active-subscriptions","title":"Check active subscriptions","text":"<pre><code>active = client.get_active_subscriptions()\nprint(f\"Active subscriptions: {len(active)}\")\n</code></pre>"},{"location":"#development-guidelines","title":"\ud83c\udfaf Development Guidelines","text":"<ul> <li>Rate Limits: SDK handles automatically, but monitor your usage</li> <li>Type Safety: Use type hints for better IDE support</li> <li>Testing: Use small intervals and short durations during development</li> <li>Logging: Enable debug logging for troubleshooting</li> </ul> <p>\ud83d\udcd6 Deep Dive: Read the Getting Started Guide for detailed setup instructions.</p>"},{"location":"#external-resources","title":"\ud83d\udd17 External Resources","text":""},{"location":"#documentation-code","title":"\ud83d\udcda Documentation &amp; Code","text":"<ul> <li>\ud83d\udcd6 Complete API Documentation - Detailed method reference</li> <li>\ud83c\udfaf Getting Started Tutorial - Step-by-step setup guide</li> <li>\ud83d\udca1 Practical Examples - Production-ready code samples</li> <li>GitHub Repository - Source code and issues</li> </ul>"},{"location":"#related-services","title":"\ud83c\udf10 Related Services","text":"<ul> <li>Dexscreener.com - Official Dexscreener platform</li> <li>Dexscreener API Docs - Upstream API documentation</li> <li>PyPI Package - Official package repository</li> </ul>"},{"location":"#need-help","title":"Need Help?","text":"Issue Type Resource Getting Started Getting Started Guide API Questions Query API or Streaming API Code Examples Examples Page Bug Reports GitHub Issues Feature Requests GitHub Discussions"},{"location":"#license","title":"\ud83d\udcc4 License","text":"<p>MIT License - See LICENSE file for complete terms and conditions.</p> <p>\ud83d\ude4f Contributing: We welcome contributions! Please read our contributing guidelines in the GitHub repository.</p>"},{"location":"examples/","title":"Complete Examples","text":"<p>This page contains complete, working examples for common use cases with Dexscreen.</p>"},{"location":"examples/#basic-usage","title":"Basic Usage","text":""},{"location":"examples/#simple-price-check","title":"Simple Price Check","text":"<pre><code>from dexscreen import DexscreenerClient\n\ndef check_token_price():\n    client = DexscreenerClient()\n\n    # Get pairs for a token\n    pairs = client.get_pairs_by_token_address(\n        \"ethereum\",\n        \"A0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\"  # USDC\n    )\n\n    if pairs:\n        # Find the most liquid pair\n        best_pair = max(pairs, key=lambda p: p.liquidity.usd if p.liquidity else 0)\n        print(f\"Most liquid USDC pair: {best_pair.base_token.symbol}/{best_pair.quote_token.symbol}\")\n        print(f\"DEX: {best_pair.dex_id}\")\n        print(f\"Price: ${best_pair.price_usd:,.4f}\")\n        print(f\"Liquidity: ${best_pair.liquidity.usd:,.0f}\")\n\nif __name__ == \"__main__\":\n    check_token_price()\n</code></pre>"},{"location":"examples/#search-and-analyze","title":"Search and Analyze","text":"<pre><code>import asyncio\nfrom dexscreen import DexscreenerClient\n\nasync def analyze_search_results():\n    client = DexscreenerClient()\n\n    # Search for PEPE tokens\n    results = await client.search_pairs_async(\"PEPE\")\n\n    # Filter and sort by liquidity\n    liquid_pairs = [p for p in results if p.liquidity and p.liquidity.usd &gt; 50_000]\n    liquid_pairs.sort(key=lambda p: p.liquidity.usd, reverse=True)\n\n    print(f\"Found {len(liquid_pairs)} liquid PEPE pairs\\n\")\n\n    for pair in liquid_pairs[:5]:\n        print(f\"{pair.chain_id} - {pair.dex_id}\")\n        print(f\"  Pair: {pair.base_token.symbol}/{pair.quote_token.symbol}\")\n        print(f\"  Price: ${pair.price_usd:,.8f}\")\n        print(f\"  24h Volume: ${pair.volume.h24:,.0f}\")\n        print(f\"  Liquidity: ${pair.liquidity.usd:,.0f}\")\n        print(f\"  24h Change: {pair.price_change.h24:+.2f}%\")\n        print()\n\nif __name__ == \"__main__\":\n    asyncio.run(analyze_search_results())\n</code></pre>"},{"location":"examples/#price-monitoring","title":"Price Monitoring","text":""},{"location":"examples/#real-time-price-tracker","title":"Real-time Price Tracker","text":"<pre><code>import asyncio\nfrom datetime import datetime\nfrom dexscreen import DexscreenerClient, FilterPresets\n\nclass PriceTracker:\n    def __init__(self):\n        self.client = DexscreenerClient()\n        self.price_history = []\n        self.alert_threshold = 0.05  # 5% change\n\n    def handle_price_update(self, pair):\n        \"\"\"Process price updates\"\"\"\n        timestamp = datetime.now()\n        self.price_history.append({\n            'time': timestamp,\n            'price': pair.price_usd,\n            'volume': pair.volume.h24\n        })\n\n        # Keep last 100 entries\n        if len(self.price_history) &gt; 100:\n            self.price_history.pop(0)\n\n        # Check for significant moves\n        if len(self.price_history) &gt;= 2:\n            prev_price = self.price_history[-2]['price']\n            current_price = pair.price_usd\n            change = (current_price - prev_price) / prev_price\n\n            if abs(change) &gt;= self.alert_threshold:\n                self.send_alert(pair, change)\n\n        # Display current status\n        print(f\"[{timestamp.strftime('%H:%M:%S')}] \"\n              f\"{pair.base_token.symbol}: ${pair.price_usd:,.4f} \"\n              f\"(24h: {pair.price_change.h24:+.2f}%)\")\n\n    def send_alert(self, pair, change):\n        \"\"\"Send price alert\"\"\"\n        direction = \"\ud83d\udcc8\" if change &gt; 0 else \"\ud83d\udcc9\"\n        print(f\"\\n{direction} ALERT: {pair.base_token.symbol} moved {change:.2%}!\\n\")\n\n    async def start_monitoring(self, chain_id, pair_address):\n        \"\"\"Start monitoring a pair\"\"\"\n        print(f\"Starting price monitor for {pair_address} on {chain_id}\")\n\n        await self.client.subscribe_pairs(\n            chain_id=chain_id,\n            pair_addresses=[pair_address],\n            callback=self.handle_price_update,\n            filter=FilterPresets.significant_price_changes(0.001),  # 0.1% changes\n            interval=0.5  # Check every 0.5 seconds\n        )\n\n        # Run for 5 minutes\n        await asyncio.sleep(300)\n        await self.client.close_streams()\n\n        # Show summary\n        if self.price_history:\n            prices = [h['price'] for h in self.price_history]\n            print(f\"\\nSession Summary:\")\n            print(f\"  Starting Price: ${prices[0]:,.4f}\")\n            print(f\"  Ending Price: ${prices[-1]:,.4f}\")\n            print(f\"  Min Price: ${min(prices):,.4f}\")\n            print(f\"  Max Price: ${max(prices):,.4f}\")\n            print(f\"  Price Updates: {len(prices)}\")\n\nasync def main():\n    tracker = PriceTracker()\n    await tracker.start_monitoring(\n        \"ethereum\",\n        \"0x88e6a0c2ddd26feeb64f039a2c41296fcb3f5640\"  # USDC/WETH\n    )\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"examples/#arbitrage-detection","title":"Arbitrage Detection","text":""},{"location":"examples/#cross-chain-arbitrage-scanner","title":"Cross-Chain Arbitrage Scanner","text":"<pre><code>import asyncio\nfrom collections import defaultdict\nfrom dexscreen import DexscreenerClient\n\nclass ArbitrageScanner:\n    def __init__(self, spread_threshold=0.01):  # 1% minimum spread\n        self.client = DexscreenerClient()\n        self.spread_threshold = spread_threshold\n        self.prices_by_chain = defaultdict(dict)\n        self.opportunities = []\n\n    async def scan_token(self, token_symbol, token_addresses):\n        \"\"\"Scan a token across multiple chains\"\"\"\n        print(f\"Scanning {token_symbol} for arbitrage opportunities...\\n\")\n\n        # Fetch pairs from all chains concurrently\n        tasks = []\n        for chain_id, token_address in token_addresses.items():\n            task = self.client.get_pairs_by_token_address_async(chain_id, token_address)\n            tasks.append((chain_id, task))\n\n        # Process results\n        for chain_id, task in tasks:\n            try:\n                pairs = await task\n                if pairs:\n                    # Get the most liquid pair\n                    best_pair = max(pairs, key=lambda p: p.liquidity.usd if p.liquidity else 0)\n\n                    if best_pair.price_usd:\n                        self.prices_by_chain[token_symbol][chain_id] = {\n                            'price': best_pair.price_usd,\n                            'pair': best_pair,\n                            'liquidity': best_pair.liquidity.usd if best_pair.liquidity else 0\n                        }\n            except Exception as e:\n                print(f\"Error fetching {chain_id}: {e}\")\n\n        # Find arbitrage opportunities\n        self.find_opportunities(token_symbol)\n\n    def find_opportunities(self, token_symbol):\n        \"\"\"Find arbitrage opportunities for a token\"\"\"\n        prices = self.prices_by_chain[token_symbol]\n\n        if len(prices) &lt; 2:\n            print(f\"Need at least 2 chains with prices for {token_symbol}\")\n            return\n\n        # Find min and max prices\n        chains = list(prices.keys())\n        for i in range(len(chains)):\n            for j in range(i + 1, len(chains)):\n                chain1, chain2 = chains[i], chains[j]\n                price1 = prices[chain1]['price']\n                price2 = prices[chain2]['price']\n\n                # Calculate spread\n                if price1 &gt; price2:\n                    buy_chain, sell_chain = chain2, chain1\n                    buy_price, sell_price = price2, price1\n                else:\n                    buy_chain, sell_chain = chain1, chain2\n                    buy_price, sell_price = price1, price2\n\n                spread = (sell_price - buy_price) / buy_price\n\n                if spread &gt;= self.spread_threshold:\n                    opportunity = {\n                        'token': token_symbol,\n                        'buy_chain': buy_chain,\n                        'sell_chain': sell_chain,\n                        'buy_price': buy_price,\n                        'sell_price': sell_price,\n                        'spread': spread,\n                        'buy_liquidity': prices[buy_chain]['liquidity'],\n                        'sell_liquidity': prices[sell_chain]['liquidity']\n                    }\n                    self.opportunities.append(opportunity)\n                    self.print_opportunity(opportunity)\n\n    def print_opportunity(self, opp):\n        \"\"\"Print arbitrage opportunity\"\"\"\n        print(f\"\ud83c\udfaf ARBITRAGE OPPORTUNITY: {opp['token']}\")\n        print(f\"  Buy on {opp['buy_chain']}: ${opp['buy_price']:,.6f}\")\n        print(f\"  Sell on {opp['sell_chain']}: ${opp['sell_price']:,.6f}\")\n        print(f\"  Spread: {opp['spread']:.2%}\")\n        print(f\"  Buy Liquidity: ${opp['buy_liquidity']:,.0f}\")\n        print(f\"  Sell Liquidity: ${opp['sell_liquidity']:,.0f}\")\n        print()\n\nasync def main():\n    scanner = ArbitrageScanner(spread_threshold=0.005)  # 0.5% minimum\n\n    # Define tokens to scan (symbol -&gt; chain -&gt; address)\n    tokens_to_scan = {\n        \"USDC\": {\n            \"ethereum\": \"A0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\",\n            \"polygon\": \"2791Bca1f2de4661ED88A30C99A7a9449Aa84174\",\n            \"arbitrum\": \"FF970A61A04b1cA14834A43f5dE4533eBDDB5CC8\",\n            \"optimism\": \"7F5c764cBc14f9669B88837ca1490cCa17c31607\"\n        },\n        \"WETH\": {\n            \"ethereum\": \"C02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\",\n            \"polygon\": \"7ceB23fD6bC0adD59E62ac25578270cFf1b9f619\",\n            \"arbitrum\": \"82aF49447D8a07e3bd95BD0d56f35241523fBab1\",\n            \"optimism\": \"4200000000000000000000000000000000000006\"\n        }\n    }\n\n    # Scan each token\n    for token_symbol, addresses in tokens_to_scan.items():\n        await scanner.scan_token(token_symbol, addresses)\n        await asyncio.sleep(1)  # Rate limiting\n\n    # Summary\n    print(f\"\\nFound {len(scanner.opportunities)} arbitrage opportunities\")\n    if scanner.opportunities:\n        best = max(scanner.opportunities, key=lambda x: x['spread'])\n        print(f\"Best opportunity: {best['token']} with {best['spread']:.2%} spread\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"examples/#portfolio-tracking","title":"Portfolio Tracking","text":""},{"location":"examples/#multi-asset-portfolio-monitor","title":"Multi-Asset Portfolio Monitor","text":"<pre><code>import asyncio\nfrom datetime import datetime\nfrom typing import Dict, List\nfrom dexscreen import DexscreenerClient, FilterPresets\n\nclass PortfolioMonitor:\n    def __init__(self):\n        self.client = DexscreenerClient()\n        self.portfolio = {}  # address -&gt; position info\n        self.portfolio_value = 0\n        self.initial_value = 0\n\n    def add_position(self, chain_id: str, pair_address: str, amount: float, entry_price: float):\n        \"\"\"Add a position to the portfolio\"\"\"\n        self.portfolio[f\"{chain_id}:{pair_address}\"] = {\n            'chain_id': chain_id,\n            'pair_address': pair_address,\n            'amount': amount,\n            'entry_price': entry_price,\n            'current_price': entry_price,\n            'pnl': 0,\n            'pnl_percent': 0\n        }\n        self.initial_value += amount * entry_price\n\n    def handle_update(self, pair):\n        \"\"\"Handle price updates for portfolio positions\"\"\"\n        key = f\"{pair.chain_id}:{pair.pair_address}\"\n        if key in self.portfolio:\n            position = self.portfolio[key]\n            old_price = position['current_price']\n            new_price = pair.price_usd\n\n            # Update position\n            position['current_price'] = new_price\n            position['pnl'] = (new_price - position['entry_price']) * position['amount']\n            position['pnl_percent'] = ((new_price - position['entry_price']) / position['entry_price']) * 100\n\n            # Only show significant changes\n            if abs(new_price - old_price) / old_price &gt; 0.001:  # 0.1% change\n                self.display_position_update(pair, position)\n\n    def display_position_update(self, pair, position):\n        \"\"\"Display position update\"\"\"\n        symbol = pair.base_token.symbol\n        pnl_emoji = \"\ud83d\udfe2\" if position['pnl'] &gt;= 0 else \"\ud83d\udd34\"\n\n        print(f\"[{datetime.now().strftime('%H:%M:%S')}] {symbol}: \"\n              f\"${position['current_price']:,.4f} \"\n              f\"{pnl_emoji} P&amp;L: ${position['pnl']:+,.2f} ({position['pnl_percent']:+.2f}%)\")\n\n    def calculate_portfolio_value(self):\n        \"\"\"Calculate total portfolio value\"\"\"\n        total = sum(p['amount'] * p['current_price'] for p in self.portfolio.values())\n        return total\n\n    def display_portfolio_summary(self):\n        \"\"\"Display portfolio summary\"\"\"\n        print(\"\\n\" + \"=\"*60)\n        print(\"PORTFOLIO SUMMARY\")\n        print(\"=\"*60)\n\n        current_value = self.calculate_portfolio_value()\n        total_pnl = current_value - self.initial_value\n        total_pnl_percent = (total_pnl / self.initial_value) * 100 if self.initial_value &gt; 0 else 0\n\n        print(f\"Initial Value: ${self.initial_value:,.2f}\")\n        print(f\"Current Value: ${current_value:,.2f}\")\n        print(f\"Total P&amp;L: ${total_pnl:+,.2f} ({total_pnl_percent:+.2f}%)\")\n        print(\"\\nPositions:\")\n\n        for key, position in self.portfolio.items():\n            value = position['amount'] * position['current_price']\n            weight = (value / current_value) * 100 if current_value &gt; 0 else 0\n            print(f\"  {key}: ${value:,.2f} ({weight:.1f}%) \"\n                  f\"P&amp;L: ${position['pnl']:+,.2f} ({position['pnl_percent']:+.2f}%)\")\n\n        print(\"=\"*60)\n\n    async def start_monitoring(self):\n        \"\"\"Start monitoring all portfolio positions\"\"\"\n        print(\"Starting portfolio monitor...\")\n\n        # Subscribe to all positions\n        for key, position in self.portfolio.items():\n            await self.client.subscribe_pairs(\n                chain_id=position['chain_id'],\n                pair_addresses=[position['pair_address']],\n                callback=self.handle_update,\n                filter=FilterPresets.ui_friendly(),  # Balanced updates for UI\n                interval=1.0\n            )\n\n        # Run for 5 minutes with periodic summaries\n        for i in range(5):\n            await asyncio.sleep(60)\n            self.display_portfolio_summary()\n\n        await self.client.close_streams()\n\nasync def main():\n    monitor = PortfolioMonitor()\n\n    # Example portfolio\n    monitor.add_position(\n        \"ethereum\",\n        \"0x88e6a0c2ddd26feeb64f039a2c41296fcb3f5640\",  # USDC/WETH\n        1000,  # 1000 USDC\n        0.0004  # Entry price\n    )\n\n    monitor.add_position(\n        \"ethereum\",\n        \"0x11b815efb8f581194ae79006d24e0d814b7697f6\",  # WETH/USDT\n        0.5,  # 0.5 WETH\n        2500  # Entry price\n    )\n\n    await monitor.start_monitoring()\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"examples/#new-token-discovery","title":"New Token Discovery","text":""},{"location":"examples/#token-launch-monitor","title":"Token Launch Monitor","text":"<pre><code>import asyncio\nfrom datetime import datetime, timedelta\nfrom dexscreen import DexscreenerClient\n\nclass TokenLaunchMonitor:\n    def __init__(self):\n        self.client = DexscreenerClient()\n        self.new_tokens = []\n        self.monitored_tokens = set()\n\n    async def scan_new_tokens(self):\n        \"\"\"Scan for newly launched tokens\"\"\"\n        print(\"Scanning for new token launches...\\n\")\n\n        # Get latest token profiles\n        profiles = await self.client.get_latest_token_profiles_async()\n\n        for token in profiles:\n            if token.token_address not in self.monitored_tokens:\n                # Get pair data\n                pairs = await self.client.get_pairs_by_token_address_async(\n                    token.chain_id,\n                    token.token_address\n                )\n\n                if pairs:\n                    # Analyze the token\n                    analysis = await self.analyze_new_token(token, pairs)\n                    if analysis['is_interesting']:\n                        self.new_tokens.append(analysis)\n                        self.print_token_alert(analysis)\n\n                self.monitored_tokens.add(token.token_address)\n                await asyncio.sleep(0.5)  # Rate limiting\n\n    async def analyze_new_token(self, token_info, pairs):\n        \"\"\"Analyze a new token for potential\"\"\"\n        # Get the most liquid pair\n        best_pair = max(pairs, key=lambda p: p.liquidity.usd if p.liquidity else 0)\n\n        # Calculate metrics\n        total_liquidity = sum(p.liquidity.usd for p in pairs if p.liquidity and p.liquidity.usd)\n        total_volume = sum(p.volume.h24 for p in pairs if p.volume.h24)\n        pair_count = len(pairs)\n\n        # Check if created recently (within 24 hours)\n        is_new = False\n        if best_pair.pair_created_at:\n            age = datetime.now() - best_pair.pair_created_at\n            is_new = age &lt; timedelta(days=1)\n\n        # Determine if interesting\n        is_interesting = (\n            total_liquidity &gt; 50_000 and  # Minimum $50k liquidity\n            total_volume &gt; 100_000 and     # Minimum $100k volume\n            pair_count &gt;= 2                # At least 2 pairs\n        )\n\n        return {\n            'token_info': token_info,\n            'best_pair': best_pair,\n            'total_liquidity': total_liquidity,\n            'total_volume': total_volume,\n            'pair_count': pair_count,\n            'is_new': is_new,\n            'is_interesting': is_interesting,\n            'price': best_pair.price_usd,\n            'price_change_24h': best_pair.price_change.h24\n        }\n\n    def print_token_alert(self, analysis):\n        \"\"\"Print alert for interesting token\"\"\"\n        token = analysis['token_info']\n\n        print(f\"\ud83d\ude80 NEW TOKEN ALERT: {token.token_address}\")\n        print(f\"  Chain: {token.chain_id}\")\n        print(f\"  Price: ${analysis['price']:,.8f}\")\n        print(f\"  24h Change: {analysis['price_change_24h']:+.2f}%\")\n        print(f\"  Total Liquidity: ${analysis['total_liquidity']:,.0f}\")\n        print(f\"  24h Volume: ${analysis['total_volume']:,.0f}\")\n        print(f\"  Number of Pairs: {analysis['pair_count']}\")\n\n        if token.description:\n            print(f\"  Description: {token.description[:100]}...\")\n\n        print(f\"  URL: {token.url}\")\n        print()\n\n    async def monitor_launches(self, duration_minutes=30):\n        \"\"\"Monitor for new launches for specified duration\"\"\"\n        start_time = datetime.now()\n        end_time = start_time + timedelta(minutes=duration_minutes)\n\n        print(f\"Monitoring new token launches for {duration_minutes} minutes...\")\n        print(f\"Start: {start_time.strftime('%Y-%m-%d %H:%M:%S')}\")\n        print(f\"End: {end_time.strftime('%Y-%m-%d %H:%M:%S')}\\n\")\n\n        while datetime.now() &lt; end_time:\n            await self.scan_new_tokens()\n\n            # Wait before next scan\n            await asyncio.sleep(60)  # Scan every minute\n\n        # Final summary\n        print(f\"\\nMonitoring complete. Found {len(self.new_tokens)} interesting tokens:\")\n        for token in self.new_tokens:\n            print(f\"- {token['token_info'].token_address} on {token['token_info'].chain_id}\")\n\nasync def main():\n    monitor = TokenLaunchMonitor()\n    await monitor.monitor_launches(duration_minutes=5)\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"examples/#volume-analysis","title":"Volume Analysis","text":""},{"location":"examples/#volume-surge-detector","title":"Volume Surge Detector","text":"<pre><code>import asyncio\nfrom collections import defaultdict, deque\nfrom dexscreen import DexscreenerClient, FilterConfig\n\nclass VolumeSurgeDetector:\n    def __init__(self, surge_multiplier=3.0):\n        self.client = DexscreenerClient()\n        self.surge_multiplier = surge_multiplier\n        self.volume_history = defaultdict(lambda: deque(maxlen=12))  # 12 x 5min = 1 hour\n        self.surge_alerts = []\n\n    def calculate_volume_surge(self, pair):\n        \"\"\"Calculate if there's a volume surge\"\"\"\n        history = self.volume_history[pair.pair_address]\n        current_volume = pair.volume.m5 or 0\n\n        # Add to history\n        history.append(current_volume)\n\n        if len(history) &lt; 6:  # Need at least 30 minutes of data\n            return None\n\n        # Compare recent vs older volume\n        recent_avg = sum(list(history)[-3:]) / 3  # Last 15 minutes\n        older_avg = sum(list(history)[-6:-3]) / 3  # Previous 15 minutes\n\n        if older_avg &gt; 0:\n            surge_ratio = recent_avg / older_avg\n            if surge_ratio &gt;= self.surge_multiplier:\n                return surge_ratio\n\n        return None\n\n    def handle_volume_update(self, pair):\n        \"\"\"Process volume updates\"\"\"\n        surge = self.calculate_volume_surge(pair)\n\n        if surge:\n            alert = {\n                'timestamp': datetime.now(),\n                'pair': pair,\n                'surge_ratio': surge,\n                '5m_volume': pair.volume.m5,\n                '24h_volume': pair.volume.h24\n            }\n            self.surge_alerts.append(alert)\n            self.print_surge_alert(alert)\n\n    def print_surge_alert(self, alert):\n        \"\"\"Print volume surge alert\"\"\"\n        pair = alert['pair']\n        print(f\"\\n\ud83d\udd0a VOLUME SURGE DETECTED at {alert['timestamp'].strftime('%H:%M:%S')}\")\n        print(f\"  Pair: {pair.base_token.symbol}/{pair.quote_token.symbol} on {pair.chain_id}\")\n        print(f\"  Surge: {alert['surge_ratio']:.1f}x normal volume\")\n        print(f\"  5min Volume: ${alert['5m_volume']:,.0f}\")\n        print(f\"  24h Volume: ${alert['24h_volume']:,.0f}\")\n        print(f\"  Current Price: ${pair.price_usd:,.6f}\")\n        print(f\"  Price Change 1h: {pair.price_change.h1:+.2f}%\")\n        print()\n\n    async def monitor_tokens(self, chain_id, token_addresses):\n        \"\"\"Monitor tokens for volume surges\"\"\"\n        print(f\"Monitoring {len(token_addresses)} tokens on {chain_id} for volume surges...\\n\")\n\n        # Get initial pairs for each token\n        all_pairs = []\n        for token_address in token_addresses:\n            pairs = await self.client.get_pairs_by_token_address_async(chain_id, token_address)\n            # Get top 3 most liquid pairs for each token\n            liquid_pairs = sorted(\n                [p for p in pairs if p.liquidity and p.liquidity.usd &gt; 10_000],\n                key=lambda p: p.liquidity.usd,\n                reverse=True\n            )[:3]\n            all_pairs.extend(liquid_pairs)\n\n        print(f\"Monitoring {len(all_pairs)} pairs total\\n\")\n\n        # Subscribe to volume updates\n        pair_addresses = [p.pair_address for p in all_pairs]\n\n        filter_config = FilterConfig(\n            change_fields=[\"volume.m5\", \"volume.h1\"],\n            volume_change_threshold=0.10  # 10% volume change\n        )\n\n        await self.client.subscribe_pairs(\n            chain_id=chain_id,\n            pair_addresses=pair_addresses,\n            callback=self.handle_volume_update,\n            filter=filter_config,\n            interval=1.0\n        )\n\n        # Monitor for 10 minutes\n        await asyncio.sleep(600)\n        await self.client.close_streams()\n\n        # Summary\n        print(f\"\\nDetected {len(self.surge_alerts)} volume surges\")\n        if self.surge_alerts:\n            biggest_surge = max(self.surge_alerts, key=lambda x: x['surge_ratio'])\n            print(f\"Biggest surge: {biggest_surge['surge_ratio']:.1f}x on \"\n                  f\"{biggest_surge['pair'].base_token.symbol}\")\n\nasync def main():\n    detector = VolumeSurgeDetector(surge_multiplier=2.5)  # 2.5x surge threshold\n\n    # Monitor popular tokens on Ethereum\n    await detector.monitor_tokens(\n        \"ethereum\",\n        [\n            \"A0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\",  # USDC\n            \"C02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\",  # WETH\n            \"6B175474E89094C44Da98b954EedeAC495271d0F\",  # DAI\n            \"dAC17F958D2ee523a2206206994597C13D831ec7\"   # USDT\n        ]\n    )\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"examples/#liquidity-monitoring","title":"Liquidity Monitoring","text":""},{"location":"examples/#liquidity-change-tracker","title":"Liquidity Change Tracker","text":"<pre><code>import asyncio\nfrom datetime import datetime\nfrom dexscreen import DexscreenerClient, FilterConfig\n\nclass LiquidityTracker:\n    def __init__(self):\n        self.client = DexscreenerClient()\n        self.liquidity_snapshots = {}\n        self.significant_changes = []\n\n    def handle_liquidity_update(self, pair):\n        \"\"\"Handle liquidity updates\"\"\"\n        if not pair.liquidity or not pair.liquidity.usd:\n            return\n\n        key = f\"{pair.chain_id}:{pair.pair_address}\"\n        current_liquidity = pair.liquidity.usd\n\n        # Check for significant change\n        if key in self.liquidity_snapshots:\n            prev_liquidity = self.liquidity_snapshots[key]['liquidity']\n            change = (current_liquidity - prev_liquidity) / prev_liquidity\n\n            if abs(change) &gt; 0.1:  # 10% change\n                event = {\n                    'timestamp': datetime.now(),\n                    'pair': pair,\n                    'prev_liquidity': prev_liquidity,\n                    'current_liquidity': current_liquidity,\n                    'change_percent': change * 100,\n                    'type': 'addition' if change &gt; 0 else 'removal'\n                }\n                self.significant_changes.append(event)\n                self.print_liquidity_event(event)\n\n        # Update snapshot\n        self.liquidity_snapshots[key] = {\n            'liquidity': current_liquidity,\n            'timestamp': datetime.now(),\n            'pair': pair\n        }\n\n    def print_liquidity_event(self, event):\n        \"\"\"Print liquidity change event\"\"\"\n        pair = event['pair']\n        emoji = \"\ud83d\udcb0\" if event['type'] == 'addition' else \"\ud83d\udcb8\"\n\n        print(f\"\\n{emoji} LIQUIDITY {event['type'].upper()}\")\n        print(f\"  Time: {event['timestamp'].strftime('%H:%M:%S')}\")\n        print(f\"  Pair: {pair.base_token.symbol}/{pair.quote_token.symbol} on {pair.dex_id}\")\n        print(f\"  Previous: ${event['prev_liquidity']:,.0f}\")\n        print(f\"  Current: ${event['current_liquidity']:,.0f}\")\n        print(f\"  Change: {event['change_percent']:+.1f}%\")\n        print(f\"  Price Impact: Current price ${pair.price_usd:,.6f}\")\n        print()\n\n    async def monitor_liquidity_changes(self, pairs_to_monitor):\n        \"\"\"Monitor liquidity changes for specific pairs\"\"\"\n        print(f\"Monitoring liquidity for {len(pairs_to_monitor)} pairs...\\n\")\n\n        # Group by chain\n        by_chain = defaultdict(list)\n        for chain_id, pair_address in pairs_to_monitor:\n            by_chain[chain_id].append(pair_address)\n\n        # Subscribe to each chain\n        for chain_id, addresses in by_chain.items():\n            filter_config = FilterConfig(\n                change_fields=[\"liquidity.usd\", \"liquidity.base\", \"liquidity.quote\"],\n                liquidity_change_threshold=0.05,  # 5% change threshold\n                max_updates_per_second=1.0\n            )\n\n            await self.client.subscribe_pairs(\n                chain_id=chain_id,\n                pair_addresses=addresses,\n                callback=self.handle_liquidity_update,\n                filter=filter_config,\n                interval=2.0\n            )\n\n        # Monitor for 10 minutes\n        await asyncio.sleep(600)\n        await self.client.close_streams()\n\n        # Summary\n        self.print_summary()\n\n    def print_summary(self):\n        \"\"\"Print monitoring summary\"\"\"\n        print(\"\\n\" + \"=\"*60)\n        print(\"LIQUIDITY MONITORING SUMMARY\")\n        print(\"=\"*60)\n\n        if not self.significant_changes:\n            print(\"No significant liquidity changes detected\")\n            return\n\n        # Calculate statistics\n        additions = [e for e in self.significant_changes if e['type'] == 'addition']\n        removals = [e for e in self.significant_changes if e['type'] == 'removal']\n\n        print(f\"Total Events: {len(self.significant_changes)}\")\n        print(f\"Liquidity Additions: {len(additions)}\")\n        print(f\"Liquidity Removals: {len(removals)}\")\n\n        if additions:\n            biggest_add = max(additions, key=lambda x: x['change_percent'])\n            print(f\"\\nBiggest Addition: {biggest_add['change_percent']:+.1f}% on \"\n                  f\"{biggest_add['pair'].base_token.symbol}\")\n\n        if removals:\n            biggest_remove = min(removals, key=lambda x: x['change_percent'])\n            print(f\"Biggest Removal: {biggest_remove['change_percent']:+.1f}% on \"\n                  f\"{biggest_remove['pair'].base_token.symbol}\")\n\n        print(\"=\"*60)\n\nasync def main():\n    tracker = LiquidityTracker()\n\n    # Monitor major pairs\n    pairs_to_monitor = [\n        (\"ethereum\", \"0x88e6a0c2ddd26feeb64f039a2c41296fcb3f5640\"),  # USDC/WETH Uniswap V3\n        (\"ethereum\", \"0x11b815efb8f581194ae79006d24e0d814b7697f6\"),  # WETH/USDT Uniswap V3\n        (\"ethereum\", \"0x4e68ccd3e89f51c3074ca5072bbac773960dfa36\"),  # WETH/USDT Uniswap V3\n        (\"bsc\", \"0x7213a321f1855cf1779f42c0cd85d3d95291d34c\"),        # USDT/USDC PancakeSwap\n        (\"polygon\", \"0x45dda9cb7c25131df268515131f647d726f50608\"),     # USDC/WETH QuickSwap\n    ]\n\n    await tracker.monitor_liquidity_changes(pairs_to_monitor)\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"examples/#alert-system","title":"Alert System","text":""},{"location":"examples/#comprehensive-alert-system","title":"Comprehensive Alert System","text":"<pre><code>import asyncio\nfrom datetime import datetime\nfrom enum import Enum\nfrom typing import List, Dict, Callable\nfrom dexscreen import DexscreenerClient, FilterConfig\n\nclass AlertType(Enum):\n    PRICE_INCREASE = \"price_increase\"\n    PRICE_DECREASE = \"price_decrease\"\n    VOLUME_SURGE = \"volume_surge\"\n    LIQUIDITY_CHANGE = \"liquidity_change\"\n    NEW_ATH = \"new_ath\"\n    LARGE_TRANSACTION = \"large_transaction\"\n\nclass AlertSystem:\n    def __init__(self):\n        self.client = DexscreenerClient()\n        self.alerts: List[Dict] = []\n        self.alert_handlers: Dict[AlertType, List[Callable]] = defaultdict(list)\n        self.price_history = defaultdict(list)\n        self.ath_tracker = {}\n\n    def register_handler(self, alert_type: AlertType, handler: Callable):\n        \"\"\"Register a handler for specific alert types\"\"\"\n        self.alert_handlers[alert_type].append(handler)\n\n    def create_alert(self, alert_type: AlertType, pair, data: Dict):\n        \"\"\"Create and dispatch an alert\"\"\"\n        alert = {\n            'type': alert_type,\n            'timestamp': datetime.now(),\n            'pair': pair,\n            'chain_id': pair.chain_id,\n            'symbol': pair.base_token.symbol,\n            'data': data\n        }\n\n        self.alerts.append(alert)\n\n        # Dispatch to handlers\n        for handler in self.alert_handlers[alert_type]:\n            try:\n                handler(alert)\n            except Exception as e:\n                print(f\"Error in alert handler: {e}\")\n\n    def check_price_alerts(self, pair):\n        \"\"\"Check for price-based alerts\"\"\"\n        key = f\"{pair.chain_id}:{pair.pair_address}\"\n\n        # Track price history\n        self.price_history[key].append(pair.price_usd)\n        if len(self.price_history[key]) &gt; 100:\n            self.price_history[key].pop(0)\n\n        # Check for new ATH\n        if key not in self.ath_tracker or pair.price_usd &gt; self.ath_tracker[key]:\n            if key in self.ath_tracker:  # Not first time\n                self.create_alert(AlertType.NEW_ATH, pair, {\n                    'new_ath': pair.price_usd,\n                    'previous_ath': self.ath_tracker[key],\n                    'increase': ((pair.price_usd - self.ath_tracker[key]) / self.ath_tracker[key]) * 100\n                })\n            self.ath_tracker[key] = pair.price_usd\n\n        # Check recent price changes\n        if len(self.price_history[key]) &gt;= 2:\n            recent_change = (pair.price_usd - self.price_history[key][-2]) / self.price_history[key][-2]\n\n            if recent_change &gt; 0.05:  # 5% increase\n                self.create_alert(AlertType.PRICE_INCREASE, pair, {\n                    'change_percent': recent_change * 100,\n                    'current_price': pair.price_usd\n                })\n            elif recent_change &lt; -0.05:  # 5% decrease\n                self.create_alert(AlertType.PRICE_DECREASE, pair, {\n                    'change_percent': recent_change * 100,\n                    'current_price': pair.price_usd\n                })\n\n    def check_volume_alerts(self, pair):\n        \"\"\"Check for volume-based alerts\"\"\"\n        # Volume surge detection\n        if pair.volume.m5 and pair.volume.h1:\n            hourly_avg_5min = pair.volume.h1 / 12  # Average 5-min volume in last hour\n            if pair.volume.m5 &gt; hourly_avg_5min * 3:  # 3x average\n                self.create_alert(AlertType.VOLUME_SURGE, pair, {\n                    'current_5m_volume': pair.volume.m5,\n                    'average_5m_volume': hourly_avg_5min,\n                    'surge_multiplier': pair.volume.m5 / hourly_avg_5min\n                })\n\n    def check_liquidity_alerts(self, pair):\n        \"\"\"Check for liquidity changes\"\"\"\n        if pair.liquidity and pair.liquidity.usd:\n            # This would need historical data to compare\n            # For demo, we'll check if liquidity is very low\n            if pair.liquidity.usd &lt; 50_000:\n                self.create_alert(AlertType.LIQUIDITY_CHANGE, pair, {\n                    'current_liquidity': pair.liquidity.usd,\n                    'warning': 'Low liquidity detected'\n                })\n\n    def comprehensive_check(self, pair):\n        \"\"\"Run all alert checks\"\"\"\n        self.check_price_alerts(pair)\n        self.check_volume_alerts(pair)\n        self.check_liquidity_alerts(pair)\n\n    async def monitor_with_alerts(self, chain_id: str, pair_addresses: List[str]):\n        \"\"\"Monitor pairs with comprehensive alerts\"\"\"\n        print(f\"Starting alert system for {len(pair_addresses)} pairs on {chain_id}\\n\")\n\n        # Configure filtering for relevant changes\n        filter_config = FilterConfig(\n            change_fields=[\"price_usd\", \"volume.m5\", \"volume.h1\", \"liquidity.usd\"],\n            price_change_threshold=0.001,  # 0.1% for high sensitivity\n            volume_change_threshold=0.10,   # 10% volume changes\n            max_updates_per_second=2.0\n        )\n\n        await self.client.subscribe_pairs(\n            chain_id=chain_id,\n            pair_addresses=pair_addresses,\n            callback=self.comprehensive_check,\n            filter=filter_config,\n            interval=0.5\n        )\n\n        # Run for specified duration\n        await asyncio.sleep(300)  # 5 minutes\n        await self.client.close_streams()\n\n        # Print summary\n        self.print_alert_summary()\n\n    def print_alert_summary(self):\n        \"\"\"Print summary of all alerts\"\"\"\n        print(\"\\n\" + \"=\"*60)\n        print(\"ALERT SUMMARY\")\n        print(\"=\"*60)\n\n        if not self.alerts:\n            print(\"No alerts triggered\")\n            return\n\n        # Group by type\n        by_type = defaultdict(list)\n        for alert in self.alerts:\n            by_type[alert['type']].append(alert)\n\n        for alert_type, alerts in by_type.items():\n            print(f\"\\n{alert_type.value.upper()}: {len(alerts)} alerts\")\n\n            # Show last 3 alerts of this type\n            for alert in alerts[-3:]:\n                print(f\"  [{alert['timestamp'].strftime('%H:%M:%S')}] \"\n                      f\"{alert['symbol']} on {alert['chain_id']}\")\n\n                # Type-specific details\n                if alert_type == AlertType.PRICE_INCREASE:\n                    print(f\"    +{alert['data']['change_percent']:.2f}% \"\n                          f\"to ${alert['data']['current_price']:,.6f}\")\n                elif alert_type == AlertType.VOLUME_SURGE:\n                    print(f\"    {alert['data']['surge_multiplier']:.1f}x normal volume\")\n                elif alert_type == AlertType.NEW_ATH:\n                    print(f\"    New ATH: ${alert['data']['new_ath']:,.6f} \"\n                          f\"(+{alert['data']['increase']:.2f}%)\")\n\n# Example handlers\ndef console_handler(alert: Dict):\n    \"\"\"Print alerts to console\"\"\"\n    emoji_map = {\n        AlertType.PRICE_INCREASE: \"\ud83d\udcc8\",\n        AlertType.PRICE_DECREASE: \"\ud83d\udcc9\",\n        AlertType.VOLUME_SURGE: \"\ud83d\udd0a\",\n        AlertType.LIQUIDITY_CHANGE: \"\ud83d\udca7\",\n        AlertType.NEW_ATH: \"\ud83d\ude80\",\n        AlertType.LARGE_TRANSACTION: \"\ud83d\udc0b\"\n    }\n\n    emoji = emoji_map.get(alert['type'], \"\ud83d\udce2\")\n    print(f\"\\n{emoji} ALERT: {alert['type'].value} - {alert['symbol']} \"\n          f\"at {alert['timestamp'].strftime('%H:%M:%S')}\")\n\nasync def main():\n    alert_system = AlertSystem()\n\n    # Register handlers\n    alert_system.register_handler(AlertType.PRICE_INCREASE, console_handler)\n    alert_system.register_handler(AlertType.PRICE_DECREASE, console_handler)\n    alert_system.register_handler(AlertType.VOLUME_SURGE, console_handler)\n    alert_system.register_handler(AlertType.NEW_ATH, console_handler)\n\n    # Monitor some active pairs\n    await alert_system.monitor_with_alerts(\n        \"ethereum\",\n        [\n            \"0x88e6a0c2ddd26feeb64f039a2c41296fcb3f5640\",  # USDC/WETH\n            \"0x11b815efb8f581194ae79006d24e0d814b7697f6\",  # WETH/USDT\n            \"0x4e68ccd3e89f51c3074ca5072bbac773960dfa36\"   # WETH/USDT\n        ]\n    )\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"examples/#next-steps","title":"Next Steps","text":"<p>These examples demonstrate various use cases for Dexscreen. You can:</p> <ol> <li>Combine examples - Mix monitoring with alerts, add database storage, etc.</li> <li>Extend functionality - Add notifications, web interfaces, trading bot integration</li> <li>Optimize performance - Use async operations, batch requests, smart filtering</li> <li>Scale up - Monitor more pairs, implement distributed systems</li> </ol> <p>For more details, see:</p> <ul> <li>Getting Started - Installation and basics</li> <li>Query API - All query methods</li> <li>Streaming API - Real-time subscriptions</li> <li>Filtering - Advanced filtering options</li> </ul>"},{"location":"getting-started/","title":"Getting Started with Dexscreen","text":"<p>This guide will help you get up and running with Dexscreen quickly, enabling you to monitor and analyze DeFi data with ease.</p>"},{"location":"getting-started/#installation","title":"Installation","text":""},{"location":"getting-started/#using-uv","title":"Using uv","text":"<pre><code>uv add dexscreen\n</code></pre>"},{"location":"getting-started/#using-pip","title":"Using pip","text":"<pre><code>pip install dexscreen\n</code></pre>"},{"location":"getting-started/#from-source","title":"From source","text":"<pre><code>git clone https://github.com/yourusername/dexscreen.git\ncd dexscreen\npip install -e .\n</code></pre>"},{"location":"getting-started/#basic-concepts","title":"Basic Concepts","text":"<p>Dexscreen provides two main ways to interact with Dexscreener data:</p> <ol> <li>Query API - One-time data fetching (synchronous or async) for:</li> <li>Current price checks</li> <li>Token discovery and search</li> <li>Snapshot data analysis</li> <li> <p>Historical data retrieval</p> </li> <li> <p>Streaming API - Real-time updates via HTTP polling for:</p> </li> <li>Real-time price monitoring</li> <li>Trading bots</li> <li>Alert systems</li> <li>Portfolio tracking</li> </ol>"},{"location":"getting-started/#your-first-query","title":"Your First Query","text":""},{"location":"getting-started/#create-a-client","title":"Create a Client","text":"<pre><code>from dexscreen import DexscreenerClient\n\n# Basic client (recommended for most use cases)\nclient = DexscreenerClient()\n\n# With browser impersonation (use when encountering anti-bot protection)\nclient = DexscreenerClient(impersonate=\"chrome136\")\n\n# Debug mode (enable verbose logging during development)\nclient = DexscreenerClient(debug=True)\n</code></pre>"},{"location":"getting-started/#fetch-pair-data","title":"Fetch Pair Data","text":"<pre><code># 1. Search for pairs (by token name or symbol)\npairs = client.search_pairs(\"PEPE\")\nif pairs:\n    print(f\"Found {len(pairs)} PEPE pairs\")\n    for pair in pairs[:5]:  # Show top 5 results\n        print(f\"  {pair.base_token.symbol}/{pair.quote_token.symbol} on {pair.chain_id}\")\n        print(f\"    Price: ${pair.price_usd:.8f}, DEX: {pair.dex_id}\")\n        print(f\"    24h Volume: ${pair.volume.h24:,.0f}\")\n        print()\n\n# 2. Get all pairs for a specific token\nusdc_address = \"0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\"  # Ethereum USDC\npairs = client.get_pairs_by_token_address(\"ethereum\", usdc_address)\nprint(f\"Found {len(pairs)} USDC pairs on Ethereum\")\n\n# Find the highest liquidity USDC pair\nif pairs:\n    best_usdc_pair = max(pairs, key=lambda p: p.liquidity.usd if p.liquidity else 0)\n    print(f\"Best USDC pair: {best_usdc_pair.base_token.symbol}/{best_usdc_pair.quote_token.symbol}\")\n    print(f\"Liquidity: ${best_usdc_pair.liquidity.usd:,.0f}\")\n\n# 3. Get details for a specific pair\npair = client.get_pair_by_pair_address(\n    \"ethereum\",\n    \"0x88e6a0c2ddd26feeb64f039a2c41296fcb3f5640\"  # Uniswap V3 USDC/WETH\n)\nif pair:\n    print(f\"Pair Details:\")\n    print(f\"  Price: ${pair.price_usd:.6f}\")\n    print(f\"  24h Volume: ${pair.volume.h24:,.0f}\")\n    print(f\"  24h Price Change: {pair.price_change.h24:+.2f}%\")\n    print(f\"  DEX: {pair.dex_id}\")\n</code></pre>"},{"location":"getting-started/#real-time-updates","title":"Real-time Updates","text":""},{"location":"getting-started/#basic-subscription","title":"Basic Subscription","text":"<pre><code>import asyncio\nfrom datetime import datetime\n\nasync def price_update_handler(pair):\n    \"\"\"Handle price updates - showing timestamp and key info\"\"\"\n    timestamp = datetime.now().strftime(\"%H:%M:%S\")\n    print(f\"[{timestamp}] {pair.base_token.symbol}: ${pair.price_usd:,.4f} \"\n          f\"(24h: {pair.price_change.h24:+.2f}%)\")\n\nasync def main():\n    client = DexscreenerClient()\n\n    print(\"Starting to monitor JUP token price...\")\n\n    # Subscribe to JUP pair on Solana\n    await client.subscribe_pairs(\n        chain_id=\"solana\",\n        pair_addresses=[\"JUPyiwrYJFskUPiHa7hkeR8VUtAeFoSYbKedZNsDvCN\"],\n        callback=price_update_handler,\n        interval=1.0  # Check for updates every second\n    )\n\n    # Monitor for 30 seconds\n    print(\"Monitoring... (30 seconds)\")\n    await asyncio.sleep(30)\n\n    # Clean up\n    print(\"Closing connections...\")\n    await client.close_streams()\n    print(\"Monitoring ended\")\n\n# Run the async function\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"getting-started/#monitor-multiple-pairs","title":"Monitor Multiple Pairs","text":"<pre><code>async def portfolio_monitor():\n    client = DexscreenerClient()\n\n    # Define your portfolio (chain_id, pair_address, description)\n    portfolio = [\n        (\"ethereum\", \"0x88e6a0c2ddd26feeb64f039a2c41296fcb3f5640\", \"USDC/WETH Uniswap V3\"),\n        (\"solana\", \"JUPyiwrYJFskUPiHa7hkeR8VUtAeFoSYbKedZNsDvCN\", \"JUP/SOL Raydium\"),\n        (\"bsc\", \"0x2170ed0880ac9a755fd29b2688956bd959f933f8\", \"ETH/BNB PancakeSwap\"),\n    ]\n\n    # Portfolio update handler\n    async def handle_portfolio_update(pair):\n        timestamp = datetime.now().strftime(\"%H:%M:%S\")\n        # Determine which token is the main token (non-stablecoin)\n        main_token = pair.base_token if pair.base_token.symbol not in [\"USDC\", \"USDT\", \"BUSD\"] else pair.quote_token\n\n        print(f\"[{timestamp}] [{pair.chain_id.upper()}] {main_token.symbol}: \"\n              f\"${pair.price_usd:,.4f} ({pair.price_change.h24:+.2f}%) \"\n              f\"Vol: ${pair.volume.h24:,.0f}\")\n\n    print(\"Starting portfolio monitoring...\")\n\n    # Subscribe to all pairs\n    for chain_id, pair_address, description in portfolio:\n        print(f\"Subscribing to {description} on {chain_id}\")\n        await client.subscribe_pairs(\n            chain_id=chain_id,\n            pair_addresses=[pair_address],\n            callback=handle_portfolio_update,\n            interval=2.0  # Check every 2 seconds\n        )\n\n    print(f\"\\nMonitoring {len(portfolio)} pairs, press Ctrl+C to stop...\")\n\n    try:\n        # Monitor for 1 minute (would be longer in production)\n        await asyncio.sleep(60)\n    except KeyboardInterrupt:\n        print(\"\\nInterrupt received, stopping...\")\n    finally:\n        await client.close_streams()\n        print(\"Portfolio monitoring stopped\")\n\nif __name__ == \"__main__\":\n    asyncio.run(portfolio_monitor())\n</code></pre>"},{"location":"getting-started/#filtering-updates","title":"Filtering Updates","text":"<p>Control when your callback is triggered using filters to reduce unnecessary notifications:</p> <pre><code>from dexscreen import FilterPresets\n\n# 1. Only trigger on significant price changes (1% threshold)\nawait client.subscribe_pairs(\n    chain_id=\"ethereum\",\n    pair_addresses=[\"0x88e6a0c2ddd26feeb64f039a2c41296fcb3f5640\"],\n    callback=handle_update,\n    filter=FilterPresets.significant_price_changes(0.01),  # 1% price change\n    interval=0.5  # Check every 0.5 seconds\n)\n\n# 2. Limit update frequency to avoid overload\nawait client.subscribe_pairs(\n    chain_id=\"ethereum\",\n    pair_addresses=[\"0x88e6a0c2ddd26feeb64f039a2c41296fcb3f5640\"],\n    callback=handle_update,\n    filter=FilterPresets.rate_limited(1.0),  # Max 1 update per second\n    interval=0.2  # Poll quickly but limit callback frequency\n)\n\n# 3. UI-friendly filtering (balanced update frequency and usefulness)\nawait client.subscribe_pairs(\n    chain_id=\"ethereum\",\n    pair_addresses=[\"0x88e6a0c2ddd26feeb64f039a2c41296fcb3f5640\"],\n    callback=handle_update,\n    filter=FilterPresets.ui_friendly(),  # Pre-configured for UI optimization\n    interval=1.0\n)\n</code></pre>"},{"location":"getting-started/#error-handling","title":"Error Handling","text":"<p>Always handle errors in your callbacks to prevent subscription interruptions in production:</p> <pre><code>import logging\n\n# Set up logging\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\nasync def safe_callback(pair):\n    try:\n        # Your business logic\n        if pair.price_usd and pair.price_usd &gt; 100:\n            print(f\"High value token: {pair.base_token.symbol} = ${pair.price_usd:,.2f}\")\n\n        # Check for anomalous price changes\n        if abs(pair.price_change.h24) &gt; 50:  # 50% change in 24h\n            logger.warning(f\"Anomalous price change: {pair.base_token.symbol} {pair.price_change.h24:+.2f}%\")\n\n    except AttributeError as e:\n        logger.error(f\"Missing data field: {e}\")\n    except TypeError as e:\n        logger.error(f\"Data type error: {e}\")\n    except Exception as e:\n        logger.error(f\"Unknown error processing update: {e}\")\n        # Important: Don't re-raise to avoid breaking the subscription\n\n# Use the safe callback\nasync def robust_monitoring():\n    client = DexscreenerClient()\n\n    try:\n        await client.subscribe_pairs(\n            chain_id=\"ethereum\",\n            pair_addresses=[\"0x88e6a0c2ddd26feeb64f039a2c41296fcb3f5640\"],\n            callback=safe_callback,\n            interval=1.0\n        )\n\n        await asyncio.sleep(30)\n\n    except Exception as e:\n        logger.error(f\"Failed to set up subscription: {e}\")\n    finally:\n        await client.close_streams()\n        logger.info(\"Monitoring session ended\")\n</code></pre>"},{"location":"getting-started/#async-vs-sync","title":"Async vs Sync","text":"<p>Dexscreen supports both patterns:</p>"},{"location":"getting-started/#synchronous-mode","title":"Synchronous Mode","text":"<pre><code># Simple and straightforward, ideal for scripts and one-time queries\nclient = DexscreenerClient()\n\n# Synchronous search\npairs = client.search_pairs(\"PEPE\")\nprint(f\"Found {len(pairs)} PEPE pairs\")\n\n# Synchronous get specific pair\npair = client.get_pair_by_pair_address(\"ethereum\", \"0x88e6...\")\nif pair:\n    print(f\"Current price: ${pair.price_usd}\")\n</code></pre>"},{"location":"getting-started/#asynchronous-mode","title":"Asynchronous Mode","text":"<pre><code># Better for concurrent operations, real-time monitoring, and high-performance applications\nasync def fetch_multiple_tokens():\n    client = DexscreenerClient()\n\n    # Define tokens to search\n    tokens = [\"PEPE\", \"SHIB\", \"DOGE\", \"FLOKI\"]\n\n    print(\"Searching multiple tokens concurrently...\")\n\n    # Run multiple queries concurrently (faster)\n    tasks = [client.search_pairs_async(token) for token in tokens]\n    results = await asyncio.gather(*tasks)\n\n    # Process results\n    for token, token_pairs in zip(tokens, results):\n        if token_pairs:\n            best_pair = max(token_pairs, key=lambda p: p.volume.h24 or 0)\n            print(f\"{token}: Found {len(token_pairs)} pairs, \"\n                  f\"highest volume: ${best_pair.volume.h24:,.0f}\")\n        else:\n            print(f\"{token}: No pairs found\")\n\n# Run the async function\nif __name__ == \"__main__\":\n    asyncio.run(fetch_multiple_tokens())\n</code></pre>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":""},{"location":"getting-started/#deep-dive","title":"\ud83d\udcda Deep Dive","text":"<ol> <li>Query API - Learn all available data fetching methods</li> <li>Streaming API - Master real-time data monitoring techniques</li> <li>Data Models - Understand the data structures returned by the API</li> <li>Filtering - Learn advanced filtering techniques for performance optimization</li> <li>Examples - View complete production-ready code examples</li> </ol>"},{"location":"getting-started/#project-ideas","title":"\ud83d\ude80 Project Ideas","text":"<ul> <li>Price Alert Bot: Monitor token price changes and send notifications</li> <li>Arbitrage Scanner: Find arbitrage opportunities across different DEXs and chains</li> <li>Portfolio Dashboard: Track your DeFi portfolio in real-time</li> <li>New Token Discovery Tool: Automatically discover and analyze newly listed tokens</li> <li>Liquidity Monitoring System: Track large liquidity changes</li> </ul>"},{"location":"getting-started/#faq-troubleshooting","title":"FAQ &amp; Troubleshooting","text":""},{"location":"getting-started/#rate-limiting","title":"\ud83d\udea6 Rate Limiting","text":"<p>Problem: Encountering rate limit errors Solution:</p> <ul> <li>The SDK handles rate limits automatically with backoff retry</li> <li>If frequently hitting limits, consider increasing polling intervals</li> <li>Use batch methods (e.g., <code>get_pairs_by_pairs_addresses</code>) instead of multiple individual calls</li> </ul>"},{"location":"getting-started/#no-data-returned","title":"\ud83d\udcca No Data Returned","text":"<p>Common causes:</p> <ul> <li>\u274c Wrong chain_id: Use <code>\"ethereum\"</code> not <code>\"eth\"</code></li> <li>\u274c Invalid contract addresses: Ensure addresses are correctly formatted and checksummed</li> <li>\u274c Token doesn't exist: Some tokens may not have pairs on certain chains</li> <li>\u274c New tokens: Recently launched tokens may not be indexed yet</li> </ul> <p>Solutions:</p> <pre><code># Verify address format\nfrom web3 import Web3\naddress = \"0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\"\nif Web3.isAddress(address):\n    pairs = client.get_pairs_by_token_address(\"ethereum\", address)\nelse:\n    print(\"Invalid Ethereum address\")\n</code></pre>"},{"location":"getting-started/#subscription-not-updating","title":"\ud83d\udd04 Subscription Not Updating","text":"<p>Diagnostic steps:</p> <ol> <li>Check filter configuration: Ensure filters aren't filtering out all updates</li> </ol> <pre><code># Temporarily disable filter for testing\nawait client.subscribe_pairs(..., filter=False)\n</code></pre> <ol> <li>Verify pair activity: Ensure the pair has actual trading activity</li> </ol> <pre><code>pair = client.get_pair_by_pair_address(chain_id, pair_address)\nif pair and pair.volume.h24 &gt; 0:\n    print(\"Pair is active\")\nelse:\n    print(\"Pair may be inactive\")\n</code></pre> <ol> <li>Check callback errors: Ensure callback function isn't throwing exceptions    <pre><code>async def debug_callback(pair):\n    try:\n        print(f\"Update received: {pair.base_token.symbol}\")\n        # Your logic...\n    except Exception as e:\n        print(f\"Callback error: {e}\")\n</code></pre></li> </ol>"},{"location":"getting-started/#connection-issues","title":"\ud83d\udd27 Connection Issues","text":"<p>Problem: Can't connect to Dexscreener API</p> <p>Solutions:</p> <pre><code># Enable browser impersonation to bypass anti-bot protection\nclient = DexscreenerClient(impersonate=\"chrome136\")\n\n# Or enable debug mode to see detailed errors\nclient = DexscreenerClient(debug=True)\n</code></pre>"},{"location":"getting-started/#memory-usage","title":"\ud83d\udcbe Memory Usage","text":"<p>Problem: High memory usage after long-running sessions</p> <p>Solutions:</p> <ul> <li>Periodically clean up unneeded subscriptions</li> <li>Use appropriate filters to reduce data processing</li> <li>Implement data rotation strategies</li> </ul> <pre><code># Example periodic cleanup\nimport asyncio\nfrom datetime import datetime, timedelta\n\nclass ManagedClient:\n    def __init__(self):\n        self.client = DexscreenerClient()\n        self.last_cleanup = datetime.now()\n\n    async def periodic_cleanup(self):\n        while True:\n            await asyncio.sleep(3600)  # Check every hour\n            if datetime.now() - self.last_cleanup &gt; timedelta(hours=6):\n                print(\"Performing periodic cleanup...\")\n                await self.client.close_streams()\n                self.client = DexscreenerClient()  # Create fresh instance\n                self.last_cleanup = datetime.now()\n</code></pre>"},{"location":"getting-started/#getting-help","title":"\ud83c\udd98 Getting Help","text":"Resource Type Link Use Case \ud83d\udcd6 Complete Examples Examples Page Need working code references \ud83d\udccb API Reference Query API Learn specific method usage \ud83d\udc1b Bug Reports GitHub Issues Found a bug or issue \ud83d\udca1 Feature Requests GitHub Discussions Suggest new features \ud83d\udcac Community Discussion GitHub Discussions General questions and discussion"},{"location":"getting-started/#best-practices-when-seeking-help","title":"\ud83d\udd0d Best Practices When Seeking Help","text":"<ol> <li>Provide complete error messages and relevant code snippets</li> <li>Explain your use case and expected behavior</li> <li>Include system information (Python version, OS, etc.)</li> <li>Check existing issues first to see if there's already a solution</li> </ol> <p>\ud83d\udca1 Tip: Most issues can be resolved by checking the complete code in Examples!</p> <p>\ud83c\udf89 Congratulations! You now have the fundamentals of Dexscreen. Continue exploring Examples to learn more advanced usage, or start building your first DeFi monitoring application!</p>"},{"location":"api/data-models/","title":"Data Models Reference","text":"<p>All data models in Dexscreen are Pydantic models, providing automatic validation and type safety.</p> <p>\ud83d\udd0d Quick Find: Use Ctrl+F to search for specific models or fields. All models are fully documented with examples.</p>"},{"location":"api/data-models/#core-models","title":"Core Models","text":""},{"location":"api/data-models/#tokenpair","title":"TokenPair","text":"<p>The primary data model representing a trading pair. This is what you'll work with most often.</p> <p>Returned by: Most query and streaming methods, contains all essential trading data.</p> <pre><code>class TokenPair(BaseModel):\n    chain_id: str                      # Blockchain identifier\n    dex_id: str                        # DEX identifier\n    url: str                           # DEXScreener URL\n    pair_address: str                  # Pair contract address\n    base_token: BaseToken              # Base token info\n    quote_token: BaseToken             # Quote token info\n    price_native: float                # Price in native token\n    price_usd: Optional[float]         # Price in USD\n    transactions: PairTransactionCounts # Transaction statistics\n    volume: VolumeChangePeriods        # Volume data\n    price_change: PriceChangePeriods   # Price changes\n    liquidity: Optional[Liquidity]     # Liquidity info\n    fdv: Optional[float]               # Fully diluted valuation\n    pair_created_at: Optional[datetime] # Creation timestamp\n</code></pre> <p>Complete Usage Example:</p> <pre><code>pair = client.get_pair_by_pair_address(\"ethereum\", \"0x88e6a0c2ddd26feeb64f039a2c41296fcb3f5640\")\nif pair:\n    # Basic information\n    print(f\"Pair: {pair.base_token.symbol}/{pair.quote_token.symbol}\")\n    print(f\"DEX: {pair.dex_id}\")\n    print(f\"Chain: {pair.chain_id.upper()}\")\n\n    # Price and market data\n    print(f\"Price: ${pair.price_usd:,.6f}\")\n    print(f\"24h Volume: ${pair.volume.h24:,.0f}\")\n    print(f\"24h Change: {pair.price_change.h24:+.2f}%\")\n\n    # Liquidity information\n    if pair.liquidity:\n        print(f\"Total Liquidity: ${pair.liquidity.usd:,.0f}\")\n        print(f\"Base Liquidity: {pair.liquidity.base:,.2f} {pair.base_token.symbol}\")\n        print(f\"Quote Liquidity: {pair.liquidity.quote:,.2f} {pair.quote_token.symbol}\")\n\n    # Trading activity\n    print(f\"24h Transactions: {pair.transactions.h24.buys + pair.transactions.h24.sells}\")\n    print(f\"Buy/Sell Ratio: {pair.transactions.h24.buys}/{pair.transactions.h24.sells}\")\n</code></pre>"},{"location":"api/data-models/#basetoken","title":"BaseToken","text":"<p>Represents token information within a trading pair.</p> <pre><code>class BaseToken(BaseModel):\n    address: str    # Contract address (checksummed)\n    name: str       # Full token name\n    symbol: str     # Token symbol/ticker\n</code></pre> <p>Practical Usage Examples:</p> <pre><code># Example 1: Identify tokens in a pair\nif pair.base_token.symbol == \"USDC\":\n    trading_token = pair.quote_token\n    print(f\"USDC/{trading_token.symbol} pair\")\nelse:\n    trading_token = pair.base_token\n    print(f\"{trading_token.symbol}/USDC pair\")\n\n# Example 2: Check if it's a stablecoin pair\nstablecoins = {\"USDC\", \"USDT\", \"DAI\", \"BUSD\", \"FRAX\"}\nbase_is_stable = pair.base_token.symbol in stablecoins\nquote_is_stable = pair.quote_token.symbol in stablecoins\n\nif base_is_stable and quote_is_stable:\n    print(\"Stablecoin pair - low volatility expected\")\nelif base_is_stable or quote_is_stable:\n    print(\"Token-stablecoin pair - good for price tracking\")\nelse:\n    print(\"Token-token pair - higher volatility expected\")\n\n# Example 3: Get token addresses for external APIs\nprint(f\"Base token address: {pair.base_token.address}\")\nprint(f\"Quote token address: {pair.quote_token.address}\")\n</code></pre>"},{"location":"api/data-models/#transaction-statistics","title":"Transaction Statistics","text":""},{"location":"api/data-models/#transactioncount","title":"TransactionCount","text":"<p>Buy and sell transaction counts.</p> <pre><code>class TransactionCount(BaseModel):\n    buys: int      # Number of buy transactions\n    sells: int     # Number of sell transactions\n</code></pre>"},{"location":"api/data-models/#pairtransactioncounts","title":"PairTransactionCounts","text":"<p>Transaction statistics across different time periods.</p> <pre><code>class PairTransactionCounts(BaseModel):\n    m5: TransactionCount    # 5 minutes\n    h1: TransactionCount    # 1 hour\n    h6: TransactionCount    # 6 hours\n    h24: TransactionCount   # 24 hours\n</code></pre> <p>Advanced Usage Examples:</p> <pre><code># Example 1: Calculate buy/sell pressure\ndef calculate_buy_pressure(transactions: TransactionCount) -&gt; float:\n    total = transactions.buys + transactions.sells\n    return transactions.buys / total if total &gt; 0 else 0.5\n\n# Analyze different time periods\nprint(\"Buy Pressure Analysis:\")\nprint(f\"  5min: {calculate_buy_pressure(pair.transactions.m5):.1%}\")\nprint(f\"  1hour: {calculate_buy_pressure(pair.transactions.h1):.1%}\")\nprint(f\"  24hour: {calculate_buy_pressure(pair.transactions.h24):.1%}\")\n\n# Example 2: Detect unusual activity\nrecent_activity = pair.transactions.m5.buys + pair.transactions.m5.sells\nhourly_avg = (pair.transactions.h1.buys + pair.transactions.h1.sells) / 12  # Per 5min\n\nif hourly_avg &gt; 0 and recent_activity &gt; hourly_avg * 3:\n    print(\"\ud83d\udea8 High activity alert: 3x normal transaction volume\")\n\n# Example 3: Trading pattern analysis\ndef analyze_trading_pattern(transactions: PairTransactionCounts):\n    patterns = []\n\n    # Check if buying is dominant\n    if calculate_buy_pressure(transactions.h24) &gt; 0.6:\n        patterns.append(\"Strong buying pressure\")\n    elif calculate_buy_pressure(transactions.h24) &lt; 0.4:\n        patterns.append(\"Strong selling pressure\")\n\n    # Check activity level\n    total_24h = transactions.h24.buys + transactions.h24.sells\n    if total_24h &gt; 1000:\n        patterns.append(\"High activity\")\n    elif total_24h &lt; 50:\n        patterns.append(\"Low activity\")\n\n    return patterns\n\npatterns = analyze_trading_pattern(pair.transactions)\nprint(f\"Trading patterns: {', '.join(patterns)}\")\n</code></pre>"},{"location":"api/data-models/#market-data","title":"Market Data","text":""},{"location":"api/data-models/#volumechangeperiods","title":"VolumeChangePeriods","text":"<p>Trading volume in USD across time periods.</p> <pre><code>class VolumeChangePeriods(BaseModel):\n    m5: Optional[float] = 0.0    # 5 minute volume\n    h1: Optional[float] = 0.0    # 1 hour volume\n    h6: Optional[float] = 0.0    # 6 hour volume\n    h24: Optional[float] = 0.0   # 24 hour volume\n</code></pre>"},{"location":"api/data-models/#pricechangeperiods","title":"PriceChangePeriods","text":"<p>Price change percentages across time periods.</p> <pre><code>class PriceChangePeriods(BaseModel):\n    m5: Optional[float] = 0.0    # 5 minute change %\n    h1: Optional[float] = 0.0    # 1 hour change %\n    h6: Optional[float] = 0.0    # 6 hour change %\n    h24: Optional[float] = 0.0   # 24 hour change %\n</code></pre> <p>Advanced Market Analysis Examples:</p> <pre><code># Example 1: Trend detection with volume confirmation\ndef detect_trends(pair: TokenPair) -&gt; str:\n    price_change = pair.price_change.h1 or 0\n    volume_24h = pair.volume.h24 or 0\n\n    # Strong uptrend: &gt;5% price increase with good volume\n    if price_change &gt; 5 and volume_24h &gt; 100_000:\n        return f\"\ud83d\udcc8 Strong uptrend: {pair.base_token.symbol}\"\n\n    # Strong downtrend: &gt;5% price decrease with good volume\n    elif price_change &lt; -5 and volume_24h &gt; 100_000:\n        return f\"\ud83d\udcc9 Strong downtrend: {pair.base_token.symbol}\"\n\n    # Consolidation: low price change despite good volume\n    elif abs(price_change) &lt; 2 and volume_24h &gt; 50_000:\n        return f\"\ud83d\udd04 Consolidating: {pair.base_token.symbol}\"\n\n    return \"No clear trend\"\n\nprint(detect_trends(pair))\n\n# Example 2: Volume acceleration analysis\ndef analyze_volume_acceleration(pair: TokenPair) -&gt; dict:\n    h1_vol = pair.volume.h1 or 0\n    h6_vol = pair.volume.h6 or 0\n    h24_vol = pair.volume.h24 or 0\n\n    # Calculate hourly averages\n    h6_hourly_avg = h6_vol / 6\n    h24_hourly_avg = h24_vol / 24\n\n    analysis = {\n        \"current_vs_6h_avg\": h1_vol / h6_hourly_avg if h6_hourly_avg &gt; 0 else 0,\n        \"current_vs_24h_avg\": h1_vol / h24_hourly_avg if h24_hourly_avg &gt; 0 else 0,\n        \"volume_trend\": \"increasing\" if h1_vol &gt; h6_hourly_avg * 1.5 else \"normal\"\n    }\n\n    return analysis\n\nvol_analysis = analyze_volume_acceleration(pair)\nif vol_analysis[\"current_vs_6h_avg\"] &gt; 3:\n    print(f\"\ud83d\udd25 Volume surge: {vol_analysis['current_vs_6h_avg']:.1f}x normal\")\n\n# Example 3: Multi-timeframe price momentum\ndef calculate_momentum_score(pair: TokenPair) -&gt; float:\n    \"\"\"Calculate momentum score (0-100)\"\"\"\n    changes = [\n        pair.price_change.m5 or 0,\n        pair.price_change.h1 or 0,\n        pair.price_change.h6 or 0,\n        pair.price_change.h24 or 0\n    ]\n\n    # Weight recent changes more heavily\n    weights = [4, 3, 2, 1]\n    weighted_score = sum(change * weight for change, weight in zip(changes, weights))\n    total_weight = sum(weights)\n\n    # Normalize to 0-100 scale (assuming max reasonable change is 50%)\n    score = max(0, min(100, 50 + weighted_score / total_weight))\n    return score\n\nmomentum = calculate_momentum_score(pair)\nprint(f\"Momentum Score: {momentum:.1f}/100\")\n</code></pre>"},{"location":"api/data-models/#liquidity","title":"Liquidity","text":"<p>Liquidity information for the pair.</p> <pre><code>class Liquidity(BaseModel):\n    usd: Optional[float]    # Total liquidity in USD\n    base: float             # Base token liquidity\n    quote: float            # Quote token liquidity\n</code></pre> <p>Advanced Liquidity Analysis Examples:</p> <pre><code># Example 1: Liquidity quality assessment\ndef assess_liquidity_quality(pair: TokenPair) -&gt; dict:\n    if not pair.liquidity or not pair.liquidity.usd:\n        return {\"quality\": \"unknown\", \"risk\": \"high\"}\n\n    liquidity_usd = pair.liquidity.usd\n    volume_24h = pair.volume.h24 or 0\n\n    # Calculate volume-to-liquidity ratio\n    vol_liq_ratio = volume_24h / liquidity_usd if liquidity_usd &gt; 0 else 0\n\n    assessment = {\n        \"liquidity_usd\": liquidity_usd,\n        \"volume_liquidity_ratio\": vol_liq_ratio,\n        \"daily_turnover\": vol_liq_ratio,  # How many times liquidity turns over daily\n    }\n\n    # Quality assessment\n    if liquidity_usd &gt; 1_000_000:\n        assessment[\"quality\"] = \"excellent\"\n        assessment[\"risk\"] = \"very_low\"\n    elif liquidity_usd &gt; 100_000:\n        assessment[\"quality\"] = \"good\"\n        assessment[\"risk\"] = \"low\"\n    elif liquidity_usd &gt; 10_000:\n        assessment[\"quality\"] = \"fair\"\n        assessment[\"risk\"] = \"medium\"\n    else:\n        assessment[\"quality\"] = \"poor\"\n        assessment[\"risk\"] = \"high\"\n\n    # High turnover might indicate price manipulation\n    if vol_liq_ratio &gt; 10:\n        assessment[\"warning\"] = \"High turnover - possible manipulation\"\n\n    return assessment\n\nliq_analysis = assess_liquidity_quality(pair)\nprint(f\"Liquidity Quality: {liq_analysis['quality']}\")\nprint(f\"Risk Level: {liq_analysis['risk']}\")\nprint(f\"Daily Turnover: {liq_analysis['daily_turnover']:.1f}x\")\n\n# Example 2: Price impact estimation\ndef estimate_price_impact(pair: TokenPair, trade_size_usd: float) -&gt; float:\n    \"\"\"Rough estimate of price impact for a given trade size\"\"\"\n    if not pair.liquidity or not pair.liquidity.usd:\n        return float('inf')  # Unknown impact\n\n    # Simple price impact model: impact = trade_size / liquidity\n    # Real AMMs use more complex formulas, but this gives a rough estimate\n    impact_percentage = (trade_size_usd / pair.liquidity.usd) * 100\n\n    return min(impact_percentage, 100)  # Cap at 100%\n\n# Test different trade sizes\ntrade_sizes = [1000, 5000, 10000, 50000]\nprint(\"\\nEstimated Price Impact:\")\nfor size in trade_sizes:\n    impact = estimate_price_impact(pair, size)\n    print(f\"  ${size:,}: {impact:.2f}%\")\n\n# Example 3: Liquidity distribution analysis\ndef analyze_liquidity_distribution(pair: TokenPair):\n    if not pair.liquidity:\n        return \"No liquidity data\"\n\n    base_value = pair.liquidity.base * (pair.price_usd or 0)\n    quote_value = pair.liquidity.quote  # Assuming quote is USD or stablecoin\n    total_value = base_value + quote_value\n\n    if total_value &gt; 0:\n        base_percentage = (base_value / total_value) * 100\n        quote_percentage = (quote_value / total_value) * 100\n\n        return {\n            \"base_percentage\": base_percentage,\n            \"quote_percentage\": quote_percentage,\n            \"balance\": \"balanced\" if 40 &lt;= base_percentage &lt;= 60 else \"imbalanced\"\n        }\n\n    return \"Cannot analyze distribution\"\n\ndistribution = analyze_liquidity_distribution(pair)\nif isinstance(distribution, dict):\n    print(f\"\\nLiquidity Distribution:\")\n    print(f\"  {pair.base_token.symbol}: {distribution['base_percentage']:.1f}%\")\n    print(f\"  {pair.quote_token.symbol}: {distribution['quote_percentage']:.1f}%\")\n    print(f\"  Status: {distribution['balance']}\")\n</code></pre>"},{"location":"api/data-models/#token-information","title":"Token Information","text":""},{"location":"api/data-models/#tokeninfo","title":"TokenInfo","text":"<p>Detailed token profile information.</p> <pre><code>class TokenInfo(BaseModel):\n    url: str                        # DEXScreener URL\n    chain_id: str                   # Blockchain identifier\n    token_address: str              # Token contract address\n    amount: float = 0.0             # Boost amount\n    total_amount: float = 0.0       # Total boost amount\n    icon: Optional[str]             # Icon URL\n    header: Optional[str]           # Header image URL\n    description: Optional[str]      # Token description\n    links: List[TokenLink] = []     # Related links\n</code></pre>"},{"location":"api/data-models/#tokenlink","title":"TokenLink","text":"<p>Links associated with a token.</p> <pre><code>class TokenLink(BaseModel):\n    type: Optional[str]     # Link type (website, twitter, etc.)\n    label: Optional[str]    # Display label\n    url: Optional[str]      # Link URL\n</code></pre> <p>Complete Token Analysis Example:</p> <pre><code># Get and analyze token profiles\nprofiles = client.get_latest_token_profiles()\n\nfor token in profiles:\n    print(f\"\\n{'='*50}\")\n    print(f\"Token: {token.token_address}\")\n    print(f\"Chain: {token.chain_id.upper()}\")\n    print(f\"URL: {token.url}\")\n\n    # Boost information\n    if token.amount &gt; 0:\n        print(f\"Boost Amount: {token.amount}\")\n        print(f\"Total Boost: {token.total_amount}\")\n\n    # Description analysis\n    if token.description:\n        desc = token.description[:200] + \"...\" if len(token.description) &gt; 200 else token.description\n        print(f\"Description: {desc}\")\n\n        # Simple keyword analysis\n        keywords = [\"meme\", \"utility\", \"defi\", \"gaming\", \"nft\", \"dao\"]\n        found_keywords = [kw for kw in keywords if kw.lower() in token.description.lower()]\n        if found_keywords:\n            print(f\"Categories: {', '.join(found_keywords)}\")\n\n    # Social links analysis\n    social_links = {}\n    for link in token.links:\n        if link.type and link.url:\n            social_links[link.type] = link.url\n\n    if social_links:\n        print(\"Social Links:\")\n        for platform, url in social_links.items():\n            print(f\"  {platform.title()}: {url}\")\n\n    # Media presence\n    if token.icon:\n        print(f\"Has Icon: Yes\")\n    if token.header:\n        print(f\"Has Header Image: Yes\")\n\n    # Get trading data for this token\n    try:\n        pairs = client.get_pairs_by_token_address(token.chain_id, token.token_address)\n        if pairs:\n            total_volume = sum(p.volume.h24 for p in pairs if p.volume.h24)\n            total_liquidity = sum(p.liquidity.usd for p in pairs if p.liquidity and p.liquidity.usd)\n            print(f\"Trading Pairs: {len(pairs)}\")\n            print(f\"Total 24h Volume: ${total_volume:,.0f}\")\n            print(f\"Total Liquidity: ${total_liquidity:,.0f}\")\n    except Exception as e:\n        print(f\"Could not fetch trading data: {e}\")\n</code></pre>"},{"location":"api/data-models/#orderinfo","title":"OrderInfo","text":"<p>Order/payment information for tokens.</p> <pre><code>class OrderInfo(BaseModel):\n    type: str               # Order type\n    status: str             # Order status\n    payment_timestamp: int  # Payment timestamp (milliseconds)\n</code></pre> <p>Advanced Order Analysis Example:</p> <pre><code>from datetime import datetime, timedelta\n\norders = client.get_orders_paid_of_token(\"ethereum\", token_address)\n\nif orders:\n    print(f\"Found {len(orders)} paid orders for token\")\n    print(\"\\nOrder Analysis:\")\n\n    # Group orders by type and status\n    order_stats = {}\n    recent_orders = []\n\n    for order in orders:\n        # Convert timestamp\n        timestamp = datetime.fromtimestamp(order.payment_timestamp / 1000)\n\n        # Track statistics\n        key = f\"{order.type}_{order.status}\"\n        order_stats[key] = order_stats.get(key, 0) + 1\n\n        # Check if order is recent (last 7 days)\n        if timestamp &gt; datetime.now() - timedelta(days=7):\n            recent_orders.append((order, timestamp))\n\n        print(f\"  {order.type.title()} order: {order.status} at {timestamp.strftime('%Y-%m-%d %H:%M')}\")\n\n    # Summary statistics\n    print(\"\\nOrder Statistics:\")\n    for order_type, count in order_stats.items():\n        print(f\"  {order_type.replace('_', ' ').title()}: {count}\")\n\n    # Recent activity\n    if recent_orders:\n        print(f\"\\nRecent Activity (last 7 days): {len(recent_orders)} orders\")\n        for order, timestamp in recent_orders[-3:]:  # Show last 3\n            print(f\"  {timestamp.strftime('%m/%d')}: {order.type} ({order.status})\")\n    else:\n        print(\"\\nNo recent order activity\")\nelse:\n    print(\"No paid orders found for this token\")\n</code></pre>"},{"location":"api/data-models/#working-with-optional-fields","title":"Working with Optional Fields","text":"<p>Many fields are optional and may be None. Always use defensive programming:</p> <pre><code># Pattern 1: Simple None checks\nif pair.price_usd:\n    print(f\"Price: ${pair.price_usd:,.6f}\")\nelse:\n    print(\"USD price not available\")\n\n# Pattern 2: Default values with or operator\nvolume_24h = pair.volume.h24 or 0\nliquidity_usd = pair.liquidity.usd if pair.liquidity else 0\nfdv = pair.fdv or 0\n\n# Pattern 3: Safe chaining with nested checks\nif pair.liquidity and pair.liquidity.usd and pair.liquidity.usd &gt; 100_000:\n    print(\"High liquidity pair\")\n\n# Pattern 4: Helper function for safe access\ndef safe_get(obj, *attrs, default=None):\n    \"\"\"Safely access nested attributes\"\"\"\n    try:\n        for attr in attrs:\n            obj = getattr(obj, attr)\n            if obj is None:\n                return default\n        return obj\n    except AttributeError:\n        return default\n\n# Usage examples\nliquidity_usd = safe_get(pair, 'liquidity', 'usd', default=0)\nvolume_h1 = safe_get(pair, 'volume', 'h1', default=0)\nbuys_5m = safe_get(pair, 'transactions', 'm5', 'buys', default=0)\n\nprint(f\"Safely accessed values:\")\nprint(f\"  Liquidity: ${liquidity_usd:,.0f}\")\nprint(f\"  1h Volume: ${volume_h1:,.0f}\")\nprint(f\"  5min Buys: {buys_5m}\")\n\n# Pattern 5: Comprehensive data validation\ndef validate_pair_data(pair: TokenPair) -&gt; dict:\n    \"\"\"Validate and score data completeness\"\"\"\n    validation = {\n        \"has_price\": bool(pair.price_usd),\n        \"has_volume\": bool(pair.volume.h24),\n        \"has_liquidity\": bool(pair.liquidity and pair.liquidity.usd),\n        \"has_price_changes\": bool(pair.price_change.h24 is not None),\n        \"has_transactions\": bool(pair.transactions.h24.buys + pair.transactions.h24.sells &gt; 0),\n        \"has_fdv\": bool(pair.fdv),\n        \"creation_date\": bool(pair.pair_created_at)\n    }\n\n    # Calculate completeness score\n    score = sum(validation.values()) / len(validation) * 100\n    validation[\"completeness_score\"] = score\n\n    # Quality assessment\n    if score &gt;= 80:\n        validation[\"quality\"] = \"excellent\"\n    elif score &gt;= 60:\n        validation[\"quality\"] = \"good\"\n    elif score &gt;= 40:\n        validation[\"quality\"] = \"fair\"\n    else:\n        validation[\"quality\"] = \"poor\"\n\n    return validation\n\n# Validate pair data\nvalidation = validate_pair_data(pair)\nprint(f\"\\nData Quality Assessment:\")\nprint(f\"  Completeness: {validation['completeness_score']:.1f}%\")\nprint(f\"  Quality: {validation['quality']}\")\nprint(f\"  Missing data: {[k for k, v in validation.items() if isinstance(v, bool) and not v]}\")\n</code></pre>"},{"location":"api/data-models/#type-hints-and-ide-support","title":"Type Hints and IDE Support","text":"<p>All models have full type hints for excellent IDE support:</p> <pre><code>from dexscreen import TokenPair, DexscreenerClient\n\ndef analyze_pair(pair: TokenPair) -&gt; dict:\n    \"\"\"Analyze a trading pair\"\"\"\n    return {\n        \"symbol\": pair.base_token.symbol,\n        \"price\": pair.price_usd,\n        \"volume_24h\": pair.volume.h24,\n        \"liquidity\": pair.liquidity.usd if pair.liquidity else 0,\n        \"buy_pressure\": calculate_buy_pressure(pair.transactions)\n    }\n\ndef calculate_buy_pressure(txns: PairTransactionCounts) -&gt; float:\n    \"\"\"Calculate buy pressure from transactions\"\"\"\n    total = txns.h24.buys + txns.h24.sells\n    return txns.h24.buys / total if total &gt; 0 else 0.5\n</code></pre>"},{"location":"api/data-models/#model-validation-error-handling","title":"Model Validation &amp; Error Handling","text":"<p>Pydantic provides automatic validation with detailed error messages:</p> <pre><code>from pydantic import ValidationError\nimport logging\n\n# Set up logging\nlogger = logging.getLogger(__name__)\n\n# Example 1: Basic validation error handling\ntry:\n    # This would fail validation\n    token = BaseToken(\n        address=\"invalid_address\",  # Should be a valid address format\n        name=\"\",                    # Should not be empty\n        symbol=\"\"                   # Should not be empty\n    )\nexcept ValidationError as e:\n    print(f\"Validation failed: {e}\")\n    # Log specific field errors\n    for error in e.errors():\n        print(f\"Field '{error['loc'][0]}': {error['msg']}\")\n\n# Example 2: Robust API response handling\ndef safely_parse_pair_data(raw_data: dict) -&gt; TokenPair | None:\n    \"\"\"Safely parse raw API data into TokenPair model\"\"\"\n    try:\n        return TokenPair.model_validate(raw_data)\n    except ValidationError as e:\n        logger.warning(f\"Failed to parse pair data: {e}\")\n\n        # Log specific issues for debugging\n        for error in e.errors():\n            field_path = ' -&gt; '.join(str(loc) for loc in error['loc'])\n            logger.debug(f\"Invalid field {field_path}: {error['msg']}\")\n\n        return None\n    except Exception as e:\n        logger.error(f\"Unexpected error parsing pair data: {e}\")\n        return None\n\n# Example 3: Data quality validation\ndef validate_trading_data_quality(pair: TokenPair) -&gt; list[str]:\n    \"\"\"Validate trading data quality and return warnings\"\"\"\n    warnings = []\n\n    # Check for suspicious data\n    if pair.price_usd and pair.price_usd &lt;= 0:\n        warnings.append(\"Invalid price: price is zero or negative\")\n\n    if pair.volume.h24 and pair.volume.h24 &lt; 0:\n        warnings.append(\"Invalid volume: negative 24h volume\")\n\n    if pair.liquidity and pair.liquidity.usd and pair.liquidity.usd &lt; 1000:\n        warnings.append(\"Low liquidity warning: less than $1,000\")\n\n    # Check for data consistency\n    total_tx = pair.transactions.h24.buys + pair.transactions.h24.sells\n    if total_tx == 0 and pair.volume.h24 and pair.volume.h24 &gt; 0:\n        warnings.append(\"Data inconsistency: volume without transactions\")\n\n    # Check for extreme values\n    if pair.price_change.h24 and abs(pair.price_change.h24) &gt; 1000:\n        warnings.append(f\"Extreme price change: {pair.price_change.h24:.1f}%\")\n\n    return warnings\n\n# Usage example\nwarnings = validate_trading_data_quality(pair)\nif warnings:\n    print(\"Data Quality Warnings:\")\n    for warning in warnings:\n        print(f\"  \u26a0\ufe0f {warning}\")\nelse:\n    print(\"\u2705 Data quality looks good\")\n\n# Example 4: Custom validation for trading strategies\ndef is_suitable_for_trading(pair: TokenPair, min_liquidity: float = 50000, min_volume: float = 10000) -&gt; dict:\n    \"\"\"Check if pair is suitable for trading based on criteria\"\"\"\n    result = {\n        \"suitable\": True,\n        \"reasons\": [],\n        \"score\": 0\n    }\n\n    # Check liquidity\n    if not pair.liquidity or not pair.liquidity.usd or pair.liquidity.usd &lt; min_liquidity:\n        result[\"suitable\"] = False\n        result[\"reasons\"].append(f\"Insufficient liquidity (need ${min_liquidity:,})\")\n    else:\n        result[\"score\"] += 25\n\n    # Check volume\n    volume_24h = pair.volume.h24 or 0\n    if volume_24h &lt; min_volume:\n        result[\"suitable\"] = False\n        result[\"reasons\"].append(f\"Low volume (need ${min_volume:,})\")\n    else:\n        result[\"score\"] += 25\n\n    # Check price availability\n    if not pair.price_usd:\n        result[\"suitable\"] = False\n        result[\"reasons\"].append(\"No USD price available\")\n    else:\n        result[\"score\"] += 25\n\n    # Check trading activity\n    total_tx = pair.transactions.h24.buys + pair.transactions.h24.sells\n    if total_tx &lt; 10:\n        result[\"suitable\"] = False\n        result[\"reasons\"].append(\"Insufficient trading activity\")\n    else:\n        result[\"score\"] += 25\n\n    return result\n\n# Test trading suitability\nsuitability = is_suitable_for_trading(pair)\nprint(f\"\\nTrading Suitability:\")\nprint(f\"  Suitable: {'\u2705 Yes' if suitability['suitable'] else '\u274c No'}\")\nprint(f\"  Score: {suitability['score']}/100\")\nif suitability[\"reasons\"]:\n    print(f\"  Issues: {', '.join(suitability['reasons'])}\")\n</code></pre>"},{"location":"api/data-models/#json-serialization-data-export","title":"JSON Serialization &amp; Data Export","text":"<p>All models support flexible serialization for storage and analysis:</p> <pre><code>import json\nfrom datetime import datetime\n\n# Basic serialization\npair_dict = pair.model_dump()\npair_json = pair.model_dump_json()\n\n# Clean serialization (exclude None values)\nclean_dict = pair.model_dump(exclude_none=True)\n\n# Custom serialization with datetime handling\ndef serialize_pair_for_analysis(pair: TokenPair) -&gt; dict:\n    \"\"\"Serialize pair data optimized for analysis\"\"\"\n    data = pair.model_dump(exclude_none=True)\n\n    # Add computed fields\n    data['computed'] = {\n        'total_transactions_24h': pair.transactions.h24.buys + pair.transactions.h24.sells,\n        'buy_sell_ratio': pair.transactions.h24.buys / max(pair.transactions.h24.sells, 1),\n        'volume_to_liquidity_ratio': (pair.volume.h24 or 0) / (pair.liquidity.usd if pair.liquidity else 1),\n        'last_updated': datetime.now().isoformat()\n    }\n\n    return data\n\n# Export to different formats\nanalysis_data = serialize_pair_for_analysis(pair)\n\n# Save to JSON file\nwith open(f\"pair_data_{pair.base_token.symbol}_{pair.quote_token.symbol}.json\", \"w\") as f:\n    json.dump(analysis_data, f, indent=2)\n\n# Save to CSV (flattened)\nimport pandas as pd\n\ndef flatten_dict(d, parent_key='', sep='_'):\n    \"\"\"Flatten nested dictionary for CSV export\"\"\"\n    items = []\n    for k, v in d.items():\n        new_key = f\"{parent_key}{sep}{k}\" if parent_key else k\n        if isinstance(v, dict):\n            items.extend(flatten_dict(v, new_key, sep=sep).items())\n        else:\n            items.append((new_key, v))\n    return dict(items)\n\nflat_data = flatten_dict(analysis_data)\ndf = pd.DataFrame([flat_data])\ndf.to_csv(f\"pair_data_{pair.base_token.symbol}_{pair.quote_token.symbol}.csv\", index=False)\n\nprint(f\"Data exported to JSON and CSV files\")\nprint(f\"JSON size: {len(json.dumps(analysis_data))} characters\")\nprint(f\"CSV columns: {len(flat_data)} fields\")\n</code></pre>"},{"location":"api/filtering/","title":"Filtering Configuration","text":"<p>Filtering allows you to control when streaming callbacks are triggered, reducing noise and focusing on meaningful changes.</p>"},{"location":"api/filtering/#overview","title":"Overview","text":"<p>The filtering system provides:</p> <ul> <li>Change Detection - Only trigger on actual data changes</li> <li>Threshold Filtering - Trigger only on significant changes</li> <li>Rate Limiting - Control maximum update frequency</li> <li>Field Selection - Monitor specific fields only</li> </ul>"},{"location":"api/filtering/#filterconfig-class","title":"FilterConfig Class","text":"<p>Custom filtering configuration for precise control.</p> <pre><code>from dataclasses import dataclass, field\nfrom typing import List, Optional\n\n@dataclass\nclass FilterConfig:\n    # Fields to monitor for changes\n    change_fields: List[str] = field(default_factory=lambda: [\n        \"price_usd\", \"price_native\", \"volume.h24\", \"liquidity.usd\"\n    ])\n\n    # Change thresholds (None = any change triggers)\n    price_change_threshold: Optional[float] = None      # Price change % (e.g., 0.01 = 1%)\n    volume_change_threshold: Optional[float] = None     # Volume change % (e.g., 0.10 = 10%)\n    liquidity_change_threshold: Optional[float] = None  # Liquidity change % (e.g., 0.05 = 5%)\n\n    # Rate limiting\n    max_updates_per_second: Optional[float] = None      # Max updates/sec (e.g., 1.0 = 1/sec)\n</code></pre>"},{"location":"api/filtering/#parameters","title":"Parameters","text":"<ul> <li><code>change_fields</code>: List of fields to monitor. Only changes in these fields can trigger updates. Supports nested   fields (e.g., \"volume.h24\")</li> <li><code>price_change_threshold</code>: Price change percentage threshold. Set to 0.01 for 1% changes</li> <li><code>volume_change_threshold</code>: Volume change percentage threshold. Set to 0.10 for 10% changes</li> <li><code>liquidity_change_threshold</code>: Liquidity change percentage threshold. Set to 0.05 for 5% changes</li> <li><code>max_updates_per_second</code>: Limits update frequency to avoid overwhelming callbacks</li> </ul>"},{"location":"api/filtering/#custom-configuration-examples","title":"Custom Configuration Examples","text":"<pre><code>from dexscreen.utils import FilterConfig\n\n# High-frequency trading config\nhft_config = FilterConfig(\n    change_fields=[\"price_usd\"],           # Only monitor price\n    price_change_threshold=0.0001,         # 0.01% changes\n    max_updates_per_second=10.0            # Allow frequent updates\n)\n\n# Long-term monitoring config\nhodl_config = FilterConfig(\n    change_fields=[\"price_usd\", \"liquidity.usd\"],\n    price_change_threshold=0.05,           # 5% changes\n    liquidity_change_threshold=0.20,       # 20% liquidity changes\n    max_updates_per_second=0.1             # Once per 10 seconds max\n)\n\n# Volume surge detection\nvolume_config = FilterConfig(\n    change_fields=[\"volume.h24\", \"volume.h1\", \"transactions.m5.buys\", \"transactions.m5.sells\"],\n    volume_change_threshold=0.15,          # 15% volume changes\n    max_updates_per_second=0.5             # Once per 2 seconds max\n)\n</code></pre>"},{"location":"api/filtering/#filterpresets","title":"FilterPresets","text":"<p>Pre-configured filters for common use cases.</p>"},{"location":"api/filtering/#simple_change_detection","title":"simple_change_detection()","text":"<pre><code>config = FilterPresets.simple_change_detection()\n</code></pre> <p>Basic change detection (default behavior) - any monitored field change triggers an update.</p> <p>Use for: General monitoring where you want all changes</p>"},{"location":"api/filtering/#significant_price_changesthreshold","title":"significant_price_changes(threshold)","text":"<pre><code>config = FilterPresets.significant_price_changes(0.01)  # 1% threshold\n</code></pre> <p>Only triggers when price changes exceed the threshold.</p> <p>Use for: Price alerts, trading signals</p>"},{"location":"api/filtering/#significant_all_changesprice_threshold-volume_threshold-liquidity_threshold","title":"significant_all_changes(price_threshold, volume_threshold, liquidity_threshold)","text":"<pre><code>config = FilterPresets.significant_all_changes(\n    price_threshold=0.005,      # 0.5% price change\n    volume_threshold=0.10,      # 10% volume change\n    liquidity_threshold=0.05    # 5% liquidity change\n)\n</code></pre> <p>All metrics must meet their thresholds to trigger.</p> <p>Use for: High-confidence signals requiring multiple confirmations</p>"},{"location":"api/filtering/#rate_limitedmax_per_second","title":"rate_limited(max_per_second)","text":"<pre><code>config = FilterPresets.rate_limited(1.0)  # Max 1 update per second\n</code></pre> <p>Limits update frequency regardless of changes.</p> <p>Use for: UI updates, reducing callback load</p>"},{"location":"api/filtering/#ui_friendly","title":"ui_friendly()","text":"<pre><code>config = FilterPresets.ui_friendly()\n</code></pre> <p>Optimized for user interfaces:</p> <ul> <li>Price change threshold: 0.1%</li> <li>Volume change threshold: 5%</li> <li>Max 2 updates per second</li> </ul> <p>Use for: Dashboard displays, real-time charts</p>"},{"location":"api/filtering/#monitoring","title":"monitoring()","text":"<pre><code>config = FilterPresets.monitoring()\n</code></pre> <p>Optimized for monitoring systems:</p> <ul> <li>Price change threshold: 1%</li> <li>Volume change threshold: 10%</li> <li>Liquidity change threshold: 5%</li> <li>Max 0.2 updates per second (once per 5 seconds)</li> </ul> <p>Use for: Alert systems, background monitoring</p>"},{"location":"api/filtering/#usage-examples","title":"Usage Examples","text":""},{"location":"api/filtering/#basic-filtering","title":"Basic Filtering","text":"<pre><code># Default filtering (changes only)\nawait client.subscribe_pairs(\n    chain_id=\"ethereum\",\n    pair_addresses=[\"0x88e6...\"],\n    callback=handle_update,\n    filter=True  # Default\n)\n\n# No filtering (all updates)\nawait client.subscribe_pairs(\n    chain_id=\"ethereum\",\n    pair_addresses=[\"0x88e6...\"],\n    callback=handle_update,\n    filter=False\n)\n\n# Preset filtering\nawait client.subscribe_pairs(\n    chain_id=\"ethereum\",\n    pair_addresses=[\"0x88e6...\"],\n    callback=handle_update,\n    filter=FilterPresets.significant_price_changes(0.02)  # 2%\n)\n</code></pre>"},{"location":"api/filtering/#advanced-filtering","title":"Advanced Filtering","text":"<pre><code># Multi-metric monitoring\ncomprehensive_config = FilterConfig(\n    change_fields=[\"price_usd\", \"volume.h24\", \"liquidity.usd\", \"price_change.h24\"],\n    price_change_threshold=0.02,           # 2% price change\n    volume_change_threshold=0.25,          # 25% volume change\n    liquidity_change_threshold=0.10,       # 10% liquidity change\n    max_updates_per_second=1.0             # Max once per second\n)\n\nawait client.subscribe_pairs(\n    chain_id=\"ethereum\",\n    pair_addresses=addresses,\n    callback=comprehensive_handler,\n    filter=comprehensive_config\n)\n</code></pre>"},{"location":"api/filtering/#conditional-filtering","title":"Conditional Filtering","text":"<p>Combine filtering with callback logic:</p> <pre><code># Filter config for significant changes\nconfig = FilterConfig(\n    change_fields=[\"price_usd\", \"volume.h1\"],\n    price_change_threshold=0.001  # 0.1%\n)\n\n# Additional logic in callback\ndef smart_callback(pair: TokenPair):\n    # Filter already ensured significant change\n    # Add more conditions\n    if pair.volume.h1 &gt; 10_000:  # Minimum volume\n        if pair.liquidity and pair.liquidity.usd &gt; 50_000:  # Minimum liquidity\n            process_significant_update(pair)\n</code></pre>"},{"location":"api/filtering/#monitorable-fields","title":"Monitorable Fields","text":"<p>Fields you can monitor in <code>change_fields</code>:</p>"},{"location":"api/filtering/#price-fields","title":"Price Fields","text":"<ul> <li><code>price_usd</code> - USD price</li> <li><code>price_native</code> - Native token price</li> </ul>"},{"location":"api/filtering/#volume-fields","title":"Volume Fields","text":"<ul> <li><code>volume.h24</code> - 24-hour volume</li> <li><code>volume.h6</code> - 6-hour volume</li> <li><code>volume.h1</code> - 1-hour volume</li> <li><code>volume.m5</code> - 5-minute volume</li> </ul>"},{"location":"api/filtering/#liquidity-fields","title":"Liquidity Fields","text":"<ul> <li><code>liquidity.usd</code> - USD liquidity</li> <li><code>liquidity.base</code> - Base token liquidity</li> <li><code>liquidity.quote</code> - Quote token liquidity</li> </ul>"},{"location":"api/filtering/#transaction-fields","title":"Transaction Fields","text":"<ul> <li><code>transactions.m5.buys</code> - 5-minute buy count</li> <li><code>transactions.m5.sells</code> - 5-minute sell count</li> <li><code>transactions.h1.buys</code> - 1-hour buy count</li> <li><code>transactions.h1.sells</code> - 1-hour sell count</li> <li><code>transactions.h6.buys</code> - 6-hour buy count</li> <li><code>transactions.h6.sells</code> - 6-hour sell count</li> <li><code>transactions.h24.buys</code> - 24-hour buy count</li> <li><code>transactions.h24.sells</code> - 24-hour sell count</li> </ul>"},{"location":"api/filtering/#price-change-fields","title":"Price Change Fields","text":"<ul> <li><code>price_change.m5</code> - 5-minute price change %</li> <li><code>price_change.h1</code> - 1-hour price change %</li> <li><code>price_change.h6</code> - 6-hour price change %</li> <li><code>price_change.h24</code> - 24-hour price change %</li> </ul>"},{"location":"api/filtering/#other-fields","title":"Other Fields","text":"<ul> <li><code>fdv</code> - Fully diluted valuation</li> </ul> <p>Note: Use dot notation for nested fields (e.g., <code>volume.h24</code>, <code>transactions.m5.buys</code>)</p>"},{"location":"api/filtering/#performance-considerations","title":"Performance Considerations","text":""},{"location":"api/filtering/#filter-efficiency","title":"Filter Efficiency","text":"<p>Filters are applied client-side after data is fetched:</p> <ol> <li>Data Fetching: Happens at the specified interval</li> <li>Change Detection: Compares with previous data</li> <li>Threshold Check: Applies configured thresholds</li> <li>Rate Limiting: Enforces max update frequency</li> <li>Callback Execution: Only if all conditions pass</li> </ol>"},{"location":"api/filtering/#optimization-tips","title":"Optimization Tips","text":"<ol> <li>Minimize Monitored Fields: Only include fields you actually need</li> </ol> <pre><code># Good - specific fields\nchange_fields=[\"price_usd\", \"volume.h24\"]\n\n# Bad - monitoring everything\nchange_fields=[\"price_usd\", \"price_native\", \"volume.h24\", \"volume.h6\", ...]\n</code></pre> <ol> <li>Set Appropriate Thresholds: Balance between sensitivity and noise</li> </ol> <pre><code># High-value assets - larger threshold\neth_config = FilterConfig(price_change_threshold=0.01)  # 1%\n\n# Low-value/volatile assets - smaller threshold\nmeme_config = FilterConfig(price_change_threshold=0.001)  # 0.1%\n</code></pre> <ol> <li>Use Rate Limiting: Prevent callback overload</li> </ol> <pre><code># For UI updates\nui_config = FilterConfig(max_updates_per_second=2.0)\n\n# For logging/database\ndb_config = FilterConfig(max_updates_per_second=0.1)  # Once per 10 sec\n</code></pre>"},{"location":"api/filtering/#common-patterns","title":"Common Patterns","text":""},{"location":"api/filtering/#price-alert-system","title":"Price Alert System","text":"<pre><code># Different alert levels\nminor_alert = FilterConfig(\n    change_fields=[\"price_usd\"],\n    price_change_threshold=0.02,  # 2%\n    max_updates_per_second=1.0\n)\n\nmajor_alert = FilterConfig(\n    change_fields=[\"price_usd\"],\n    price_change_threshold=0.05,  # 5%\n    max_updates_per_second=None   # No rate limit for major alerts\n)\n\n# Subscribe with different callbacks\nawait client.subscribe_pairs(chain_id, pairs, minor_callback, filter=minor_alert)\nawait client.subscribe_pairs(chain_id, pairs, major_callback, filter=major_alert)\n</code></pre>"},{"location":"api/filtering/#multi-strategy-filtering","title":"Multi-Strategy Filtering","text":"<pre><code>strategies = {\n    \"scalping\": FilterConfig(\n        change_fields=[\"price_usd\"],\n        price_change_threshold=0.0005,  # 0.05%\n        max_updates_per_second=10.0\n    ),\n    \"swing\": FilterConfig(\n        change_fields=[\"price_usd\", \"volume.h24\"],\n        price_change_threshold=0.02,    # 2%\n        volume_change_threshold=0.30,   # 30%\n        max_updates_per_second=0.2      # Once per 5 sec\n    ),\n    \"liquidity\": FilterConfig(\n        change_fields=[\"liquidity.usd\"],\n        liquidity_change_threshold=0.10,  # 10%\n        max_updates_per_second=0.1        # Once per 10 sec\n    )\n}\n\n# Apply different strategies to different pairs\nfor strategy_name, config in strategies.items():\n    pairs = get_pairs_for_strategy(strategy_name)\n    callback = create_strategy_callback(strategy_name)\n    await client.subscribe_pairs(\"ethereum\", pairs, callback, filter=config)\n</code></pre>"},{"location":"api/filtering/#production-alert-system","title":"Production Alert System","text":"<pre><code>from enum import Enum\nfrom datetime import datetime\n\nclass AlertLevel(Enum):\n    INFO = \"info\"\n    WARNING = \"warning\"\n    CRITICAL = \"critical\"\n\nclass ProductionAlertSystem:\n    def __init__(self):\n        self.alert_count = {level: 0 for level in AlertLevel}\n\n    async def deploy_monitoring(self, client, watch_pairs):\n        \"\"\"Deploy production-grade filtering system\"\"\"\n\n        # Tier 1: Informational (1% moves)\n        info_filter = FilterConfig(\n            change_fields=[\"price_usd\"],\n            price_change_threshold=0.01,\n            max_updates_per_second=0.5  # Don't spam\n        )\n\n        # Tier 2: Warning (5% moves + volume)\n        warning_filter = FilterConfig(\n            change_fields=[\"price_usd\", \"volume.h24\"],\n            price_change_threshold=0.05,\n            volume_change_threshold=0.75,\n            max_updates_per_second=2.0\n        )\n\n        # Tier 3: Critical (10% moves + liquidity issues)\n        critical_filter = FilterConfig(\n            change_fields=[\"price_usd\", \"liquidity.usd\"],\n            price_change_threshold=0.10,\n            liquidity_change_threshold=0.25,\n            max_updates_per_second=10.0  # No limits on critical\n        )\n\n        # Deploy all tiers\n        await client.subscribe_pairs(\n            \"ethereum\", watch_pairs,\n            lambda p: self.handle_alert(p, AlertLevel.INFO),\n            filter=info_filter\n        )\n\n        await client.subscribe_pairs(\n            \"ethereum\", watch_pairs,\n            lambda p: self.handle_alert(p, AlertLevel.WARNING),\n            filter=warning_filter\n        )\n\n        await client.subscribe_pairs(\n            \"ethereum\", watch_pairs,\n            lambda p: self.handle_alert(p, AlertLevel.CRITICAL),\n            filter=critical_filter\n        )\n\n        print(f\"\ud83d\ude80 Production monitoring deployed for {len(watch_pairs)} pairs\")\n\n    async def handle_alert(self, pair, level: AlertLevel):\n        self.alert_count[level] += 1\n\n        if level == AlertLevel.CRITICAL:\n            await self.send_sms(f\"CRITICAL: {pair.base_token.symbol} moved {pair.price_change.h24:+.1f}%\")\n            await self.send_email_alert(pair, level)\n        elif level == AlertLevel.WARNING:\n            await self.send_slack_message(pair, level)\n        else:\n            print(f\"\ud83d\udcca {pair.base_token.symbol}: {pair.price_change.h24:+.2f}%\")\n\n    async def send_sms(self, message): pass  # Implement SMS\n    async def send_email_alert(self, pair, level): pass  # Implement email\n    async def send_slack_message(self, pair, level): pass  # Implement Slack\n\n# Usage\nalert_system = ProductionAlertSystem()\nwatch_list = [\"0x88e6a0c2ddd26feeb64f039a2c41296fcb3f5640\"]  # Add your pairs\nawait alert_system.deploy_monitoring(client, watch_list)\n</code></pre>"},{"location":"api/query-api/","title":"Query API Reference","text":"<p>The Query API provides synchronous and asynchronous methods for fetching data from Dexscreener. All methods have both sync and async versions.</p>"},{"location":"api/query-api/#overview","title":"Overview","text":"<p>Query methods are one-time data fetches that return immediately with the current data. They are ideal for:</p> <ul> <li>Getting current prices</li> <li>Searching for tokens</li> <li>Fetching pair information</li> <li>Retrieving token profiles</li> </ul>"},{"location":"api/query-api/#rate-limits","title":"Rate Limits","text":"<ul> <li>Pair queries: 300 requests/minute</li> <li>Token profiles/orders: 60 requests/minute</li> </ul> <p>The SDK automatically handles rate limiting with retry logic.</p>"},{"location":"api/query-api/#pair-queries","title":"Pair Queries","text":""},{"location":"api/query-api/#get_pair-get_pair_async","title":"get_pair / get_pair_async","text":"<pre><code>def get_pair(address: str) -&gt; Optional[TokenPair]\nasync def get_pair_async(address: str) -&gt; Optional[TokenPair]\n</code></pre> <p>Get information for a single trading pair (implemented via search, no need to specify chain).</p> <p>Example:</p> <pre><code># Sync\npair = client.get_pair(\"JUPyiwrYJFskUPiHa7hkeR8VUtAeFoSYbKedZNsDvCN\")\nif pair:\n    print(f\"{pair.base_token.symbol}: ${pair.price_usd}\")\n\n# Async\npair = await client.get_pair_async(\"JUPyiwrYJFskUPiHa7hkeR8VUtAeFoSYbKedZNsDvCN\")\n</code></pre>"},{"location":"api/query-api/#get_pair_by_pair_address-get_pair_by_pair_address_async","title":"get_pair_by_pair_address / get_pair_by_pair_address_async","text":"<pre><code>def get_pair_by_pair_address(chain_id: str, pair_address: str) -&gt; Optional[TokenPair]\nasync def get_pair_by_pair_address_async(chain_id: str, pair_address: str) -&gt; Optional[TokenPair]\n</code></pre> <p>Get trading pair information on a specified blockchain.</p> <p>Parameters:</p> <ul> <li><code>chain_id</code>: Blockchain identifier (e.g., \"ethereum\", \"solana\", \"bsc\")</li> <li><code>pair_address</code>: The pair contract address</li> </ul> <p>Example:</p> <pre><code>pair = client.get_pair_by_pair_address(\n    \"ethereum\",\n    \"0x88e6a0c2ddd26feeb64f039a2c41296fcb3f5640\"  # USDC/WETH\n)\n</code></pre>"},{"location":"api/query-api/#get_pairs_by_pairs_addresses-get_pairs_by_pairs_addresses_async","title":"get_pairs_by_pairs_addresses / get_pairs_by_pairs_addresses_async","text":"<pre><code>def get_pairs_by_pairs_addresses(chain_id: str, pair_addresses: List[str]) -&gt; List[TokenPair]\nasync def get_pairs_by_pairs_addresses_async(chain_id: str, pair_addresses: List[str]) -&gt; List[TokenPair]\n</code></pre> <p>Batch fetch trading pair information (same chain). Supports up to 30 addresses, exceeding this will raise ValueError.</p> <p>Example:</p> <pre><code>pairs = client.get_pairs_by_pairs_addresses(\n    \"ethereum\",\n    [\n        \"0x88e6a0c2ddd26feeb64f039a2c41296fcb3f5640\",\n        \"0x11b815efb8f581194ae79006d24e0d814b7697f6\",\n        \"0x4e68ccd3e89f51c3074ca5072bbac773960dfa36\"\n    ]\n)\n</code></pre>"},{"location":"api/query-api/#search_pairs-search_pairs_async","title":"search_pairs / search_pairs_async","text":"<pre><code>def search_pairs(query: str) -&gt; List[TokenPair]\nasync def search_pairs_async(query: str) -&gt; List[TokenPair]\n</code></pre> <p>Search for trading pairs (by name, symbol, or address).</p> <p>Example:</p> <pre><code># Search by symbol\nresults = client.search_pairs(\"PEPE\")\n\n# Search by name\nresults = client.search_pairs(\"Shiba Inu\")\n\n# Search by address\nresults = client.search_pairs(\"0x88e6a0c2ddd26feeb64f039a2c41296fcb3f5640\")\n</code></pre>"},{"location":"api/query-api/#get_pairs_by_token_address-get_pairs_by_token_address_async","title":"get_pairs_by_token_address / get_pairs_by_token_address_async","text":"<pre><code>def get_pairs_by_token_address(chain_id: str, token_address: str) -&gt; List[TokenPair]\nasync def get_pairs_by_token_address_async(chain_id: str, token_address: str) -&gt; List[TokenPair]\n</code></pre> <p>Get all trading pairs for a single token on a specified chain. Returns all trading pairs for that token across all DEXs on that chain.</p> <p>Example:</p> <pre><code># Get all USDC pairs on Ethereum\nusdc_pairs = client.get_pairs_by_token_address(\n    \"ethereum\",\n    \"A0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\"  # USDC\n)\n\nfor pair in usdc_pairs:\n    other_token = pair.quote_token if pair.base_token.address.lower() == usdc_address.lower() else pair.base_token\n    print(f\"USDC/{other_token.symbol} on {pair.dex_id}: ${pair.price_usd}\")\n</code></pre>"},{"location":"api/query-api/#get_pairs_by_token_addresses-get_pairs_by_token_addresses_async","title":"get_pairs_by_token_addresses / get_pairs_by_token_addresses_async","text":"<pre><code>def get_pairs_by_token_addresses(chain_id: str, token_addresses: List[str]) -&gt; List[TokenPair]\nasync def get_pairs_by_token_addresses_async(chain_id: str, token_addresses: List[str]) -&gt; List[TokenPair]\n</code></pre> <p>Batch fetch all trading pairs for multiple tokens on a specified chain. Returns all trading pairs containing any of the specified tokens (deduplicated).</p> <p>Important Notes:</p> <ul> <li>Chain ID must be specified (e.g., \"solana\", \"ethereum\", etc.)</li> <li>Supports up to 30 token addresses max, exceeding this will raise ValueError</li> <li>API returns maximum 30 trading pairs (most relevant/active)</li> <li>Returns a collection of all trading pairs containing any of these tokens. If a trading pair contains multiple   specified tokens (e.g., USDC/SOL pair contains both USDC and SOL), it will only appear once</li> </ul> <p>Example:</p> <pre><code># Get pairs for multiple tokens\ntoken_addresses = [\n    \"A0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\",  # USDC\n    \"dac17f958d2ee523a2206206994597c13d831ec7\",  # USDT\n    \"6B175474E89094C44Da98b954EedeAC495271d0F\"   # DAI\n]\n\nstablecoin_pairs = client.get_pairs_by_token_addresses(\"ethereum\", token_addresses)\n</code></pre>"},{"location":"api/query-api/#token-information-queries","title":"Token Information Queries","text":""},{"location":"api/query-api/#get_latest_token_profiles-get_latest_token_profiles_async","title":"get_latest_token_profiles / get_latest_token_profiles_async","text":"<pre><code>def get_latest_token_profiles() -&gt; List[TokenInfo]\nasync def get_latest_token_profiles_async() -&gt; List[TokenInfo]\n</code></pre> <p>Get latest token profiles. Rate limit: 60 requests/minute.</p> <p>Example:</p> <pre><code>profiles = client.get_latest_token_profiles()\nfor token in profiles[:10]:\n    print(f\"{token.token_address}: {token.description}\")\n</code></pre>"},{"location":"api/query-api/#get_latest_boosted_tokens-get_latest_boosted_tokens_async","title":"get_latest_boosted_tokens / get_latest_boosted_tokens_async","text":"<pre><code>def get_latest_boosted_tokens() -&gt; List[TokenInfo]\nasync def get_latest_boosted_tokens_async() -&gt; List[TokenInfo]\n</code></pre> <p>Get latest boosted tokens. Rate limit: 60 requests/minute.</p> <p>Example:</p> <pre><code>boosted = client.get_latest_boosted_tokens()\nfor token in boosted:\n    print(f\"{token.chain_id}: {token.token_address} - Boost: {token.amount}\")\n</code></pre>"},{"location":"api/query-api/#get_tokens_most_active-get_tokens_most_active_async","title":"get_tokens_most_active / get_tokens_most_active_async","text":"<pre><code>def get_tokens_most_active() -&gt; List[TokenInfo]\nasync def get_tokens_most_active_async() -&gt; List[TokenInfo]\n</code></pre> <p>Get most active boosted tokens. Rate limit: 60 requests/minute.</p>"},{"location":"api/query-api/#pool-information-queries","title":"Pool Information Queries","text":""},{"location":"api/query-api/#get_pools_by_token_address-get_pools_by_token_address_async","title":"get_pools_by_token_address / get_pools_by_token_address_async","text":"<pre><code>def get_pools_by_token_address(chain_id: str, token_address: str) -&gt; List[TokenPair]\nasync def get_pools_by_token_address_async(chain_id: str, token_address: str) -&gt; List[TokenPair]\n</code></pre> <p>Get pool information using the token-pairs/v1 endpoint. Similar to get_pairs_by_pairs_addresses but uses a different API endpoint. Rate limit: 300 requests/minute.</p>"},{"location":"api/query-api/#order-queries","title":"Order Queries","text":""},{"location":"api/query-api/#get_orders_paid_of_token-get_orders_paid_of_token_async","title":"get_orders_paid_of_token / get_orders_paid_of_token_async","text":"<pre><code>def get_orders_paid_of_token(chain_id: str, token_address: str) -&gt; List[OrderInfo]\nasync def get_orders_paid_of_token_async(chain_id: str, token_address: str) -&gt; List[OrderInfo]\n</code></pre> <p>Get paid orders for a token. Rate limit: 60 requests/minute.</p> <p>Example:</p> <pre><code>orders = client.get_orders_paid_of_token(\"ethereum\", token_address)\nfor order in orders:\n    print(f\"Order {order.type}: {order.status} at {order.payment_timestamp}\")\n</code></pre>"},{"location":"api/query-api/#best-practices","title":"Best Practices","text":""},{"location":"api/query-api/#1-use-async-for-multiple-queries","title":"1. Use Async for Multiple Queries","text":"<p>When fetching data for multiple tokens/pairs, use async methods:</p> <pre><code>import asyncio\n\nasync def fetch_multiple_tokens():\n    client = DexscreenerClient()\n\n    tokens = [\"address1\", \"address2\", \"address3\"]\n\n    # Concurrent fetching\n    tasks = [\n        client.get_pairs_by_token_address_async(\"ethereum\", addr)\n        for addr in tokens\n    ]\n\n    results = await asyncio.gather(*tasks)\n    return results\n</code></pre>"},{"location":"api/query-api/#2-handle-rate-limits","title":"2. Handle Rate Limits","text":"<p>The SDK handles rate limits automatically, but you can also be proactive:</p> <pre><code># Space out requests for token profiles (60/min limit)\nimport time\n\nfor token_address in large_token_list:\n    orders = client.get_orders_paid_of_token(\"ethereum\", token_address)\n    process_orders(orders)\n    time.sleep(1.1)  # ~54 requests per minute to be safe\n</code></pre>"},{"location":"api/query-api/#3-error-handling","title":"3. Error Handling","text":"<p>Always handle potential None returns:</p> <pre><code>pair = client.get_pair_by_pair_address(\"ethereum\", pair_address)\nif pair:\n    # Process pair data\n    print(f\"Price: ${pair.price_usd}\")\nelse:\n    print(f\"Pair {pair_address} not found\")\n</code></pre>"},{"location":"api/query-api/#4-batch-operations","title":"4. Batch Operations","text":"<p>For multiple addresses on the same chain, use batch methods:</p> <pre><code># Instead of this:\npairs = []\nfor address in addresses:\n    pair = client.get_pair_by_pair_address(\"ethereum\", address)\n    if pair:\n        pairs.append(pair)\n\n# Do this:\npairs = client.get_pairs_by_pairs_addresses(\"ethereum\", addresses)\n</code></pre>"},{"location":"api/query-api/#common-patterns","title":"Common Patterns","text":""},{"location":"api/query-api/#finding-arbitrage-opportunities","title":"Finding Arbitrage Opportunities","text":"<pre><code>async def find_arbitrage(token_address: str):\n    client = DexscreenerClient()\n\n    # Get pairs across multiple chains\n    chains = [\"ethereum\", \"bsc\", \"polygon\", \"arbitrum\"]\n\n    tasks = [\n        client.get_pairs_by_token_address_async(chain, token_address)\n        for chain in chains\n    ]\n\n    all_pairs = await asyncio.gather(*tasks)\n\n    # Flatten and analyze\n    prices_by_chain = {}\n    for chain, pairs in zip(chains, all_pairs):\n        if pairs:\n            # Get the most liquid pair\n            best_pair = max(pairs, key=lambda p: p.liquidity.usd or 0)\n            prices_by_chain[chain] = best_pair.price_usd\n\n    # Find arbitrage\n    if len(prices_by_chain) &gt; 1:\n        min_price = min(prices_by_chain.values())\n        max_price = max(prices_by_chain.values())\n        spread = ((max_price - min_price) / min_price) * 100\n\n        if spread &gt; 1:  # 1% threshold\n            print(f\"Arbitrage opportunity: {spread:.2f}% spread\")\n            return prices_by_chain\n</code></pre>"},{"location":"api/query-api/#token-discovery","title":"Token Discovery","text":"<pre><code>def discover_new_tokens():\n    client = DexscreenerClient()\n\n    # Get latest profiles\n    profiles = client.get_latest_token_profiles()\n\n    # Filter interesting tokens\n    interesting = []\n    for token in profiles:\n        # Get trading data\n        pairs = client.get_pairs_by_token_address(token.chain_id, token.token_address)\n\n        if pairs:\n            total_volume = sum(p.volume.h24 for p in pairs if p.volume.h24)\n            total_liquidity = sum(p.liquidity.usd for p in pairs if p.liquidity and p.liquidity.usd)\n\n            if total_volume &gt; 100_000 and total_liquidity &gt; 50_000:\n                interesting.append({\n                    'token': token,\n                    'pairs': pairs,\n                    'volume': total_volume,\n                    'liquidity': total_liquidity\n                })\n\n    return interesting\n</code></pre>"},{"location":"api/streaming-api/","title":"Streaming API Reference","text":"<p>The Streaming API provides real-time data updates through HTTP polling, supporting dynamic subscription management, flexible filtering, and multi-chain monitoring.</p> <p>\ud83d\udca1 Key Feature: Unlike WebSocket-based APIs, Dexscreen uses intelligent HTTP polling for better reliability and easier debugging.</p>"},{"location":"api/streaming-api/#overview","title":"Overview","text":"<p>Streaming methods provide continuous updates for price changes, volume, liquidity, and other metrics through intelligent polling.</p>"},{"location":"api/streaming-api/#perfect-for","title":"Perfect For:","text":"<ul> <li>\ud83d\udcb0 Trading Bots - Real-time price monitoring and execution</li> <li>\ud83d\udd04 Arbitrage Detection - Cross-chain price difference monitoring</li> <li>\ud83d\udcca Portfolio Tracking - Multi-asset performance monitoring</li> <li>\ud83d\udd0d Token Discovery - New pair and listing detection</li> <li>\ud83d\udea8 Alert Systems - Custom threshold-based notifications</li> </ul> <p>\u26a1 Performance: Polling intervals as low as 0.2 seconds with intelligent batching and filtering.</p>"},{"location":"api/streaming-api/#core-features","title":"Core Features","text":""},{"location":"api/streaming-api/#dynamic-subscription-management","title":"\ud83d\udd04 Dynamic Subscription Management","text":"<p>Subscriptions are cumulative - adding more pairs extends your monitoring rather than replacing it:</p> <pre><code># 1. Start monitoring USDC/WETH\nawait client.subscribe_pairs(\"ethereum\", [\"0xaaa...\"], callback)\n\n# 2. Add more pairs (now monitoring 3 pairs total)\nawait client.subscribe_pairs(\"ethereum\", [\"0xbbb...\", \"0xccc...\"], callback)\n\n# 3. Remove specific pairs (now monitoring 2 pairs)\nawait client.unsubscribe_pairs(\"ethereum\", [\"0xaaa...\"])\n\n# 4. Check what's currently active\nactive = client.get_active_subscriptions()\nprint(f\"Monitoring {len(active)} subscriptions\")\n</code></pre> <p>\ud83d\udcd8 Important: Each <code>subscribe_pairs()</code> call adds to existing subscriptions - it doesn't replace them.</p>"},{"location":"api/streaming-api/#multi-chain-support","title":"\ud83c\udf10 Multi-chain Support","text":"<p>Monitor multiple blockchains simultaneously with independent configurations:</p> <pre><code># Each chain can have different settings\nawait client.subscribe_pairs(\n    \"ethereum\", eth_pairs, eth_callback,\n    interval=1.0,  # Slower for expensive chains\n    filter=FilterPresets.significant_price_changes(0.01)\n)\n\nawait client.subscribe_pairs(\n    \"solana\", sol_pairs, sol_callback,\n    interval=0.2,  # Faster for cheaper chains\n    filter=FilterPresets.ui_friendly()\n)\n\nawait client.subscribe_pairs(\n    \"bsc\", bsc_pairs, bsc_callback,\n    interval=0.5,  # Balanced for moderate costs\n    filter=FilterPresets.monitoring()\n)\n</code></pre> <p>\ud83d\ude80 Pro Tip: Adjust intervals based on chain speed and costs - faster chains can use shorter intervals.</p>"},{"location":"api/streaming-api/#main-methods","title":"Main Methods","text":""},{"location":"api/streaming-api/#subscribe_pairs","title":"subscribe_pairs","text":"<pre><code>async def subscribe_pairs(\n    chain_id: str,\n    pair_addresses: List[str],\n    callback: Callable[[TokenPair], None],\n    *,\n    filter: Union[bool, FilterConfig] = True,\n    interval: float = 0.2\n) -&gt; None\n</code></pre> <p>Subscribe to real-time pair updates. Supports dynamic addition - multiple calls accumulate subscriptions rather than replacing them.</p> <p>Parameters:</p> <ul> <li><code>chain_id</code>: Blockchain identifier (e.g., \"ethereum\", \"solana\")</li> <li><code>pair_addresses</code>: List of pair contract addresses</li> <li><code>callback</code>: Function called on each update, receives TokenPair object</li> <li><code>filter</code>: Filtering configuration:</li> <li><code>True</code> (default): Only emit on data changes</li> <li><code>False</code>: Emit all polling results</li> <li><code>FilterConfig</code> object: Custom filtering rules</li> <li><code>interval</code>: Polling interval in seconds (default 0.2s)</li> </ul> <p>Real-World Examples:</p> <pre><code># Example 1: High-frequency trading monitor\nawait client.subscribe_pairs(\n    \"ethereum\",\n    [\"0x88e6a0c2ddd26feeb64f039a2c41296fcb3f5640\"],  # USDC/ETH\n    hft_callback,\n    filter=FilterPresets.significant_price_changes(0.001),  # 0.1% sensitivity\n    interval=0.2  # Very fast updates\n)\n\n# Example 2: Cross-DEX arbitrage scanner\n# Monitor WETH/USDC on different DEXs\nweth_usdc_pairs = [\n    \"0x88e6a0c2ddd26feeb64f039a2c41296fcb3f5640\",  # Uniswap V3\n    \"0x4e68ccd3e89f51c3074ca5072bbac773960dfa36\",  # Uniswap V3 (different fee)\n    \"0x397ff1542f962076d0bfe58ea045ffa2d347aca0\"   # Sushiswap\n]\n\nawait client.subscribe_pairs(\n    \"ethereum\",\n    weth_usdc_pairs,\n    arbitrage_scanner,\n    filter=False,  # Need all price updates for comparison\n    interval=0.5   # Fast enough for arb opportunities\n)\n\n# Example 3: Portfolio tracking with smart filtering\nportfolio_config = FilterConfig(\n    change_fields=[\"price_usd\", \"volume.h24\", \"liquidity.usd\"],\n    price_change_threshold=0.02,     # 2% price change threshold\n    volume_change_threshold=0.15,    # 15% volume change threshold\n    max_updates_per_second=0.5       # Max 1 update per 2 seconds\n)\n\nawait client.subscribe_pairs(\n    \"ethereum\",\n    portfolio_pairs,\n    portfolio_tracker,\n    filter=portfolio_config,\n    interval=10.0  # Relaxed checking for long-term holdings\n)\n</code></pre>"},{"location":"api/streaming-api/#subscribe_tokens","title":"subscribe_tokens","text":"<pre><code>async def subscribe_tokens(\n    chain_id: str,\n    token_addresses: List[str],\n    callback: Callable[[List[TokenPair]], None],\n    *,\n    filter: Union[bool, FilterConfig] = True,\n    interval: float = 0.2\n) -&gt; None\n</code></pre> <p>Subscribe to all pairs of specific tokens. Automatically discovers new pairs - ideal for comprehensive token monitoring.</p> <p>Parameters:</p> <ul> <li><code>chain_id</code>: Blockchain identifier</li> <li><code>token_addresses</code>: List of token contract addresses</li> <li><code>callback</code>: Function receiving list of all pairs for the token</li> <li><code>filter</code>: Filtering configuration (same as subscribe_pairs)</li> <li><code>interval</code>: Polling interval in seconds</li> </ul> <p>Real-World Examples:</p> <pre><code># Example 1: New token launch monitor\n# Great for discovering new DEX listings\nawait client.subscribe_tokens(\n    \"solana\",\n    [\"EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v\"],  # USDC on Solana\n    new_listing_detector,\n    filter=False,  # Get all updates to catch new pairs immediately\n    interval=1.0   # Check every second for new listings\n)\n\n# Example 2: Stablecoin liquidity monitoring across all pairs\n# Monitor USDC liquidity changes across all DEXs\nawait client.subscribe_tokens(\n    \"ethereum\",\n    [\"A0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\"],  # USDC\n    liquidity_monitor,\n    filter=FilterConfig(\n        change_fields=[\"liquidity.usd\", \"volume.h1\"],\n        liquidity_change_threshold=0.05,  # 5% liquidity threshold\n        volume_change_threshold=0.25      # 25% volume spike threshold\n    ),\n    interval=5.0  # Check every 5 seconds for liquidity changes\n)\n\n# Example 3: Multi-DEX price comparison for arbitrage\ndef price_comparison_callback(pairs: List[TokenPair]):\n    \"\"\"Analyze price differences across DEXs\"\"\"\n    if len(pairs) &lt; 2:\n        return\n\n    # Group pairs by DEX\n    dex_prices = {}\n    for pair in pairs:\n        if pair.price_usd:\n            dex_prices[pair.dex_id] = pair.price_usd\n\n    # Find arbitrage opportunities\n    if len(dex_prices) &gt;= 2:\n        prices = list(dex_prices.values())\n        spread = (max(prices) - min(prices)) / min(prices)\n\n        if spread &gt; 0.005:  # 0.5% spread threshold\n            print(f\"Arbitrage opportunity: {spread:.2%} spread\")\n            for dex, price in dex_prices.items():\n                print(f\"  {dex}: ${price:.6f}\")\n\n# Monitor WETH across all BSC DEXs\nawait client.subscribe_tokens(\n    \"bsc\",\n    [\"0x2170Ed0880ac9A755fd29B2688956BD959F933F8\"],  # WETH on BSC\n    price_comparison_callback,\n    interval=2.0\n)\n</code></pre>"},{"location":"api/streaming-api/#unsubscribe_pairs","title":"unsubscribe_pairs","text":"<pre><code>async def unsubscribe_pairs(chain_id: str, pair_addresses: List[str]) -&gt; None\n</code></pre> <p>Remove specific pair subscriptions. Chain ID must match exactly.</p> <pre><code># Remove single subscription\nawait client.unsubscribe_pairs(\"ethereum\", [\"0xaaa...\"])\n\n# Batch removal (more efficient)\nawait client.unsubscribe_pairs(\"ethereum\", [\n    \"0xaaa...\",\n    \"0xbbb...\",\n    \"0xccc...\"\n])\n\n# \u26a0\ufe0f Chain ID must match exactly\n# This WON'T remove the subscription (wrong chain)\nawait client.unsubscribe_pairs(\"bsc\", [\"0xaaa...\"])  # Address on ethereum\n</code></pre> <p>\ud83d\udcdd Note: Unsubscribing from non-existent pairs is safe and will be ignored.</p>"},{"location":"api/streaming-api/#unsubscribe_tokens","title":"unsubscribe_tokens","text":"<pre><code>async def unsubscribe_tokens(chain_id: str, token_addresses: List[str]) -&gt; None\n</code></pre> <p>Remove all pair subscriptions for specific tokens.</p> <pre><code># Stop monitoring USDC\nawait client.unsubscribe_tokens(\n    \"ethereum\",\n    [\"A0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\"]\n)\n</code></pre>"},{"location":"api/streaming-api/#close_streams","title":"close_streams","text":"<pre><code>async def close_streams() -&gt; None\n</code></pre> <p>Gracefully close all subscriptions and streaming connections. Always call this on program exit.</p> <pre><code># Pattern 1: Try/finally (recommended)\ntry:\n    await client.subscribe_pairs(...)\n    await asyncio.sleep(300)  # Run for 5 minutes\nfinally:\n    await client.close_streams()  # Always cleanup\n\n# Pattern 2: Context manager style\nasync def monitor_with_cleanup():\n    client = DexscreenerClient()\n    try:\n        await client.subscribe_pairs(...)\n        # Your monitoring logic\n        while True:\n            await asyncio.sleep(1)\n    except KeyboardInterrupt:\n        print(\"Stopping...\")\n    finally:\n        await client.close_streams()\n        print(\"Streams closed.\")\n</code></pre> <p>\u26a0\ufe0f Important: Failing to call <code>close_streams()</code> may leave background tasks running.</p>"},{"location":"api/streaming-api/#management-methods","title":"Management Methods","text":""},{"location":"api/streaming-api/#get_active_subscriptions","title":"get_active_subscriptions","text":"<pre><code>def get_active_subscriptions() -&gt; List[Dict[str, Any]]\n</code></pre> <p>Get detailed information about all active subscriptions.</p> <pre><code># View all subscriptions\nactive = client.get_active_subscriptions()\nfor sub in active:\n    if sub[\"type\"] == \"pair\":\n        print(f\"Pair: {sub['chain_id']}:{sub['pair_address']}\")\n    else:\n        print(f\"Token: {sub['chain_id']}:{sub['token_address']}\")\n\n# Return format example\n[\n    {\n        \"type\": \"pair\",\n        \"chain_id\": \"ethereum\",\n        \"pair_address\": \"0x88e6...\",\n        \"filter\": True,\n        \"interval\": 1.0\n    },\n    {\n        \"type\": \"token\",\n        \"chain_id\": \"solana\",\n        \"token_address\": \"EPjFW...\",\n        \"filter\": FilterConfig(...),\n        \"interval\": 0.2\n    }\n]\n</code></pre>"},{"location":"api/streaming-api/#advanced-usage","title":"Advanced Usage","text":""},{"location":"api/streaming-api/#complete-subscription-lifecycle-management","title":"Complete Subscription Lifecycle Management","text":"<pre><code>class PortfolioManager:\n    def __init__(self):\n        self.client = DexscreenerClient()\n        self.active_pairs = set()\n\n    async def add_pair(self, chain_id: str, pair_address: str):\n        \"\"\"Dynamically add a pair to the portfolio\"\"\"\n        if (chain_id, pair_address) not in self.active_pairs:\n            await self.client.subscribe_pairs(\n                chain_id,\n                [pair_address],\n                self.handle_update,\n                filter=FilterPresets.monitoring()\n            )\n            self.active_pairs.add((chain_id, pair_address))\n\n    async def remove_pair(self, chain_id: str, pair_address: str):\n        \"\"\"Remove a pair from the portfolio\"\"\"\n        if (chain_id, pair_address) in self.active_pairs:\n            await self.client.unsubscribe_pairs(chain_id, [pair_address])\n            self.active_pairs.remove((chain_id, pair_address))\n\n    def handle_update(self, pair: TokenPair):\n        \"\"\"Process price updates\"\"\"\n        # Implement your logic\n        pass\n\n# Usage example\nmanager = PortfolioManager()\n\n# Dynamic management\nawait manager.add_pair(\"ethereum\", \"0xaaa...\")\nawait manager.add_pair(\"ethereum\", \"0xbbb...\")\nawait manager.remove_pair(\"ethereum\", \"0xaaa...\")\n</code></pre>"},{"location":"api/streaming-api/#multi-strategy-parallel-monitoring","title":"Multi-Strategy Parallel Monitoring","text":"<pre><code># Create different monitoring strategies for different purposes\nclient = DexscreenerClient()\n\n# Strategy 1: High-frequency trading monitor\nawait client.subscribe_pairs(\n    \"solana\",\n    hft_pairs,\n    hft_callback,\n    filter=FilterConfig(\n        price_change_threshold=0.0001,  # 0.01%\n        max_updates_per_second=10.0\n    ),\n    interval=0.2\n)\n\n# Strategy 2: Liquidity provider monitor\nawait client.subscribe_pairs(\n    \"ethereum\",\n    lp_pairs,\n    lp_callback,\n    filter=FilterConfig(\n        change_fields=[\"liquidity.usd\", \"volume.h24\"],\n        liquidity_change_threshold=0.01,  # 1%\n        volume_change_threshold=0.20      # 20%\n    ),\n    interval=5.0\n)\n\n# Strategy 3: Price alerts\nalert_config = FilterConfig(\n    price_change_threshold=0.05  # 5% change triggers alert\n)\nawait client.subscribe_pairs(\n    \"bsc\",\n    alert_pairs,\n    send_price_alert,\n    filter=alert_config,\n    interval=10.0\n)\n</code></pre>"},{"location":"api/streaming-api/#callback-best-practices","title":"Callback Best Practices","text":""},{"location":"api/streaming-api/#error-handling","title":"Error Handling","text":"<p>Always wrap callback logic in try-except:</p> <pre><code>async def safe_callback(pair: TokenPair):\n    try:\n        # Your logic here\n        if pair.price_usd &gt; threshold:\n            await send_alert(pair)\n    except Exception as e:\n        logger.error(f\"Callback error: {e}\")\n        # Don't let errors crash the subscription\n</code></pre>"},{"location":"api/streaming-api/#async-callbacks","title":"Async Callbacks","text":"<p>Callbacks can be sync or async:</p> <pre><code># Sync callback\ndef sync_handler(pair: TokenPair):\n    print(f\"Price: ${pair.price_usd}\")\n\n# Async callback\nasync def async_handler(pair: TokenPair):\n    await database.save_price(pair)\n    await check_trading_conditions(pair)\n\n# Both work with subscribe_pairs\nawait client.subscribe_pairs(\"ethereum\", addresses, sync_handler)\nawait client.subscribe_pairs(\"ethereum\", addresses, async_handler)\n</code></pre>"},{"location":"api/streaming-api/#state-management","title":"State Management","text":"<p>Use closures or classes for stateful callbacks:</p> <pre><code># Using closure\ndef create_ma_calculator(period: int):\n    prices = []\n\n    def calculate_ma(pair: TokenPair):\n        prices.append(pair.price_usd)\n        if len(prices) &gt; period:\n            prices.pop(0)\n\n        if len(prices) == period:\n            ma = sum(prices) / period\n            print(f\"MA({period}): ${ma:.4f}\")\n\n    return calculate_ma\n\n# Using class\nclass TradingStrategy:\n    def __init__(self):\n        self.positions = {}\n        self.alerts = []\n\n    async def process_update(self, pair: TokenPair):\n        # Complex stateful logic\n        if self.should_buy(pair):\n            await self.execute_buy(pair)\n</code></pre>"},{"location":"api/streaming-api/#performance-optimization","title":"Performance Optimization","text":""},{"location":"api/streaming-api/#1-subscription-limits","title":"1. Subscription Limits","text":"<ul> <li>Maximum 30 pair subscriptions per chain</li> <li>Exceeding limits will log warnings and ignore extra subscriptions</li> <li>Use <code>subscribe_tokens</code> to monitor all pairs of a token (no limit)</li> </ul>"},{"location":"api/streaming-api/#2-polling-optimization","title":"2. Polling Optimization","text":"<ul> <li>Multiple subscriptions on the same chain are batched automatically</li> <li>Polling interval is the minimum of all subscriptions on that chain</li> <li>Filters are applied independently per subscription</li> </ul>"},{"location":"api/streaming-api/#3-best-practices","title":"3. Best Practices","text":"<ul> <li>Check <code>get_active_subscriptions()</code> before subscribing to avoid duplicates</li> <li>Use appropriate filtering to reduce unnecessary callbacks</li> <li>Always call <code>close_streams()</code> on program exit</li> <li>Balance polling intervals with your real-time needs</li> </ul>"},{"location":"api/streaming-api/#common-patterns","title":"Common Patterns","text":""},{"location":"api/streaming-api/#price-alert-system","title":"Price Alert System","text":"<pre><code>class PriceAlertSystem:\n    def __init__(self, alert_thresholds: Dict[str, float]):\n        self.client = DexscreenerClient()\n        self.thresholds = alert_thresholds\n        self.last_prices = {}\n\n    async def start_monitoring(self):\n        for pair_address, threshold in self.thresholds.items():\n            await self.client.subscribe_pairs(\n                \"ethereum\",\n                [pair_address],\n                self.check_price,\n                filter=FilterConfig(\n                    price_change_threshold=threshold\n                )\n            )\n\n    def check_price(self, pair: TokenPair):\n        if pair.pair_address in self.last_prices:\n            old_price = self.last_prices[pair.pair_address]\n            change = abs(pair.price_usd - old_price) / old_price\n\n            if change &gt;= self.thresholds[pair.pair_address]:\n                self.send_alert(pair, old_price, pair.price_usd)\n\n        self.last_prices[pair.pair_address] = pair.price_usd\n</code></pre>"},{"location":"api/streaming-api/#volume-surge-detection","title":"Volume Surge Detection","text":"<pre><code>async def detect_volume_surges():\n    client = DexscreenerClient()\n\n    # Track volume history\n    volume_history = defaultdict(list)\n\n    def volume_callback(pair: TokenPair):\n        history = volume_history[pair.pair_address]\n        history.append(pair.volume.m5 or 0)\n\n        # Keep last 12 periods (1 hour of 5-min data)\n        if len(history) &gt; 12:\n            history.pop(0)\n\n        if len(history) &gt;= 6:\n            recent_avg = sum(history[-3:]) / 3\n            older_avg = sum(history[-6:-3]) / 3\n\n            if older_avg &gt; 0:\n                surge = recent_avg / older_avg\n                if surge &gt; 3:  # 3x volume surge\n                    print(f\"Volume surge detected: {pair.base_token.symbol} - {surge:.1f}x\")\n\n    # Monitor high-liquidity pairs\n    pairs = await client.search_pairs_async(\"ETH\")\n    liquid_pairs = [p for p in pairs if p.liquidity and p.liquidity.usd &gt; 100_000]\n\n    addresses = [p.pair_address for p in liquid_pairs[:20]]\n    await client.subscribe_pairs(\n        \"ethereum\",\n        addresses,\n        volume_callback,\n        filter=FilterConfig(change_fields=[\"volume.m5\"]),\n        interval=0.5\n    )\n</code></pre>"},{"location":"zh/","title":"Dexscreen \u6587\u6863","text":"<p>\u6b22\u8fce\u4f7f\u7528 Dexscreen \u6587\u6863\uff01\u8fd9\u4e2a Python SDK \u4e3a Dexscreener.com API \u63d0\u4f9b\u4e86\u7a33\u5b9a\u3001\u53ef\u9760\u4e14\u529f\u80fd\u4e30\u5bcc\u7684\u63a5\u53e3\uff0c\u652f\u6301\u5b9e\u65f6 DeFi \u6570\u636e\u76d1\u63a7\u548c\u5206\u6790\u3002</p> <p>\ud83c\udfaf \u5feb\u901f\u5f00\u59cb\uff1aDexscreen \u65b0\u624b\uff1f\u4ece\u6211\u4eec\u7684\u5165\u95e8\u6307\u5357\u5f00\u59cb\uff0c\u4e86\u89e3\u5b89\u88c5\u548c\u9996\u6b21\u67e5\u8be2\u3002</p>"},{"location":"zh/#_1","title":"\ud83d\ude80 \u5feb\u901f\u5bfc\u822a","text":"\u7ae0\u8282 \u63cf\u8ff0 \u9002\u7528\u573a\u666f \u5165\u95e8\u6307\u5357 \u5b89\u88c5\u3001\u8bbe\u7f6e\u548c\u9996\u6b21\u67e5\u8be2 \u65b0\u7528\u6237\u3001\u5feb\u901f\u8bbe\u7f6e \u67e5\u8be2 API \u5355\u6b21\u67e5\u8be2\u65b9\u6cd5\u83b7\u53d6\u6570\u636e \u4e00\u6b21\u6027\u6570\u636e\u83b7\u53d6\u3001API \u53c2\u8003 \u6d41\u5f0f API \u5b9e\u65f6\u8ba2\u9605\u65b9\u6cd5\u83b7\u53d6\u5b9e\u65f6\u66f4\u65b0 \u5b9e\u65f6\u76d1\u63a7\u3001\u4ea4\u6613\u673a\u5668\u4eba \u6570\u636e\u6a21\u578b \u6240\u6709\u6570\u636e\u7ed3\u6784\u7684\u5b8c\u6574\u53c2\u8003 \u7406\u89e3 API \u54cd\u5e94 \u8fc7\u6ee4\u5668 \u9ad8\u7ea7\u8fc7\u6ee4\u548c\u914d\u7f6e\u9009\u9879 \u4f18\u5316\u8ba2\u9605\u3001\u51cf\u5c11\u566a\u97f3 \u793a\u4f8b \u5e38\u89c1\u7528\u4f8b\u7684\u5b8c\u6574\u5de5\u4f5c\u793a\u4f8b \u5b9e\u4f8b\u5b66\u4e60\u3001\u751f\u4ea7\u6a21\u5f0f"},{"location":"zh/#_2","title":"\ud83d\udcda \u6587\u6863\u7ed3\u6784","text":""},{"location":"zh/#_3","title":"\ud83c\udfaf \u5feb\u901f\u5f00\u59cb","text":"<ul> <li>\u5165\u95e8\u6307\u5357 - \u5b89\u88c5\u3001\u57fa\u672c\u8bbe\u7f6e\u548c\u9996\u6b21\u67e5\u8be2</li> <li>\u793a\u4f8b - \u5e38\u89c1\u7528\u4f8b\u7684\u5b8c\u6574\u53ef\u8fd0\u884c\u793a\u4f8b</li> </ul> <p>\ud83d\udca1 \u65b0\u7528\u6237\u8def\u5f84\uff1a\u5165\u95e8\u6307\u5357 \u2192 \u793a\u4f8b \u2192 \u67e5\u8be2 API \u2192 \u6d41\u5f0f API</p>"},{"location":"zh/#api","title":"\ud83d\udcd6 API \u53c2\u8003","text":"<ul> <li>\u67e5\u8be2 API - \u4e00\u6b21\u6027\u6570\u636e\u83b7\u53d6\u7684\u6240\u6709\u67e5\u8be2\u65b9\u6cd5\u7efc\u5408\u6307\u5357</li> <li>\u6d41\u5f0f API - \u6301\u7eed\u66f4\u65b0\u7684\u5b9e\u65f6\u8ba2\u9605\u65b9\u6cd5</li> <li>\u6570\u636e\u6a21\u578b - \u6240\u6709\u6570\u636e\u7ed3\u6784\u548c\u7c7b\u578b\u7684\u5b8c\u6574\u53c2\u8003</li> <li>\u8fc7\u6ee4\u5668 - \u9ad8\u7ea7\u8fc7\u6ee4\u3001\u901f\u7387\u9650\u5236\u548c\u6027\u80fd\u4f18\u5316</li> </ul> <p>\u26a0\ufe0f \u91cd\u8981\uff1a\u5904\u7406 API \u54cd\u5e94\u65f6\u8bf7\u52a1\u5fc5\u67e5\u770b\u6570\u636e\u6a21\u578b\u53c2\u8003\u3002</p>"},{"location":"zh/#_4","title":"\u26a1 \u5feb\u901f\u5f00\u59cb","text":""},{"location":"zh/#_5","title":"\u5b89\u88c5","text":"<p>\u4f7f\u7528 uv\uff08\u63a8\u8350\uff09\uff1a</p> <pre><code>uv add dexscreen\n</code></pre> <p>\u4f7f\u7528 pip\uff1a</p> <pre><code>pip install dexscreen\n</code></pre>"},{"location":"zh/#_6","title":"\u57fa\u672c\u4f7f\u7528\u793a\u4f8b","text":"<p>\ud83d\udcca \u83b7\u53d6\u4ee3\u5e01\u4ef7\u683c\uff1a</p> <pre><code>from dexscreen import DexscreenerClient\n\nclient = DexscreenerClient()\n\n# \u83b7\u53d6\u4ee5\u592a\u574a\u4e0a\u7684\u6240\u6709 USDC \u4ea4\u6613\u5bf9\npairs = client.get_pairs_by_token_address(\n    \"ethereum\",\n    \"0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\"  # USDC\n)\n\nif pairs:\n    # \u627e\u5230\u6d41\u52a8\u6027\u6700\u9ad8\u7684\u4ea4\u6613\u5bf9\n    best_pair = max(pairs, key=lambda p: p.liquidity.usd if p.liquidity else 0)\n    print(f\"USDC \u4ef7\u683c: ${best_pair.price_usd:.4f}\")\n    print(f\"24\u5c0f\u65f6\u4ea4\u6613\u91cf: ${best_pair.volume.h24:,.0f}\")\n</code></pre> <p>\ud83d\udd04 \u5b9e\u65f6\u76d1\u63a7\uff1a</p> <pre><code>import asyncio\nfrom dexscreen import DexscreenerClient, FilterPresets\n\nasync def price_alert(pair):\n    print(f\"{pair.base_token.symbol}: ${pair.price_usd:.4f}\")\n\nasync def main():\n    client = DexscreenerClient()\n\n    # \u76d1\u63a7 USDC/WETH \u4ea4\u6613\u5bf9\uff0c\u4ef7\u683c\u53d8\u5316 &gt; 0.1%\n    await client.subscribe_pairs(\n        chain_id=\"ethereum\",\n        pair_addresses=[\"0x88e6a0c2ddd26feeb64f039a2c41296fcb3f5640\"],\n        callback=price_alert,\n        filter=FilterPresets.significant_price_changes(0.001)  # 0.1%\n    )\n\n    await asyncio.sleep(60)  # \u76d1\u63a7 1 \u5206\u949f\n    await client.close_streams()\n\nasyncio.run(main())\n</code></pre> <p>\ud83d\udcd6 \u4e86\u89e3\u66f4\u591a\uff1a\u67e5\u770b\u793a\u4f8b\u83b7\u53d6\u5b8c\u6574\u7684\u751f\u4ea7\u5c31\u7eea\u4ee3\u7801\u793a\u4f8b\u3002</p> <p>\ud83d\udd0d \u9700\u8981\u5e2e\u52a9\uff1f\uff1a\u67e5\u770b\u4e0b\u65b9\u7684\u7591\u96be\u89e3\u7b54\u90e8\u5206\u6216\u6d4f\u89c8\u793a\u4f8b\u4e86\u89e3\u5e38\u89c1\u6a21\u5f0f\u3002</p>"},{"location":"zh/#api_1","title":"\ud83d\udcca API \u5feb\u901f\u53c2\u8003","text":""},{"location":"zh/#_7","title":"\ud83d\udd0d \u67e5\u8be2\u65b9\u6cd5\uff08\u5b8c\u6574\u53c2\u8003\uff09","text":"\u65b9\u6cd5 \u63cf\u8ff0 \u901f\u7387\u9650\u5236 \u4f7f\u7528\u573a\u666f <code>get_pair(address)</code> \u6309\u5730\u5740\u83b7\u53d6\u4ea4\u6613\u5bf9\uff08\u4efb\u610f\u94fe\uff09 300/\u5206\u949f \u5feb\u901f\u4ef7\u683c\u68c0\u67e5 <code>get_pair_by_pair_address(chain_id, pair_address)</code> \u83b7\u53d6\u7279\u5b9a\u94fe\u4e0a\u7684\u7279\u5b9a\u4ea4\u6613\u5bf9 300/\u5206\u949f \u8be6\u7ec6\u4ea4\u6613\u5bf9\u4fe1\u606f <code>get_pairs_by_token_address(chain_id, token_address)</code> \u83b7\u53d6\u4ee3\u5e01\u7684\u6240\u6709\u4ea4\u6613\u5bf9 300/\u5206\u949f \u4ee3\u5e01\u5206\u6790 <code>search_pairs(query)</code> \u6309\u540d\u79f0/\u7b26\u53f7/\u5730\u5740\u641c\u7d22\u4ea4\u6613\u5bf9 300/\u5206\u949f \u4ee3\u5e01\u53d1\u73b0 <code>get_latest_token_profiles()</code> \u6700\u65b0\u4ee3\u5e01\u6863\u6848 60/\u5206\u949f \u65b0\u4ee3\u5e01\u8ddf\u8e2a <code>get_latest_boosted_tokens()</code> \u6700\u65b0\u63a8\u5e7f\u4ee3\u5e01 60/\u5206\u949f \u63a8\u5e7f\u4ee3\u5e01"},{"location":"zh/#_8","title":"\ud83d\udce1 \u6d41\u5f0f\u65b9\u6cd5\uff08\u5b8c\u6574\u53c2\u8003\uff09","text":"\u65b9\u6cd5 \u63cf\u8ff0 \u6700\u9002\u7528\u4e8e <code>subscribe_pairs(chain_id, pair_addresses, callback)</code> \u76d1\u63a7\u7279\u5b9a\u4ea4\u6613\u5bf9 \u4ef7\u683c\u8b66\u62a5\u3001\u4ea4\u6613 <code>subscribe_tokens(chain_id, token_addresses, callback)</code> \u76d1\u63a7\u4ee3\u5e01\u7684\u6240\u6709\u4ea4\u6613\u5bf9 \u4ee3\u5e01\u76d1\u63a7 <code>unsubscribe_pairs(chain_id, pair_addresses)</code> \u505c\u6b62\u76d1\u63a7\u4ea4\u6613\u5bf9 \u52a8\u6001\u7ba1\u7406 <code>unsubscribe_tokens(chain_id, token_addresses)</code> \u505c\u6b62\u76d1\u63a7\u4ee3\u5e01 \u52a8\u6001\u7ba1\u7406 <code>get_active_subscriptions()</code> \u5217\u51fa\u6d3b\u52a8\u8ba2\u9605 \u8c03\u8bd5\u3001\u76d1\u63a7 <code>close_streams()</code> \u6e05\u7406\u6240\u6709\u8fde\u63a5 \u6e05\u7406\u3001\u5173\u95ed <p>\u26a0\ufe0f \u901f\u7387\u9650\u5236\uff1aSDK \u81ea\u52a8\u5904\u7406\u901f\u7387\u9650\u5236\uff0c\u5e76\u914d\u5907\u667a\u80fd\u91cd\u8bd5\u903b\u8f91\u3002</p>"},{"location":"zh/#_9","title":"\ud83d\udd11 \u6838\u5fc3\u529f\u80fd","text":""},{"location":"zh/#_10","title":"\u2728 \u6838\u5fc3\u529f\u80fd","text":"<ul> <li>\ud83c\udf10 \u5b8c\u6574 API \u8986\u76d6 - \u6240\u6709 Dexscreener \u7aef\u70b9\uff0c\u529f\u80fd\u5b8c\u5168\u5bf9\u7b49</li> <li>\u26a1 \u5b9e\u65f6\u66f4\u65b0 - \u57fa\u4e8e HTTP \u7684\u6d41\u5f0f\u4f20\u8f93\uff0c\u53ef\u914d\u7f6e\u8f6e\u8be2\u95f4\u9694</li> <li>\ud83c\udfaf \u667a\u80fd\u8fc7\u6ee4 - \u5e26\u81ea\u5b9a\u4e49\u9608\u503c\u7684\u5ba2\u6237\u7aef\u8fc7\u6ee4\uff0c\u51cf\u5c11\u566a\u97f3</li> <li>\ud83d\udd17 \u591a\u94fe\u652f\u6301 - \u4f7f\u7528\u72ec\u7acb\u914d\u7f6e\u540c\u65f6\u76d1\u63a7\u591a\u4e2a\u533a\u5757\u94fe</li> </ul>"},{"location":"zh/#_11","title":"\ud83d\udee1\ufe0f \u53ef\u9760\u6027\u4e0e\u6027\u80fd","text":"<ul> <li>\ud83d\udea6 \u81ea\u52a8\u901f\u7387\u9650\u5236 - \u667a\u80fd\u91cd\u8bd5\u903b\u8f91\u4e0e\u6307\u6570\u9000\u907f</li> <li>\ud83d\udd75\ufe0f \u6d4f\u89c8\u5668\u6a21\u62df - \u4f7f\u7528 curl_cffi \u7684\u9ad8\u7ea7\u53cd\u673a\u5668\u4eba\u7ed5\u8fc7</li> <li>\ud83d\udd12 \u7c7b\u578b\u5b89\u5168 - \u5b8c\u6574\u7684 Pydantic \u6a21\u578b\u9a8c\u8bc1\u4e0e\u7efc\u5408\u9519\u8bef\u5904\u7406</li> <li>\ud83d\udcca \u6279\u91cf\u64cd\u4f5c - \u591a\u67e5\u8be2\u7684\u9ad8\u6548\u6279\u91cf\u5904\u7406</li> </ul>"},{"location":"zh/#_12","title":"\ud83c\udfa8 \u5f00\u53d1\u8005\u4f53\u9a8c","text":"<ul> <li>\ud83d\udc0d \u5f02\u6b65/\u540c\u6b65\u652f\u6301 - \u540c\u65f6\u63d0\u4f9b\u540c\u6b65\u548c\u5f02\u6b65 API</li> <li>\ud83d\udcdd \u4e30\u5bcc\u6587\u6863 - \u5e26\u5b9e\u9645\u793a\u4f8b\u7684\u7efc\u5408\u6307\u5357</li> <li>\ud83d\udd27 \u7075\u6d3b\u914d\u7f6e - \u53ef\u81ea\u5b9a\u4e49\u8fc7\u6ee4\u5668\u3001\u95f4\u9694\u548c\u56de\u8c03</li> <li>\ud83d\udc1b \u8c03\u8bd5\u53cb\u597d - \u8be6\u7ec6\u65e5\u5fd7\u548c\u9519\u8bef\u6d88\u606f</li> </ul>"},{"location":"zh/#_13","title":"\ud83d\udee0\ufe0f \u5e38\u89c1\u7528\u4f8b","text":""},{"location":"zh/#defi","title":"\ud83d\udcb0 \u4ea4\u6613\u4e0e DeFi","text":"<p>\ud83d\udcc8 \u4ef7\u683c\u76d1\u63a7 - \u5b8c\u6574\u793a\u4f8b</p> <pre><code># \u8ddf\u8e2a\u663e\u8457\u4ef7\u683c\u53d8\u52a8\uff081% \u9608\u503c\uff09\nawait client.subscribe_pairs(\n    chain_id=\"ethereum\",\n    pair_addresses=[\"0x88e6a0c2ddd26feeb64f039a2c41296fcb3f5640\"],\n    callback=price_alert,\n    filter=FilterPresets.significant_price_changes(0.01)\n)\n</code></pre> <p>\ud83d\udd04 \u5957\u5229\u68c0\u6d4b - \u5b8c\u6574\u793a\u4f8b</p> <pre><code># \u76d1\u63a7\u591a\u6761\u94fe\u4e0a\u7684 USDC \u4ef7\u683c\u5dee\u5f02\nchains = [\"ethereum\", \"polygon\", \"arbitrum\"]\nfor chain in chains:\n    await client.subscribe_pairs(chain, usdc_pairs[chain], arbitrage_callback)\n</code></pre>"},{"location":"zh/#_14","title":"\ud83d\udcca \u5206\u6790\u4e0e\u7814\u7a76","text":"<p>\ud83d\udd0d \u65b0\u4ee3\u5e01\u53d1\u73b0 - \u5b8c\u6574\u793a\u4f8b</p> <pre><code># \u76d1\u63a7\u4ee3\u5e01\u7684\u6240\u6709\u4ea4\u6613\u5bf9\u4ee5\u53d1\u73b0\u65b0\u7684 DEX \u4e0a\u5e02\nawait client.subscribe_tokens(\n    chain_id=\"solana\",\n    token_addresses=[\"JUPyiwrYJFskUPiHa7hkeR8VUtAeFoSYbKedZNsDvCN\"],\n    callback=new_pair_callback\n)\n</code></pre> <p>\ud83d\udcc8 \u6295\u8d44\u7ec4\u5408\u8ddf\u8e2a - \u5b8c\u6574\u793a\u4f8b</p> <pre><code># \u4f7f\u7528\u6bcf\u6761\u94fe\u7684\u81ea\u5b9a\u4e49\u8fc7\u6ee4\u5668\u8ddf\u8e2a\u591a\u4e2a\u8d44\u4ea7\nfor chain_id, config in portfolio_config.items():\n    await client.subscribe_pairs(\n        chain_id=chain_id,\n        pair_addresses=config['pairs'],\n        callback=portfolio_callback,\n        filter=config['filter']\n    )\n</code></pre>"},{"location":"zh/#_15","title":"\ud83d\udea8 \u76d1\u63a7\u4e0e\u8b66\u62a5","text":"<p>\u26a0\ufe0f \u4ea4\u6613\u91cf\u6fc0\u589e\u68c0\u6d4b - \u5b8c\u6574\u793a\u4f8b</p> <pre><code># \u68c0\u6d4b\u5f02\u5e38\u4ea4\u6613\u6d3b\u52a8\nvolume_config = FilterConfig(\n    change_fields=[\"volume.m5\", \"volume.h1\"],\n    volume_change_threshold=0.50  # 50% \u4ea4\u6613\u91cf\u589e\u957f\n)\n</code></pre> <p>\ud83d\udca7 \u6d41\u52a8\u6027\u76d1\u63a7 - \u5b8c\u6574\u793a\u4f8b</p> <pre><code># \u8ddf\u8e2a\u6d41\u52a8\u6027\u6dfb\u52a0/\u79fb\u9664\nliquidity_config = FilterConfig(\n    change_fields=[\"liquidity.usd\"],\n    liquidity_change_threshold=0.10  # 10% \u6d41\u52a8\u6027\u53d8\u5316\n)\n</code></pre> <p>\ud83d\udd17 \u66f4\u591a\u793a\u4f8b\uff1a\u8bbf\u95ee\u793a\u4f8b\u9875\u9762\u83b7\u53d6\u5b8c\u6574\u7684\u751f\u4ea7\u5c31\u7eea\u5b9e\u73b0\u3002</p> <p>\ud83d\udcca \u6027\u80fd\u63d0\u793a\uff1a\u67e5\u770b\u6211\u4eec\u7684\u6027\u80fd\u4f18\u5316\u90e8\u5206\u548c\u8fc7\u6ee4\u6307\u5357\u4e86\u89e3\u6700\u4f73\u5b9e\u8df5\u3002</p>"},{"location":"zh/#_16","title":"\u6700\u4f73\u5b9e\u8df5","text":""},{"location":"zh/#_17","title":"\u26a1 \u6027\u80fd\u4f18\u5316","text":"<ol> <li>\ud83c\udfaf \u4f7f\u7528\u9002\u5f53\u7684\u95f4\u9694</li> </ol> <pre><code># \u9ad8\u9891\u4ea4\u6613\uff1a0.2\u79d2\ninterval=0.2\n\n# \u6295\u8d44\u7ec4\u5408\u76d1\u63a7\uff1a5-10\u79d2\ninterval=5.0\n\n# \u957f\u671f\u8b66\u62a5\uff1a30-60\u79d2\ninterval=30.0\n</code></pre> <ol> <li>\ud83d\udd0d \u5e94\u7528\u667a\u80fd\u8fc7\u6ee4 - \u4e86\u89e3\u66f4\u591a</li> </ol> <pre><code># \u4ec5\u663e\u8457\u53d8\u5316\nfilter=FilterPresets.significant_price_changes(0.01)\n\n# \u901f\u7387\u9650\u5236\u66f4\u65b0\nfilter=FilterPresets.rate_limited(1.0)  # \u6bcf\u79d2\u6700\u591a 1 \u6b21\n</code></pre>"},{"location":"zh/#_18","title":"\ud83d\udee1\ufe0f \u9519\u8bef\u5904\u7406\u4e0e\u8d44\u6e90\u7ba1\u7406","text":"<ol> <li>\ud83d\udea8 \u4f18\u96c5\u5904\u7406\u9519\u8bef</li> </ol> <pre><code>async def safe_callback(pair):\n    try:\n        await process_update(pair)\n    except Exception as e:\n        logger.error(f\"\u56de\u8c03\u9519\u8bef: {e}\")\n        # \u4e0d\u8981\u8ba9\u9519\u8bef\u5bfc\u81f4\u8ba2\u9605\u5d29\u6e83\n</code></pre> <ol> <li>\ud83e\uddf9 \u6e05\u7406\u8d44\u6e90</li> </ol> <pre><code>try:\n    await client.subscribe_pairs(...)\n    await asyncio.sleep(300)  # \u8fd0\u884c 5 \u5206\u949f\nfinally:\n    await client.close_streams()  # \u59cb\u7ec8\u6e05\u7406\n</code></pre>"},{"location":"zh/#_19","title":"\u68c0\u67e5\u6d3b\u52a8\u8ba2\u9605","text":"<pre><code>active = client.get_active_subscriptions()\nprint(f\"\u6d3b\u52a8\u8ba2\u9605\u6570: {len(active)}\")\n</code></pre>"},{"location":"zh/#_20","title":"\ud83c\udfaf \u5f00\u53d1\u6307\u5357","text":"<ul> <li>\u901f\u7387\u9650\u5236\uff1aSDK \u81ea\u52a8\u5904\u7406\uff0c\u4f46\u8981\u76d1\u63a7\u60a8\u7684\u4f7f\u7528\u60c5\u51b5</li> <li>\u7c7b\u578b\u5b89\u5168\uff1a\u4f7f\u7528\u7c7b\u578b\u63d0\u793a\u83b7\u5f97\u66f4\u597d\u7684 IDE \u652f\u6301</li> <li>\u6d4b\u8bd5\uff1a\u5f00\u53d1\u671f\u95f4\u4f7f\u7528\u5c0f\u95f4\u9694\u548c\u77ed\u6301\u7eed\u65f6\u95f4</li> <li>\u65e5\u5fd7\u8bb0\u5f55\uff1a\u542f\u7528\u8c03\u8bd5\u65e5\u5fd7\u4ee5\u8fdb\u884c\u6545\u969c\u6392\u9664</li> </ul> <p>\ud83d\udcd6 \u6df1\u5165\u4e86\u89e3\uff1a\u9605\u8bfb\u5165\u95e8\u6307\u5357\u83b7\u53d6\u8be6\u7ec6\u7684\u8bbe\u7f6e\u8bf4\u660e\u3002</p>"},{"location":"zh/#_21","title":"\ud83d\udd17 \u5916\u90e8\u8d44\u6e90","text":""},{"location":"zh/#_22","title":"\ud83d\udcda \u6587\u6863\u4e0e\u4ee3\u7801","text":"<ul> <li>\ud83d\udcd6 \u5b8c\u6574 API \u6587\u6863 - \u8be6\u7ec6\u7684\u65b9\u6cd5\u53c2\u8003</li> <li>\ud83c\udfaf \u5165\u95e8\u6559\u7a0b - \u5206\u6b65\u8bbe\u7f6e\u6307\u5357</li> <li>\ud83d\udca1 \u5b9e\u7528\u793a\u4f8b - \u751f\u4ea7\u5c31\u7eea\u4ee3\u7801\u793a\u4f8b</li> <li>GitHub \u4ed3\u5e93 - \u6e90\u4ee3\u7801\u548c\u95ee\u9898\u53cd\u9988</li> </ul>"},{"location":"zh/#_23","title":"\ud83c\udf10 \u76f8\u5173\u670d\u52a1","text":"<ul> <li>Dexscreener.com - \u5b98\u65b9 Dexscreener \u5e73\u53f0</li> <li>Dexscreener API \u6587\u6863 - \u4e0a\u6e38 API \u6587\u6863</li> <li>PyPI \u5305 - \u5b98\u65b9\u5305\u4ed3\u5e93</li> </ul>"},{"location":"zh/#_24","title":"\u9700\u8981\u5e2e\u52a9\uff1f","text":"\u95ee\u9898\u7c7b\u578b \u8d44\u6e90 \u5feb\u901f\u5f00\u59cb \u5165\u95e8\u6307\u5357 API \u95ee\u9898 \u67e5\u8be2 API \u6216 \u6d41\u5f0f API \u4ee3\u7801\u793a\u4f8b \u793a\u4f8b\u9875\u9762 \u9519\u8bef\u62a5\u544a GitHub Issues \u529f\u80fd\u8bf7\u6c42 GitHub Discussions"},{"location":"zh/#_25","title":"\ud83d\udcc4 \u8bb8\u53ef\u8bc1","text":"<p>MIT \u8bb8\u53ef\u8bc1 - \u67e5\u770b LICENSE \u6587\u4ef6\u4e86\u89e3\u5b8c\u6574\u6761\u6b3e\u548c\u6761\u4ef6\u3002</p> <p>\ud83d\ude4f \u8d21\u732e\uff1a\u6211\u4eec\u6b22\u8fce\u8d21\u732e\uff01\u8bf7\u9605\u8bfb GitHub \u4ed3\u5e93\u4e2d\u7684\u8d21\u732e\u6307\u5357\u3002</p>"},{"location":"zh/examples/","title":"\u5b8c\u6574\u793a\u4f8b","text":"<p>\u672c\u9875\u5305\u542b Dexscreen \u5e38\u89c1\u7528\u4f8b\u7684\u5b8c\u6574\u5de5\u4f5c\u793a\u4f8b\u3002</p>"},{"location":"zh/examples/#_2","title":"\u57fa\u672c\u7528\u6cd5","text":""},{"location":"zh/examples/#_3","title":"\u7b80\u5355\u4ef7\u683c\u68c0\u67e5","text":"<pre><code>from dexscreen import DexscreenerClient\n\ndef check_token_price():\n    client = DexscreenerClient()\n\n    # \u83b7\u53d6\u4ee3\u5e01\u7684\u4ea4\u6613\u5bf9\n    pairs = client.get_pairs_by_token_address(\n        \"ethereum\",\n        \"A0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\"  # USDC\n    )\n\n    if pairs:\n        # \u627e\u5230\u6d41\u52a8\u6027\u6700\u9ad8\u7684\u4ea4\u6613\u5bf9\n        best_pair = max(pairs, key=lambda p: p.liquidity.usd if p.liquidity else 0)\n        print(f\"\u6d41\u52a8\u6027\u6700\u9ad8\u7684 USDC \u4ea4\u6613\u5bf9: {best_pair.base_token.symbol}/{best_pair.quote_token.symbol}\")\n        print(f\"DEX: {best_pair.dex_id}\")\n        print(f\"\u4ef7\u683c: ${best_pair.price_usd:,.4f}\")\n        print(f\"\u6d41\u52a8\u6027: ${best_pair.liquidity.usd:,.0f}\")\n\nif __name__ == \"__main__\":\n    check_token_price()\n</code></pre>"},{"location":"zh/examples/#_4","title":"\u641c\u7d22\u548c\u5206\u6790","text":"<pre><code>import asyncio\nfrom dexscreen import DexscreenerClient\n\nasync def analyze_search_results():\n    client = DexscreenerClient()\n\n    # \u641c\u7d22 PEPE \u4ee3\u5e01\n    results = await client.search_pairs_async(\"PEPE\")\n\n    # \u6309\u6d41\u52a8\u6027\u8fc7\u6ee4\u548c\u6392\u5e8f\n    liquid_pairs = [p for p in results if p.liquidity and p.liquidity.usd &gt; 50_000]\n    liquid_pairs.sort(key=lambda p: p.liquidity.usd, reverse=True)\n\n    print(f\"\u627e\u5230 {len(liquid_pairs)} \u4e2a\u6d41\u52a8\u6027\u5145\u8db3\u7684 PEPE \u4ea4\u6613\u5bf9\\n\")\n\n    for pair in liquid_pairs[:5]:\n        print(f\"{pair.chain_id} - {pair.dex_id}\")\n        print(f\"  \u4ea4\u6613\u5bf9: {pair.base_token.symbol}/{pair.quote_token.symbol}\")\n        print(f\"  \u4ef7\u683c: ${pair.price_usd:,.8f}\")\n        print(f\"  24\u5c0f\u65f6\u4ea4\u6613\u91cf: ${pair.volume.h24:,.0f}\")\n        print(f\"  \u6d41\u52a8\u6027: ${pair.liquidity.usd:,.0f}\")\n        print(f\"  24\u5c0f\u65f6\u53d8\u5316: {pair.price_change.h24:+.2f}%\")\n        print()\n\nif __name__ == \"__main__\":\n    asyncio.run(analyze_search_results())\n</code></pre>"},{"location":"zh/examples/#_5","title":"\u4ef7\u683c\u76d1\u63a7","text":""},{"location":"zh/examples/#_6","title":"\u5b9e\u65f6\u4ef7\u683c\u8ddf\u8e2a\u5668","text":"<pre><code>import asyncio\nfrom datetime import datetime\nfrom dexscreen import DexscreenerClient, FilterPresets\n\nclass PriceTracker:\n    def __init__(self):\n        self.client = DexscreenerClient()\n        self.price_history = []\n        self.alert_threshold = 0.05  # 5% \u53d8\u5316\n\n    def handle_price_update(self, pair):\n        \"\"\"\u5904\u7406\u4ef7\u683c\u66f4\u65b0\"\"\"\n        timestamp = datetime.now()\n        self.price_history.append({\n            'time': timestamp,\n            'price': pair.price_usd,\n            'volume': pair.volume.h24\n        })\n\n        # \u4fdd\u7559\u6700\u540e 100 \u6761\u8bb0\u5f55\n        if len(self.price_history) &gt; 100:\n            self.price_history.pop(0)\n\n        # \u68c0\u67e5\u663e\u8457\u53d8\u52a8\n        if len(self.price_history) &gt;= 2:\n            prev_price = self.price_history[-2]['price']\n            current_price = pair.price_usd\n            change = (current_price - prev_price) / prev_price\n\n            if abs(change) &gt;= self.alert_threshold:\n                self.send_alert(pair, change)\n\n        # \u663e\u793a\u5f53\u524d\u72b6\u6001\n        print(f\"[{timestamp.strftime('%H:%M:%S')}] \"\n              f\"{pair.base_token.symbol}: ${pair.price_usd:,.4f} \"\n              f\"(24\u5c0f\u65f6: {pair.price_change.h24:+.2f}%)\")\n\n    def send_alert(self, pair, change):\n        \"\"\"\u53d1\u9001\u4ef7\u683c\u8b66\u62a5\"\"\"\n        direction = \"\ud83d\udcc8\" if change &gt; 0 else \"\ud83d\udcc9\"\n        print(f\"\\n{direction} \u8b66\u62a5: {pair.base_token.symbol} \u53d8\u52a8 {change:.2%}!\\n\")\n\n    async def start_monitoring(self, chain_id, pair_address):\n        \"\"\"\u5f00\u59cb\u76d1\u63a7\u4ea4\u6613\u5bf9\"\"\"\n        print(f\"\u5f00\u59cb\u76d1\u63a7 {chain_id} \u4e0a\u7684 {pair_address}\")\n\n        await self.client.subscribe_pairs(\n            chain_id=chain_id,\n            pair_addresses=[pair_address],\n            callback=self.handle_price_update,\n            filter=FilterPresets.significant_price_changes(0.001),  # 0.1% \u53d8\u5316\n            interval=0.5  # \u6bcf 0.5 \u79d2\u68c0\u67e5\n        )\n\n        # \u8fd0\u884c 5 \u5206\u949f\n        await asyncio.sleep(300)\n        await self.client.close_streams()\n\n        # \u663e\u793a\u6458\u8981\n        if self.price_history:\n            prices = [h['price'] for h in self.price_history]\n            print(f\"\\n\u4f1a\u8bdd\u6458\u8981:\")\n            print(f\"  \u8d77\u59cb\u4ef7\u683c: ${prices[0]:,.4f}\")\n            print(f\"  \u7ed3\u675f\u4ef7\u683c: ${prices[-1]:,.4f}\")\n            print(f\"  \u6700\u4f4e\u4ef7\u683c: ${min(prices):,.4f}\")\n            print(f\"  \u6700\u9ad8\u4ef7\u683c: ${max(prices):,.4f}\")\n            print(f\"  \u4ef7\u683c\u66f4\u65b0\u6b21\u6570: {len(prices)}\")\n\nasync def main():\n    tracker = PriceTracker()\n    await tracker.start_monitoring(\n        \"ethereum\",\n        \"0x88e6a0c2ddd26feeb64f039a2c41296fcb3f5640\"  # USDC/WETH\n    )\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"zh/examples/#_7","title":"\u5957\u5229\u68c0\u6d4b","text":""},{"location":"zh/examples/#_8","title":"\u8de8\u94fe\u5957\u5229\u626b\u63cf\u5668","text":"<pre><code>import asyncio\nfrom collections import defaultdict\nfrom dexscreen import DexscreenerClient\n\nclass ArbitrageScanner:\n    def __init__(self, spread_threshold=0.01):  # 1% \u6700\u5c0f\u4ef7\u5dee\n        self.client = DexscreenerClient()\n        self.spread_threshold = spread_threshold\n        self.prices_by_chain = defaultdict(dict)\n        self.opportunities = []\n\n    async def scan_token(self, token_symbol, token_addresses):\n        \"\"\"\u626b\u63cf\u4ee3\u5e01\u7684\u5957\u5229\u673a\u4f1a\"\"\"\n        print(f\"\u626b\u63cf {token_symbol} \u7684\u5957\u5229\u673a\u4f1a...\\n\")\n\n        # \u5e76\u53d1\u83b7\u53d6\u6240\u6709\u94fe\u7684\u4ea4\u6613\u5bf9\n        tasks = []\n        for chain_id, token_address in token_addresses.items():\n            task = self.client.get_pairs_by_token_address_async(chain_id, token_address)\n            tasks.append((chain_id, task))\n\n        # \u5904\u7406\u7ed3\u679c\n        for chain_id, task in tasks:\n            try:\n                pairs = await task\n                if pairs:\n                    # \u83b7\u53d6\u6d41\u52a8\u6027\u6700\u9ad8\u7684\u4ea4\u6613\u5bf9\n                    best_pair = max(pairs, key=lambda p: p.liquidity.usd if p.liquidity else 0)\n\n                    if best_pair.price_usd:\n                        self.prices_by_chain[token_symbol][chain_id] = {\n                            'price': best_pair.price_usd,\n                            'pair': best_pair,\n                            'liquidity': best_pair.liquidity.usd if best_pair.liquidity else 0\n                        }\n            except Exception as e:\n                print(f\"\u83b7\u53d6 {chain_id} \u65f6\u51fa\u9519: {e}\")\n\n        # \u5bfb\u627e\u5957\u5229\u673a\u4f1a\n        self.find_opportunities(token_symbol)\n\n    def find_opportunities(self, token_symbol):\n        \"\"\"\u5bfb\u627e\u4ee3\u5e01\u7684\u5957\u5229\u673a\u4f1a\"\"\"\n        prices = self.prices_by_chain[token_symbol]\n\n        if len(prices) &lt; 2:\n            print(f\"{token_symbol} \u9700\u8981\u81f3\u5c11 2 \u6761\u94fe\u7684\u4ef7\u683c\")\n            return\n\n        # \u627e\u5230\u6700\u4f4e\u548c\u6700\u9ad8\u4ef7\u683c\n        chains = list(prices.keys())\n        for i in range(len(chains)):\n            for j in range(i + 1, len(chains)):\n                chain1, chain2 = chains[i], chains[j]\n                price1 = prices[chain1]['price']\n                price2 = prices[chain2]['price']\n\n                # \u8ba1\u7b97\u4ef7\u5dee\n                if price1 &gt; price2:\n                    buy_chain, sell_chain = chain2, chain1\n                    buy_price, sell_price = price2, price1\n                else:\n                    buy_chain, sell_chain = chain1, chain2\n                    buy_price, sell_price = price1, price2\n\n                spread = (sell_price - buy_price) / buy_price\n\n                if spread &gt;= self.spread_threshold:\n                    opportunity = {\n                        'token': token_symbol,\n                        'buy_chain': buy_chain,\n                        'sell_chain': sell_chain,\n                        'buy_price': buy_price,\n                        'sell_price': sell_price,\n                        'spread': spread,\n                        'buy_liquidity': prices[buy_chain]['liquidity'],\n                        'sell_liquidity': prices[sell_chain]['liquidity']\n                    }\n                    self.opportunities.append(opportunity)\n                    self.print_opportunity(opportunity)\n\n    def print_opportunity(self, opp):\n        \"\"\"\u6253\u5370\u5957\u5229\u673a\u4f1a\"\"\"\n        print(f\"\ud83c\udfaf \u5957\u5229\u673a\u4f1a: {opp['token']}\")\n        print(f\"  \u5728 {opp['buy_chain']} \u4e70\u5165: ${opp['buy_price']:,.6f}\")\n        print(f\"  \u5728 {opp['sell_chain']} \u5356\u51fa: ${opp['sell_price']:,.6f}\")\n        print(f\"  \u4ef7\u5dee: {opp['spread']:.2%}\")\n        print(f\"  \u4e70\u5165\u6d41\u52a8\u6027: ${opp['buy_liquidity']:,.0f}\")\n        print(f\"  \u5356\u51fa\u6d41\u52a8\u6027: ${opp['sell_liquidity']:,.0f}\")\n        print()\n\nasync def main():\n    scanner = ArbitrageScanner(spread_threshold=0.005)  # 0.5% \u6700\u5c0f\u503c\n\n    # \u5b9a\u4e49\u8981\u626b\u63cf\u7684\u4ee3\u5e01\uff08\u7b26\u53f7 -&gt; \u94fe -&gt; \u5730\u5740\uff09\n    tokens_to_scan = {\n        \"USDC\": {\n            \"ethereum\": \"A0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\",\n            \"polygon\": \"2791Bca1f2de4661ED88A30C99A7a9449Aa84174\",\n            \"arbitrum\": \"FF970A61A04b1cA14834A43f5dE4533eBDDB5CC8\",\n            \"optimism\": \"7F5c764cBc14f9669B88837ca1490cCa17c31607\"\n        },\n        \"WETH\": {\n            \"ethereum\": \"C02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\",\n            \"polygon\": \"7ceB23fD6bC0adD59E62ac25578270cFf1b9f619\",\n            \"arbitrum\": \"82aF49447D8a07e3bd95BD0d56f35241523fBab1\",\n            \"optimism\": \"4200000000000000000000000000000000000006\"\n        }\n    }\n\n    # \u626b\u63cf\u6bcf\u4e2a\u4ee3\u5e01\n    for token_symbol, addresses in tokens_to_scan.items():\n        await scanner.scan_token(token_symbol, addresses)\n        await asyncio.sleep(1)  # \u901f\u7387\u9650\u5236\n\n    # \u6458\u8981\n    print(f\"\\n\u627e\u5230 {len(scanner.opportunities)} \u4e2a\u5957\u5229\u673a\u4f1a\")\n    if scanner.opportunities:\n        best = max(scanner.opportunities, key=lambda x: x['spread'])\n        print(f\"\u6700\u4f73\u673a\u4f1a: {best['token']} \u6709 {best['spread']:.2%} \u4ef7\u5dee\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"zh/examples/#_9","title":"\u6295\u8d44\u7ec4\u5408\u8ddf\u8e2a","text":""},{"location":"zh/examples/#_10","title":"\u591a\u8d44\u4ea7\u6295\u8d44\u7ec4\u5408\u76d1\u63a7\u5668","text":"<pre><code>import asyncio\nfrom datetime import datetime\nfrom typing import Dict, List\nfrom dexscreen import DexscreenerClient, FilterPresets\n\nclass PortfolioMonitor:\n    def __init__(self):\n        self.client = DexscreenerClient()\n        self.portfolio = {}  # \u5730\u5740 -&gt; \u6301\u4ed3\u4fe1\u606f\n        self.portfolio_value = 0\n        self.initial_value = 0\n\n    def add_position(self, chain_id: str, pair_address: str, amount: float, entry_price: float):\n        \"\"\"\u6dfb\u52a0\u6301\u4ed3\u5230\u6295\u8d44\u7ec4\u5408\"\"\"\n        self.portfolio[f\"{chain_id}:{pair_address}\"] = {\n            'chain_id': chain_id,\n            'pair_address': pair_address,\n            'amount': amount,\n            'entry_price': entry_price,\n            'current_price': entry_price,\n            'pnl': 0,\n            'pnl_percent': 0\n        }\n        self.initial_value += amount * entry_price\n\n    def handle_update(self, pair):\n        \"\"\"\u5904\u7406\u6295\u8d44\u7ec4\u5408\u6301\u4ed3\u7684\u4ef7\u683c\u66f4\u65b0\"\"\"\n        key = f\"{pair.chain_id}:{pair.pair_address}\"\n        if key in self.portfolio:\n            position = self.portfolio[key]\n            old_price = position['current_price']\n            new_price = pair.price_usd\n\n            # \u66f4\u65b0\u6301\u4ed3\n            position['current_price'] = new_price\n            position['pnl'] = (new_price - position['entry_price']) * position['amount']\n            position['pnl_percent'] = ((new_price - position['entry_price']) / position['entry_price']) * 100\n\n            # \u4ec5\u663e\u793a\u663e\u8457\u53d8\u5316\n            if abs(new_price - old_price) / old_price &gt; 0.001:  # 0.1% \u53d8\u5316\n                self.display_position_update(pair, position)\n\n    def display_position_update(self, pair, position):\n        \"\"\"\u663e\u793a\u6301\u4ed3\u66f4\u65b0\"\"\"\n        symbol = pair.base_token.symbol\n        pnl_emoji = \"\ud83d\udfe2\" if position['pnl'] &gt;= 0 else \"\ud83d\udd34\"\n\n        print(f\"[{datetime.now().strftime('%H:%M:%S')}] {symbol}: \"\n              f\"${position['current_price']:,.4f} \"\n              f\"{pnl_emoji} \u76c8\u4e8f: ${position['pnl']:+,.2f} ({position['pnl_percent']:+.2f}%)\")\n\n    def calculate_portfolio_value(self):\n        \"\"\"\u8ba1\u7b97\u6295\u8d44\u7ec4\u5408\u603b\u4ef7\u503c\"\"\"\n        total = sum(p['amount'] * p['current_price'] for p in self.portfolio.values())\n        return total\n\n    def display_portfolio_summary(self):\n        \"\"\"\u663e\u793a\u6295\u8d44\u7ec4\u5408\u6458\u8981\"\"\"\n        print(\"\\n\" + \"=\"*60)\n        print(\"\u6295\u8d44\u7ec4\u5408\u6458\u8981\")\n        print(\"=\"*60)\n\n        current_value = self.calculate_portfolio_value()\n        total_pnl = current_value - self.initial_value\n        total_pnl_percent = (total_pnl / self.initial_value) * 100 if self.initial_value &gt; 0 else 0\n\n        print(f\"\u521d\u59cb\u4ef7\u503c: ${self.initial_value:,.2f}\")\n        print(f\"\u5f53\u524d\u4ef7\u503c: ${current_value:,.2f}\")\n        print(f\"\u603b\u76c8\u4e8f: ${total_pnl:+,.2f} ({total_pnl_percent:+.2f}%)\")\n        print(\"\\n\u6301\u4ed3:\")\n\n        for key, position in self.portfolio.items():\n            value = position['amount'] * position['current_price']\n            weight = (value / current_value) * 100 if current_value &gt; 0 else 0\n            print(f\"  {key}: ${value:,.2f} ({weight:.1f}%) \"\n                  f\"\u76c8\u4e8f: ${position['pnl']:+,.2f} ({position['pnl_percent']:+.2f}%)\")\n\n        print(\"=\"*60)\n\n    async def start_monitoring(self):\n        \"\"\"\u5f00\u59cb\u76d1\u63a7\u6240\u6709\u6295\u8d44\u7ec4\u5408\u6301\u4ed3\"\"\"\n        print(\"\u5f00\u59cb\u6295\u8d44\u7ec4\u5408\u76d1\u63a7...\")\n\n        # \u8ba2\u9605\u6240\u6709\u6301\u4ed3\n        for key, position in self.portfolio.items():\n            await self.client.subscribe_pairs(\n                chain_id=position['chain_id'],\n                pair_addresses=[position['pair_address']],\n                callback=self.handle_update,\n                filter=FilterPresets.ui_friendly(),  # \u4e3a UI \u5e73\u8861\u66f4\u65b0\n                interval=1.0\n            )\n\n        # \u8fd0\u884c 5 \u5206\u949f\u5e76\u5b9a\u671f\u663e\u793a\u6458\u8981\n        for i in range(5):\n            await asyncio.sleep(60)\n            self.display_portfolio_summary()\n\n        await self.client.close_streams()\n\nasync def main():\n    monitor = PortfolioMonitor()\n\n    # \u793a\u4f8b\u6295\u8d44\u7ec4\u5408\n    monitor.add_position(\n        \"ethereum\",\n        \"0x88e6a0c2ddd26feeb64f039a2c41296fcb3f5640\",  # USDC/WETH\n        1000,  # 1000 USDC\n        0.0004  # \u5165\u573a\u4ef7\u683c\n    )\n\n    monitor.add_position(\n        \"ethereum\",\n        \"0x11b815efb8f581194ae79006d24e0d814b7697f6\",  # WETH/USDT\n        0.5,  # 0.5 WETH\n        2500  # \u5165\u573a\u4ef7\u683c\n    )\n\n    await monitor.start_monitoring()\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"zh/examples/#_11","title":"\u65b0\u4ee3\u5e01\u53d1\u73b0","text":""},{"location":"zh/examples/#_12","title":"\u4ee3\u5e01\u53d1\u5e03\u76d1\u63a7\u5668","text":"<pre><code>import asyncio\nfrom datetime import datetime, timedelta\nfrom dexscreen import DexscreenerClient\n\nclass TokenLaunchMonitor:\n    def __init__(self):\n        self.client = DexscreenerClient()\n        self.new_tokens = []\n        self.monitored_tokens = set()\n\n    async def scan_new_tokens(self):\n        \"\"\"\u626b\u63cf\u65b0\u53d1\u5e03\u7684\u4ee3\u5e01\"\"\"\n        print(\"\u626b\u63cf\u65b0\u4ee3\u5e01\u53d1\u5e03...\\n\")\n\n        # \u83b7\u53d6\u6700\u65b0\u4ee3\u5e01\u6863\u6848\n        profiles = await self.client.get_latest_token_profiles_async()\n\n        for token in profiles:\n            if token.token_address not in self.monitored_tokens:\n                # \u83b7\u53d6\u4ea4\u6613\u5bf9\u6570\u636e\n                pairs = await self.client.get_pairs_by_token_address_async(\n                    token.chain_id,\n                    token.token_address\n                )\n\n                if pairs:\n                    # \u5206\u6790\u4ee3\u5e01\n                    analysis = await self.analyze_new_token(token, pairs)\n                    if analysis['is_interesting']:\n                        self.new_tokens.append(analysis)\n                        self.print_token_alert(analysis)\n\n                self.monitored_tokens.add(token.token_address)\n                await asyncio.sleep(0.5)  # \u901f\u7387\u9650\u5236\n\n    async def analyze_new_token(self, token_info, pairs):\n        \"\"\"\u5206\u6790\u65b0\u4ee3\u5e01\u7684\u6f5c\u529b\"\"\"\n        # \u83b7\u53d6\u6d41\u52a8\u6027\u6700\u9ad8\u7684\u4ea4\u6613\u5bf9\n        best_pair = max(pairs, key=lambda p: p.liquidity.usd if p.liquidity else 0)\n\n        # \u8ba1\u7b97\u6307\u6807\n        total_liquidity = sum(p.liquidity.usd for p in pairs if p.liquidity and p.liquidity.usd)\n        total_volume = sum(p.volume.h24 for p in pairs if p.volume.h24)\n        pair_count = len(pairs)\n\n        # \u68c0\u67e5\u662f\u5426\u6700\u8fd1\u521b\u5efa\uff0824\u5c0f\u65f6\u5185\uff09\n        is_new = False\n        if best_pair.pair_created_at:\n            age = datetime.now() - best_pair.pair_created_at\n            is_new = age &lt; timedelta(days=1)\n\n        # \u5224\u65ad\u662f\u5426\u6709\u8da3\n        is_interesting = (\n            total_liquidity &gt; 50_000 and  # \u6700\u4f4e $50k \u6d41\u52a8\u6027\n            total_volume &gt; 100_000 and     # \u6700\u4f4e $100k \u4ea4\u6613\u91cf\n            pair_count &gt;= 2                # \u81f3\u5c11 2 \u4e2a\u4ea4\u6613\u5bf9\n        )\n\n        return {\n            'token_info': token_info,\n            'best_pair': best_pair,\n            'total_liquidity': total_liquidity,\n            'total_volume': total_volume,\n            'pair_count': pair_count,\n            'is_new': is_new,\n            'is_interesting': is_interesting,\n            'price': best_pair.price_usd,\n            'price_change_24h': best_pair.price_change.h24\n        }\n\n    def print_token_alert(self, analysis):\n        \"\"\"\u6253\u5370\u6709\u8da3\u4ee3\u5e01\u7684\u8b66\u62a5\"\"\"\n        token = analysis['token_info']\n\n        print(f\"\ud83d\ude80 \u65b0\u4ee3\u5e01\u8b66\u62a5: {token.token_address}\")\n        print(f\"  \u94fe: {token.chain_id}\")\n        print(f\"  \u4ef7\u683c: ${analysis['price']:,.8f}\")\n        print(f\"  24\u5c0f\u65f6\u53d8\u5316: {analysis['price_change_24h']:+.2f}%\")\n        print(f\"  \u603b\u6d41\u52a8\u6027: ${analysis['total_liquidity']:,.0f}\")\n        print(f\"  24\u5c0f\u65f6\u4ea4\u6613\u91cf: ${analysis['total_volume']:,.0f}\")\n        print(f\"  \u4ea4\u6613\u5bf9\u6570\u91cf: {analysis['pair_count']}\")\n\n        if token.description:\n            print(f\"  \u63cf\u8ff0: {token.description[:100]}...\")\n\n        print(f\"  URL: {token.url}\")\n        print()\n\n    async def monitor_launches(self, duration_minutes=30):\n        \"\"\"\u76d1\u63a7\u65b0\u53d1\u5e03\u6307\u5b9a\u65f6\u957f\"\"\"\n        start_time = datetime.now()\n        end_time = start_time + timedelta(minutes=duration_minutes)\n\n        print(f\"\u76d1\u63a7\u65b0\u4ee3\u5e01\u53d1\u5e03 {duration_minutes} \u5206\u949f...\")\n        print(f\"\u5f00\u59cb: {start_time.strftime('%Y-%m-%d %H:%M:%S')}\")\n        print(f\"\u7ed3\u675f: {end_time.strftime('%Y-%m-%d %H:%M:%S')}\\n\")\n\n        while datetime.now() &lt; end_time:\n            await self.scan_new_tokens()\n\n            # \u7b49\u5f85\u4e0b\u6b21\u626b\u63cf\n            await asyncio.sleep(60)  # \u6bcf\u5206\u949f\u626b\u63cf\n\n        # \u6700\u7ec8\u6458\u8981\n        print(f\"\\n\u76d1\u63a7\u5b8c\u6210\u3002\u627e\u5230 {len(self.new_tokens)} \u4e2a\u6709\u8da3\u7684\u4ee3\u5e01:\")\n        for token in self.new_tokens:\n            print(f\"- {token['token_info'].token_address} \u5728 {token['token_info'].chain_id}\")\n\nasync def main():\n    monitor = TokenLaunchMonitor()\n    await monitor.monitor_launches(duration_minutes=5)\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"zh/examples/#_13","title":"\u4ea4\u6613\u91cf\u5206\u6790","text":""},{"location":"zh/examples/#_14","title":"\u4ea4\u6613\u91cf\u6fc0\u589e\u68c0\u6d4b\u5668","text":"<pre><code>import asyncio\nfrom collections import defaultdict, deque\nfrom dexscreen import DexscreenerClient, FilterConfig\n\nclass VolumeSurgeDetector:\n    def __init__(self, surge_multiplier=3.0):\n        self.client = DexscreenerClient()\n        self.surge_multiplier = surge_multiplier\n        self.volume_history = defaultdict(lambda: deque(maxlen=12))  # 12 x 5\u5206\u949f = 1\u5c0f\u65f6\n        self.surge_alerts = []\n\n    def calculate_volume_surge(self, pair):\n        \"\"\"\u8ba1\u7b97\u662f\u5426\u6709\u4ea4\u6613\u91cf\u6fc0\u589e\"\"\"\n        history = self.volume_history[pair.pair_address]\n        current_volume = pair.volume.m5 or 0\n\n        # \u6dfb\u52a0\u5230\u5386\u53f2\n        history.append(current_volume)\n\n        if len(history) &lt; 6:  # \u9700\u8981\u81f3\u5c11 30 \u5206\u949f\u7684\u6570\u636e\n            return None\n\n        # \u6bd4\u8f83\u6700\u8fd1\u548c\u4e4b\u524d\u7684\u4ea4\u6613\u91cf\n        recent_avg = sum(list(history)[-3:]) / 3  # \u6700\u540e 15 \u5206\u949f\n        older_avg = sum(list(history)[-6:-3]) / 3  # \u4e4b\u524d 15 \u5206\u949f\n\n        if older_avg &gt; 0:\n            surge_ratio = recent_avg / older_avg\n            if surge_ratio &gt;= self.surge_multiplier:\n                return surge_ratio\n\n        return None\n\n    def handle_volume_update(self, pair):\n        \"\"\"\u5904\u7406\u4ea4\u6613\u91cf\u66f4\u65b0\"\"\"\n        surge = self.calculate_volume_surge(pair)\n\n        if surge:\n            alert = {\n                'timestamp': datetime.now(),\n                'pair': pair,\n                'surge_ratio': surge,\n                '5m_volume': pair.volume.m5,\n                '24h_volume': pair.volume.h24\n            }\n            self.surge_alerts.append(alert)\n            self.print_surge_alert(alert)\n\n    def print_surge_alert(self, alert):\n        \"\"\"\u6253\u5370\u4ea4\u6613\u91cf\u6fc0\u589e\u8b66\u62a5\"\"\"\n        pair = alert['pair']\n        print(f\"\\n\ud83d\udd0a \u68c0\u6d4b\u5230\u4ea4\u6613\u91cf\u6fc0\u589e \u4e8e {alert['timestamp'].strftime('%H:%M:%S')}\")\n        print(f\"  \u4ea4\u6613\u5bf9: {pair.base_token.symbol}/{pair.quote_token.symbol} \u5728 {pair.chain_id}\")\n        print(f\"  \u6fc0\u589e: {alert['surge_ratio']:.1f}x \u6b63\u5e38\u4ea4\u6613\u91cf\")\n        print(f\"  5\u5206\u949f\u4ea4\u6613\u91cf: ${alert['5m_volume']:,.0f}\")\n        print(f\"  24\u5c0f\u65f6\u4ea4\u6613\u91cf: ${alert['24h_volume']:,.0f}\")\n        print(f\"  \u5f53\u524d\u4ef7\u683c: ${pair.price_usd:,.6f}\")\n        print(f\"  1\u5c0f\u65f6\u4ef7\u683c\u53d8\u5316: {pair.price_change.h1:+.2f}%\")\n        print()\n\n    async def monitor_tokens(self, chain_id, token_addresses):\n        \"\"\"\u76d1\u63a7\u4ee3\u5e01\u7684\u4ea4\u6613\u91cf\u6fc0\u589e\"\"\"\n        print(f\"\u76d1\u63a7 {chain_id} \u4e0a {len(token_addresses)} \u4e2a\u4ee3\u5e01\u7684\u4ea4\u6613\u91cf\u6fc0\u589e...\\n\")\n\n        # \u83b7\u53d6\u6bcf\u4e2a\u4ee3\u5e01\u7684\u521d\u59cb\u4ea4\u6613\u5bf9\n        all_pairs = []\n        for token_address in token_addresses:\n            pairs = await self.client.get_pairs_by_token_address_async(chain_id, token_address)\n            # \u83b7\u53d6\u6bcf\u4e2a\u4ee3\u5e01\u6d41\u52a8\u6027\u6700\u9ad8\u7684\u524d 3 \u4e2a\u4ea4\u6613\u5bf9\n            liquid_pairs = sorted(\n                [p for p in pairs if p.liquidity and p.liquidity.usd &gt; 10_000],\n                key=lambda p: p.liquidity.usd,\n                reverse=True\n            )[:3]\n            all_pairs.extend(liquid_pairs)\n\n        print(f\"\u603b\u5171\u76d1\u63a7 {len(all_pairs)} \u4e2a\u4ea4\u6613\u5bf9\\n\")\n\n        # \u8ba2\u9605\u4ea4\u6613\u91cf\u66f4\u65b0\n        pair_addresses = [p.pair_address for p in all_pairs]\n\n        filter_config = FilterConfig(\n            change_fields=[\"volume.m5\", \"volume.h1\"],\n            volume_change_threshold=0.10  # 10% \u4ea4\u6613\u91cf\u53d8\u5316\n        )\n\n        await self.client.subscribe_pairs(\n            chain_id=chain_id,\n            pair_addresses=pair_addresses,\n            callback=self.handle_volume_update,\n            filter=filter_config,\n            interval=1.0\n        )\n\n        # \u76d1\u63a7 10 \u5206\u949f\n        await asyncio.sleep(600)\n        await self.client.close_streams()\n\n        # \u6458\u8981\n        print(f\"\\n\u68c0\u6d4b\u5230 {len(self.surge_alerts)} \u6b21\u4ea4\u6613\u91cf\u6fc0\u589e\")\n        if self.surge_alerts:\n            biggest_surge = max(self.surge_alerts, key=lambda x: x['surge_ratio'])\n            print(f\"\u6700\u5927\u6fc0\u589e: {biggest_surge['surge_ratio']:.1f}x \u5728 \"\n                  f\"{biggest_surge['pair'].base_token.symbol}\")\n\nasync def main():\n    detector = VolumeSurgeDetector(surge_multiplier=2.5)  # 2.5x \u6fc0\u589e\u9608\u503c\n\n    # \u76d1\u63a7\u4ee5\u592a\u574a\u4e0a\u7684\u70ed\u95e8\u4ee3\u5e01\n    await detector.monitor_tokens(\n        \"ethereum\",\n        [\n            \"A0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\",  # USDC\n            \"C02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\",  # WETH\n            \"6B175474E89094C44Da98b954EedeAC495271d0F\",  # DAI\n            \"dAC17F958D2ee523a2206206994597C13D831ec7\"   # USDT\n        ]\n    )\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"zh/examples/#_15","title":"\u6d41\u52a8\u6027\u76d1\u63a7","text":""},{"location":"zh/examples/#_16","title":"\u6d41\u52a8\u6027\u53d8\u5316\u8ddf\u8e2a\u5668","text":"<pre><code>import asyncio\nfrom datetime import datetime\nfrom dexscreen import DexscreenerClient, FilterConfig\n\nclass LiquidityTracker:\n    def __init__(self):\n        self.client = DexscreenerClient()\n        self.liquidity_snapshots = {}\n        self.significant_changes = []\n\n    def handle_liquidity_update(self, pair):\n        \"\"\"\u5904\u7406\u6d41\u52a8\u6027\u66f4\u65b0\"\"\"\n        if not pair.liquidity or not pair.liquidity.usd:\n            return\n\n        key = f\"{pair.chain_id}:{pair.pair_address}\"\n        current_liquidity = pair.liquidity.usd\n\n        # \u68c0\u67e5\u663e\u8457\u53d8\u5316\n        if key in self.liquidity_snapshots:\n            prev_liquidity = self.liquidity_snapshots[key]['liquidity']\n            change = (current_liquidity - prev_liquidity) / prev_liquidity\n\n            if abs(change) &gt; 0.1:  # 10% \u53d8\u5316\n                event = {\n                    'timestamp': datetime.now(),\n                    'pair': pair,\n                    'prev_liquidity': prev_liquidity,\n                    'current_liquidity': current_liquidity,\n                    'change_percent': change * 100,\n                    'type': '\u589e\u52a0' if change &gt; 0 else '\u79fb\u9664'\n                }\n                self.significant_changes.append(event)\n                self.print_liquidity_event(event)\n\n        # \u66f4\u65b0\u5feb\u7167\n        self.liquidity_snapshots[key] = {\n            'liquidity': current_liquidity,\n            'timestamp': datetime.now(),\n            'pair': pair\n        }\n\n    def print_liquidity_event(self, event):\n        \"\"\"\u6253\u5370\u6d41\u52a8\u6027\u53d8\u5316\u4e8b\u4ef6\"\"\"\n        pair = event['pair']\n        emoji = \"\ud83d\udcb0\" if event['type'] == '\u589e\u52a0' else \"\ud83d\udcb8\"\n\n        print(f\"\\n{emoji} \u6d41\u52a8\u6027{event['type']}\")\n        print(f\"  \u65f6\u95f4: {event['timestamp'].strftime('%H:%M:%S')}\")\n        print(f\"  \u4ea4\u6613\u5bf9: {pair.base_token.symbol}/{pair.quote_token.symbol} \u5728 {pair.dex_id}\")\n        print(f\"  \u4e4b\u524d: ${event['prev_liquidity']:,.0f}\")\n        print(f\"  \u5f53\u524d: ${event['current_liquidity']:,.0f}\")\n        print(f\"  \u53d8\u5316: {event['change_percent']:+.1f}%\")\n        print(f\"  \u4ef7\u683c\u5f71\u54cd: \u5f53\u524d\u4ef7\u683c ${pair.price_usd:,.6f}\")\n        print()\n\n    async def monitor_liquidity_changes(self, pairs_to_monitor):\n        \"\"\"\u76d1\u63a7\u7279\u5b9a\u4ea4\u6613\u5bf9\u7684\u6d41\u52a8\u6027\u53d8\u5316\"\"\"\n        print(f\"\u76d1\u63a7 {len(pairs_to_monitor)} \u4e2a\u4ea4\u6613\u5bf9\u7684\u6d41\u52a8\u6027...\\n\")\n\n        # \u6309\u94fe\u5206\u7ec4\n        by_chain = defaultdict(list)\n        for chain_id, pair_address in pairs_to_monitor:\n            by_chain[chain_id].append(pair_address)\n\n        # \u8ba2\u9605\u6bcf\u6761\u94fe\n        for chain_id, addresses in by_chain.items():\n            filter_config = FilterConfig(\n                change_fields=[\"liquidity.usd\", \"liquidity.base\", \"liquidity.quote\"],\n                liquidity_change_threshold=0.05,  # 5% \u53d8\u5316\u9608\u503c\n                max_updates_per_second=1.0\n            )\n\n            await self.client.subscribe_pairs(\n                chain_id=chain_id,\n                pair_addresses=addresses,\n                callback=self.handle_liquidity_update,\n                filter=filter_config,\n                interval=2.0\n            )\n\n        # \u76d1\u63a7 10 \u5206\u949f\n        await asyncio.sleep(600)\n        await self.client.close_streams()\n\n        # \u6458\u8981\n        self.print_summary()\n\n    def print_summary(self):\n        \"\"\"\u6253\u5370\u76d1\u63a7\u6458\u8981\"\"\"\n        print(\"\\n\" + \"=\"*60)\n        print(\"\u6d41\u52a8\u6027\u76d1\u63a7\u6458\u8981\")\n        print(\"=\"*60)\n\n        if not self.significant_changes:\n            print(\"\u672a\u68c0\u6d4b\u5230\u663e\u8457\u7684\u6d41\u52a8\u6027\u53d8\u5316\")\n            return\n\n        # \u8ba1\u7b97\u7edf\u8ba1\u6570\u636e\n        additions = [e for e in self.significant_changes if e['type'] == '\u589e\u52a0']\n        removals = [e for e in self.significant_changes if e['type'] == '\u79fb\u9664']\n\n        print(f\"\u603b\u4e8b\u4ef6\u6570: {len(self.significant_changes)}\")\n        print(f\"\u6d41\u52a8\u6027\u589e\u52a0: {len(additions)}\")\n        print(f\"\u6d41\u52a8\u6027\u79fb\u9664: {len(removals)}\")\n\n        if additions:\n            biggest_add = max(additions, key=lambda x: x['change_percent'])\n            print(f\"\\n\u6700\u5927\u589e\u52a0: {biggest_add['change_percent']:+.1f}% \u5728 \"\n                  f\"{biggest_add['pair'].base_token.symbol}\")\n\n        if removals:\n            biggest_remove = min(removals, key=lambda x: x['change_percent'])\n            print(f\"\u6700\u5927\u79fb\u9664: {biggest_remove['change_percent']:+.1f}% \u5728 \"\n                  f\"{biggest_remove['pair'].base_token.symbol}\")\n\n        print(\"=\"*60)\n\nasync def main():\n    tracker = LiquidityTracker()\n\n    # \u76d1\u63a7\u4e3b\u8981\u4ea4\u6613\u5bf9\n    pairs_to_monitor = [\n        (\"ethereum\", \"0x88e6a0c2ddd26feeb64f039a2c41296fcb3f5640\"),  # USDC/WETH Uniswap V3\n        (\"ethereum\", \"0x11b815efb8f581194ae79006d24e0d814b7697f6\"),  # WETH/USDT Uniswap V3\n        (\"ethereum\", \"0x4e68ccd3e89f51c3074ca5072bbac773960dfa36\"),  # WETH/USDT Uniswap V3\n        (\"bsc\", \"0x7213a321f1855cf1779f42c0cd85d3d95291d34c\"),        # USDT/USDC PancakeSwap\n        (\"polygon\", \"0x45dda9cb7c25131df268515131f647d726f50608\"),     # USDC/WETH QuickSwap\n    ]\n\n    await tracker.monitor_liquidity_changes(pairs_to_monitor)\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"zh/examples/#_17","title":"\u8b66\u62a5\u7cfb\u7edf","text":""},{"location":"zh/examples/#_18","title":"\u7efc\u5408\u8b66\u62a5\u7cfb\u7edf","text":"<pre><code>import asyncio\nfrom datetime import datetime\nfrom enum import Enum\nfrom typing import List, Dict, Callable\nfrom dexscreen import DexscreenerClient, FilterConfig\n\nclass AlertType(Enum):\n    PRICE_INCREASE = \"\u4ef7\u683c\u4e0a\u6da8\"\n    PRICE_DECREASE = \"\u4ef7\u683c\u4e0b\u8dcc\"\n    VOLUME_SURGE = \"\u4ea4\u6613\u91cf\u6fc0\u589e\"\n    LIQUIDITY_CHANGE = \"\u6d41\u52a8\u6027\u53d8\u5316\"\n    NEW_ATH = \"\u65b0\u9ad8\"\n    LARGE_TRANSACTION = \"\u5927\u989d\u4ea4\u6613\"\n\nclass AlertSystem:\n    def __init__(self):\n        self.client = DexscreenerClient()\n        self.alerts: List[Dict] = []\n        self.alert_handlers: Dict[AlertType, List[Callable]] = defaultdict(list)\n        self.price_history = defaultdict(list)\n        self.ath_tracker = {}\n\n    def register_handler(self, alert_type: AlertType, handler: Callable):\n        \"\"\"\u4e3a\u7279\u5b9a\u8b66\u62a5\u7c7b\u578b\u6ce8\u518c\u5904\u7406\u5668\"\"\"\n        self.alert_handlers[alert_type].append(handler)\n\n    def create_alert(self, alert_type: AlertType, pair, data: Dict):\n        \"\"\"\u521b\u5efa\u5e76\u5206\u53d1\u8b66\u62a5\"\"\"\n        alert = {\n            'type': alert_type,\n            'timestamp': datetime.now(),\n            'pair': pair,\n            'chain_id': pair.chain_id,\n            'symbol': pair.base_token.symbol,\n            'data': data\n        }\n\n        self.alerts.append(alert)\n\n        # \u5206\u53d1\u7ed9\u5904\u7406\u5668\n        for handler in self.alert_handlers[alert_type]:\n            try:\n                handler(alert)\n            except Exception as e:\n                print(f\"\u8b66\u62a5\u5904\u7406\u5668\u9519\u8bef: {e}\")\n\n    def check_price_alerts(self, pair):\n        \"\"\"\u68c0\u67e5\u57fa\u4e8e\u4ef7\u683c\u7684\u8b66\u62a5\"\"\"\n        key = f\"{pair.chain_id}:{pair.pair_address}\"\n\n        # \u8ddf\u8e2a\u4ef7\u683c\u5386\u53f2\n        self.price_history[key].append(pair.price_usd)\n        if len(self.price_history[key]) &gt; 100:\n            self.price_history[key].pop(0)\n\n        # \u68c0\u67e5\u65b0\u9ad8\n        if key not in self.ath_tracker or pair.price_usd &gt; self.ath_tracker[key]:\n            if key in self.ath_tracker:  # \u4e0d\u662f\u7b2c\u4e00\u6b21\n                self.create_alert(AlertType.NEW_ATH, pair, {\n                    'new_ath': pair.price_usd,\n                    'previous_ath': self.ath_tracker[key],\n                    'increase': ((pair.price_usd - self.ath_tracker[key]) / self.ath_tracker[key]) * 100\n                })\n            self.ath_tracker[key] = pair.price_usd\n\n        # \u68c0\u67e5\u6700\u8fd1\u4ef7\u683c\u53d8\u5316\n        if len(self.price_history[key]) &gt;= 2:\n            recent_change = (pair.price_usd - self.price_history[key][-2]) / self.price_history[key][-2]\n\n            if recent_change &gt; 0.05:  # 5% \u4e0a\u6da8\n                self.create_alert(AlertType.PRICE_INCREASE, pair, {\n                    'change_percent': recent_change * 100,\n                    'current_price': pair.price_usd\n                })\n            elif recent_change &lt; -0.05:  # 5% \u4e0b\u8dcc\n                self.create_alert(AlertType.PRICE_DECREASE, pair, {\n                    'change_percent': recent_change * 100,\n                    'current_price': pair.price_usd\n                })\n\n    def check_volume_alerts(self, pair):\n        \"\"\"\u68c0\u67e5\u57fa\u4e8e\u4ea4\u6613\u91cf\u7684\u8b66\u62a5\"\"\"\n        # \u4ea4\u6613\u91cf\u6fc0\u589e\u68c0\u6d4b\n        if pair.volume.m5 and pair.volume.h1:\n            hourly_avg_5min = pair.volume.h1 / 12  # \u8fc7\u53bb\u4e00\u5c0f\u65f6\u7684\u5e73\u57475\u5206\u949f\u4ea4\u6613\u91cf\n            if pair.volume.m5 &gt; hourly_avg_5min * 3:  # 3\u500d\u5e73\u5747\u503c\n                self.create_alert(AlertType.VOLUME_SURGE, pair, {\n                    'current_5m_volume': pair.volume.m5,\n                    'average_5m_volume': hourly_avg_5min,\n                    'surge_multiplier': pair.volume.m5 / hourly_avg_5min\n                })\n\n    def check_liquidity_alerts(self, pair):\n        \"\"\"\u68c0\u67e5\u6d41\u52a8\u6027\u53d8\u5316\"\"\"\n        if pair.liquidity and pair.liquidity.usd:\n            # \u8fd9\u9700\u8981\u5386\u53f2\u6570\u636e\u6765\u6bd4\u8f83\n            # \u4e3a\u6f14\u793a\uff0c\u6211\u4eec\u68c0\u67e5\u6d41\u52a8\u6027\u662f\u5426\u975e\u5e38\u4f4e\n            if pair.liquidity.usd &lt; 50_000:\n                self.create_alert(AlertType.LIQUIDITY_CHANGE, pair, {\n                    'current_liquidity': pair.liquidity.usd,\n                    'warning': '\u68c0\u6d4b\u5230\u4f4e\u6d41\u52a8\u6027'\n                })\n\n    def comprehensive_check(self, pair):\n        \"\"\"\u8fd0\u884c\u6240\u6709\u8b66\u62a5\u68c0\u67e5\"\"\"\n        self.check_price_alerts(pair)\n        self.check_volume_alerts(pair)\n        self.check_liquidity_alerts(pair)\n\n    async def monitor_with_alerts(self, chain_id: str, pair_addresses: List[str]):\n        \"\"\"\u4f7f\u7528\u7efc\u5408\u8b66\u62a5\u76d1\u63a7\u4ea4\u6613\u5bf9\"\"\"\n        print(f\"\u4e3a {chain_id} \u4e0a\u7684 {len(pair_addresses)} \u4e2a\u4ea4\u6613\u5bf9\u542f\u52a8\u8b66\u62a5\u7cfb\u7edf\\n\")\n\n        # \u914d\u7f6e\u8fc7\u6ee4\u4ee5\u83b7\u53d6\u76f8\u5173\u53d8\u5316\n        filter_config = FilterConfig(\n            change_fields=[\"price_usd\", \"volume.m5\", \"volume.h1\", \"liquidity.usd\"],\n            price_change_threshold=0.001,  # 0.1% \u9ad8\u7075\u654f\u5ea6\n            volume_change_threshold=0.10,   # 10% \u4ea4\u6613\u91cf\u53d8\u5316\n            max_updates_per_second=2.0\n        )\n\n        await self.client.subscribe_pairs(\n            chain_id=chain_id,\n            pair_addresses=pair_addresses,\n            callback=self.comprehensive_check,\n            filter=filter_config,\n            interval=0.5\n        )\n\n        # \u8fd0\u884c\u6307\u5b9a\u65f6\u957f\n        await asyncio.sleep(300)  # 5 \u5206\u949f\n        await self.client.close_streams()\n\n        # \u6253\u5370\u6458\u8981\n        self.print_alert_summary()\n\n    def print_alert_summary(self):\n        \"\"\"\u6253\u5370\u6240\u6709\u8b66\u62a5\u7684\u6458\u8981\"\"\"\n        print(\"\\n\" + \"=\"*60)\n        print(\"\u8b66\u62a5\u6458\u8981\")\n        print(\"=\"*60)\n\n        if not self.alerts:\n            print(\"\u6ca1\u6709\u89e6\u53d1\u8b66\u62a5\")\n            return\n\n        # \u6309\u7c7b\u578b\u5206\u7ec4\n        by_type = defaultdict(list)\n        for alert in self.alerts:\n            by_type[alert['type']].append(alert)\n\n        for alert_type, alerts in by_type.items():\n            print(f\"\\n{alert_type.value.upper()}: {len(alerts)} \u4e2a\u8b66\u62a5\")\n\n            # \u663e\u793a\u8be5\u7c7b\u578b\u7684\u6700\u540e 3 \u4e2a\u8b66\u62a5\n            for alert in alerts[-3:]:\n                print(f\"  [{alert['timestamp'].strftime('%H:%M:%S')}] \"\n                      f\"{alert['symbol']} \u5728 {alert['chain_id']}\")\n\n                # \u7279\u5b9a\u7c7b\u578b\u7684\u8be6\u60c5\n                if alert_type == AlertType.PRICE_INCREASE:\n                    print(f\"    +{alert['data']['change_percent']:.2f}% \"\n                          f\"\u5230 ${alert['data']['current_price']:,.6f}\")\n                elif alert_type == AlertType.VOLUME_SURGE:\n                    print(f\"    {alert['data']['surge_multiplier']:.1f}x \u6b63\u5e38\u4ea4\u6613\u91cf\")\n                elif alert_type == AlertType.NEW_ATH:\n                    print(f\"    \u65b0\u9ad8: ${alert['data']['new_ath']:,.6f} \"\n                          f\"(+{alert['data']['increase']:.2f}%)\")\n\n# \u793a\u4f8b\u5904\u7406\u5668\ndef console_handler(alert: Dict):\n    \"\"\"\u5c06\u8b66\u62a5\u6253\u5370\u5230\u63a7\u5236\u53f0\"\"\"\n    emoji_map = {\n        AlertType.PRICE_INCREASE: \"\ud83d\udcc8\",\n        AlertType.PRICE_DECREASE: \"\ud83d\udcc9\",\n        AlertType.VOLUME_SURGE: \"\ud83d\udd0a\",\n        AlertType.LIQUIDITY_CHANGE: \"\ud83d\udca7\",\n        AlertType.NEW_ATH: \"\ud83d\ude80\",\n        AlertType.LARGE_TRANSACTION: \"\ud83d\udc0b\"\n    }\n\n    emoji = emoji_map.get(alert['type'], \"\ud83d\udce2\")\n    print(f\"\\n{emoji} \u8b66\u62a5: {alert['type'].value} - {alert['symbol']} \"\n          f\"\u4e8e {alert['timestamp'].strftime('%H:%M:%S')}\")\n\nasync def main():\n    alert_system = AlertSystem()\n\n    # \u6ce8\u518c\u5904\u7406\u5668\n    alert_system.register_handler(AlertType.PRICE_INCREASE, console_handler)\n    alert_system.register_handler(AlertType.PRICE_DECREASE, console_handler)\n    alert_system.register_handler(AlertType.VOLUME_SURGE, console_handler)\n    alert_system.register_handler(AlertType.NEW_ATH, console_handler)\n\n    # \u76d1\u63a7\u4e00\u4e9b\u6d3b\u8dc3\u7684\u4ea4\u6613\u5bf9\n    await alert_system.monitor_with_alerts(\n        \"ethereum\",\n        [\n            \"0x88e6a0c2ddd26feeb64f039a2c41296fcb3f5640\",  # USDC/WETH\n            \"0x11b815efb8f581194ae79006d24e0d814b7697f6\",  # WETH/USDT\n            \"0x4e68ccd3e89f51c3074ca5072bbac773960dfa36\"   # WETH/USDT\n        ]\n    )\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"zh/examples/#_19","title":"\u4e0b\u4e00\u6b65","text":"<p>\u8fd9\u4e9b\u793a\u4f8b\u5c55\u793a\u4e86 Dexscreen \u7684\u5404\u79cd\u7528\u4f8b\u3002\u60a8\u53ef\u4ee5\uff1a</p> <ol> <li>\u7ec4\u5408\u793a\u4f8b - \u6df7\u5408\u76d1\u63a7\u4e0e\u8b66\u62a5\uff0c\u6dfb\u52a0\u6570\u636e\u5e93\u5b58\u50a8\u7b49</li> <li>\u6269\u5c55\u529f\u80fd - \u6dfb\u52a0\u901a\u77e5\u3001Web \u754c\u9762\u3001\u4ea4\u6613\u673a\u5668\u4eba\u96c6\u6210</li> <li>\u4f18\u5316\u6027\u80fd - \u4f7f\u7528\u5f02\u6b65\u64cd\u4f5c\u3001\u6279\u91cf\u8bf7\u6c42\u3001\u667a\u80fd\u8fc7\u6ee4</li> <li>\u6269\u5c55\u89c4\u6a21 - \u76d1\u63a7\u66f4\u591a\u4ea4\u6613\u5bf9\uff0c\u5b9e\u73b0\u5206\u5e03\u5f0f\u7cfb\u7edf</li> </ol> <p>\u66f4\u591a\u8be6\u60c5\uff0c\u8bf7\u53c2\u89c1\uff1a</p> <ul> <li>\u5165\u95e8\u6307\u5357 - \u5b89\u88c5\u548c\u57fa\u7840\u77e5\u8bc6</li> <li>\u67e5\u8be2 API - \u6240\u6709\u67e5\u8be2\u65b9\u6cd5</li> <li>\u6d41\u5f0f API - \u5b9e\u65f6\u8ba2\u9605</li> <li>\u8fc7\u6ee4 - \u9ad8\u7ea7\u8fc7\u6ee4\u9009\u9879</li> </ul>"},{"location":"zh/getting-started/","title":"Dexscreen \u5165\u95e8\u6307\u5357","text":"<p>\u672c\u6307\u5357\u5c06\u5e2e\u52a9\u60a8\u5feb\u901f\u4e0a\u624b\u5e76\u5f00\u59cb\u4f7f\u7528 Dexscreen\uff0c\u8ba9\u60a8\u8f7b\u677e\u8fdb\u884c DeFi \u6570\u636e\u76d1\u63a7\u548c\u5206\u6790\u3002</p>"},{"location":"zh/getting-started/#_1","title":"\u5b89\u88c5","text":""},{"location":"zh/getting-started/#uv","title":"\u4f7f\u7528 uv","text":"<pre><code>uv add dexscreen\n</code></pre>"},{"location":"zh/getting-started/#pip","title":"\u4f7f\u7528 pip","text":"<pre><code>pip install dexscreen\n</code></pre>"},{"location":"zh/getting-started/#_2","title":"\u4ece\u6e90\u7801\u5b89\u88c5","text":"<pre><code>git clone https://github.com/yourusername/dexscreen.git\ncd dexscreen\npip install -e .\n</code></pre>"},{"location":"zh/getting-started/#_3","title":"\u57fa\u672c\u6982\u5ff5","text":"<p>Dexscreen \u63d0\u4f9b\u4e24\u79cd\u4e3b\u8981\u65b9\u5f0f\u4e0e Dexscreener \u6570\u636e\u4ea4\u4e92\uff1a</p> <ol> <li>\u67e5\u8be2 API - \u4e00\u6b21\u6027\u6570\u636e\u83b7\u53d6\uff08\u540c\u6b65\u6216\u5f02\u6b65\uff09\uff0c\u9002\u7528\u4e8e\uff1a</li> <li>\u5f53\u524d\u4ef7\u683c\u68c0\u67e5</li> <li>\u4ee3\u5e01\u641c\u7d22\u548c\u53d1\u73b0</li> <li>\u5feb\u7167\u5f0f\u6570\u636e\u5206\u6790</li> <li> <p>\u5386\u53f2\u6570\u636e\u83b7\u53d6</p> </li> <li> <p>\u6d41\u5f0f API - \u901a\u8fc7 HTTP \u8f6e\u8be2\u5b9e\u73b0\u5b9e\u65f6\u66f4\u65b0\uff0c\u9002\u7528\u4e8e\uff1a</p> </li> <li>\u5b9e\u65f6\u4ef7\u683c\u76d1\u63a7</li> <li>\u4ea4\u6613\u673a\u5668\u4eba</li> <li>\u8b66\u62a5\u7cfb\u7edf</li> <li>\u6295\u8d44\u7ec4\u5408\u8ddf\u8e2a</li> </ol>"},{"location":"zh/getting-started/#_4","title":"\u60a8\u7684\u7b2c\u4e00\u4e2a\u67e5\u8be2","text":""},{"location":"zh/getting-started/#_5","title":"\u521b\u5efa\u5ba2\u6237\u7aef","text":"<pre><code>from dexscreen import DexscreenerClient\n\n# \u57fa\u672c\u5ba2\u6237\u7aef\uff08\u63a8\u8350\u7528\u4e8e\u5927\u591a\u6570\u7528\u4f8b\uff09\nclient = DexscreenerClient()\n\n# \u5e26\u6d4f\u89c8\u5668\u6a21\u62df\uff08\u5728\u9047\u5230\u53cd\u673a\u5668\u4eba\u4fdd\u62a4\u65f6\u4f7f\u7528\uff09\nclient = DexscreenerClient(impersonate=\"chrome136\")\n\n# \u8c03\u8bd5\u6a21\u5f0f\uff08\u5f00\u53d1\u65f6\u542f\u7528\u8be6\u7ec6\u65e5\u5fd7\uff09\nclient = DexscreenerClient(debug=True)\n</code></pre>"},{"location":"zh/getting-started/#_6","title":"\u83b7\u53d6\u4ea4\u6613\u5bf9\u6570\u636e","text":"<pre><code># 1. \u641c\u7d22\u4ea4\u6613\u5bf9\uff08\u6309\u4ee3\u5e01\u540d\u79f0\u6216\u7b26\u53f7\uff09\npairs = client.search_pairs(\"PEPE\")\nif pairs:\n    print(f\"\u627e\u5230 {len(pairs)} \u4e2a PEPE \u4ea4\u6613\u5bf9\")\n    for pair in pairs[:5]:  # \u663e\u793a\u524d 5 \u4e2a\u7ed3\u679c\n        print(f\"  {pair.base_token.symbol}/{pair.quote_token.symbol} \u5728 {pair.chain_id}\")\n        print(f\"    \u4ef7\u683c: ${pair.price_usd:.8f}, DEX: {pair.dex_id}\")\n        print(f\"    24h\u4ea4\u6613\u91cf: ${pair.volume.h24:,.0f}\")\n        print()\n\n# 2. \u83b7\u53d6\u7279\u5b9a\u4ee3\u5e01\u7684\u6240\u6709\u4ea4\u6613\u5bf9\nusdc_address = \"0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\"  # \u4ee5\u592a\u574a USDC\npairs = client.get_pairs_by_token_address(\"ethereum\", usdc_address)\nprint(f\"\u5728\u4ee5\u592a\u574a\u627e\u5230 {len(pairs)} \u4e2a USDC \u4ea4\u6613\u5bf9\")\n\n# \u627e\u5230\u6d41\u52a8\u6027\u6700\u9ad8\u7684 USDC \u4ea4\u6613\u5bf9\nif pairs:\n    best_usdc_pair = max(pairs, key=lambda p: p.liquidity.usd if p.liquidity else 0)\n    print(f\"\u6700\u4f73 USDC \u4ea4\u6613\u5bf9: {best_usdc_pair.base_token.symbol}/{best_usdc_pair.quote_token.symbol}\")\n    print(f\"\u6d41\u52a8\u6027: ${best_usdc_pair.liquidity.usd:,.0f}\")\n\n# 3. \u83b7\u53d6\u7279\u5b9a\u4ea4\u6613\u5bf9\u7684\u8be6\u7ec6\u4fe1\u606f\npair = client.get_pair_by_pair_address(\n    \"ethereum\",\n    \"0x88e6a0c2ddd26feeb64f039a2c41296fcb3f5640\"  # Uniswap V3 USDC/WETH\n)\nif pair:\n    print(f\"\u4ea4\u6613\u5bf9\u8be6\u60c5:\")\n    print(f\"  \u4ef7\u683c: ${pair.price_usd:.6f}\")\n    print(f\"  24\u5c0f\u65f6\u4ea4\u6613\u91cf: ${pair.volume.h24:,.0f}\")\n    print(f\"  24\u5c0f\u65f6\u4ef7\u683c\u53d8\u5316: {pair.price_change.h24:+.2f}%\")\n    print(f\"  DEX: {pair.dex_id}\")\n</code></pre>"},{"location":"zh/getting-started/#_7","title":"\u5b9e\u65f6\u66f4\u65b0","text":""},{"location":"zh/getting-started/#_8","title":"\u57fa\u672c\u8ba2\u9605","text":"<pre><code>import asyncio\nfrom datetime import datetime\n\nasync def price_update_handler(pair):\n    \"\"\"\u5904\u7406\u4ef7\u683c\u66f4\u65b0 - \u663e\u793a\u65f6\u95f4\u6233\u548c\u5173\u952e\u4fe1\u606f\"\"\"\n    timestamp = datetime.now().strftime(\"%H:%M:%S\")\n    print(f\"[{timestamp}] {pair.base_token.symbol}: ${pair.price_usd:,.4f} \"\n          f\"(24h: {pair.price_change.h24:+.2f}%)\")\n\nasync def main():\n    client = DexscreenerClient()\n\n    print(\"\u5f00\u59cb\u76d1\u63a7 JUP \u4ee3\u5e01\u4ef7\u683c...\")\n\n    # \u8ba2\u9605 Solana \u4e0a\u7684 JUP \u4ea4\u6613\u5bf9\n    await client.subscribe_pairs(\n        chain_id=\"solana\",\n        pair_addresses=[\"JUPyiwrYJFskUPiHa7hkeR8VUtAeFoSYbKedZNsDvCN\"],\n        callback=price_update_handler,\n        interval=1.0  # \u6bcf\u79d2\u68c0\u67e5\u4e00\u6b21\u66f4\u65b0\n    )\n\n    # \u76d1\u63a7 30 \u79d2\n    print(\"\u76d1\u63a7\u4e2d... (30\u79d2)\")\n    await asyncio.sleep(30)\n\n    # \u6e05\u7406\u8d44\u6e90\n    print(\"\u6b63\u5728\u5173\u95ed\u8fde\u63a5...\")\n    await client.close_streams()\n    print(\"\u76d1\u63a7\u7ed3\u675f\")\n\n# \u8fd0\u884c\u5f02\u6b65\u51fd\u6570\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"zh/getting-started/#_9","title":"\u76d1\u63a7\u591a\u4e2a\u4ea4\u6613\u5bf9","text":"<pre><code>async def portfolio_monitor():\n    client = DexscreenerClient()\n\n    # \u5b9a\u4e49\u60a8\u7684\u6295\u8d44\u7ec4\u5408\uff08\u94feID, \u4ea4\u6613\u5bf9\u5730\u5740, \u63cf\u8ff0\uff09\n    portfolio = [\n        (\"ethereum\", \"0x88e6a0c2ddd26feeb64f039a2c41296fcb3f5640\", \"USDC/WETH Uniswap V3\"),\n        (\"solana\", \"JUPyiwrYJFskUPiHa7hkeR8VUtAeFoSYbKedZNsDvCN\", \"JUP/SOL Raydium\"),\n        (\"bsc\", \"0x2170ed0880ac9a755fd29b2688956bd959f933f8\", \"ETH/BNB PancakeSwap\"),\n    ]\n\n    # \u6295\u8d44\u7ec4\u5408\u66f4\u65b0\u5904\u7406\u5668\n    async def handle_portfolio_update(pair):\n        timestamp = datetime.now().strftime(\"%H:%M:%S\")\n        # \u786e\u5b9a\u54ea\u4e2a\u4ee3\u5e01\u662f\u4e3b\u8981\u4ee3\u5e01\uff08\u975e\u7a33\u5b9a\u5e01\uff09\n        main_token = pair.base_token if pair.base_token.symbol not in [\"USDC\", \"USDT\", \"BUSD\"] else pair.quote_token\n\n        print(f\"[{timestamp}] [{pair.chain_id.upper()}] {main_token.symbol}: \"\n              f\"${pair.price_usd:,.4f} ({pair.price_change.h24:+.2f}%) \"\n              f\"Vol: ${pair.volume.h24:,.0f}\")\n\n    print(\"\u5f00\u59cb\u76d1\u63a7\u6295\u8d44\u7ec4\u5408...\")\n\n    # \u8ba2\u9605\u6240\u6709\u4ea4\u6613\u5bf9\n    for chain_id, pair_address, description in portfolio:\n        print(f\"\u8ba2\u9605 {description} \u5728 {chain_id}\")\n        await client.subscribe_pairs(\n            chain_id=chain_id,\n            pair_addresses=[pair_address],\n            callback=handle_portfolio_update,\n            interval=2.0  # \u6bcf 2 \u79d2\u68c0\u67e5\u66f4\u65b0\n        )\n\n    print(f\"\\n\u6b63\u5728\u76d1\u63a7 {len(portfolio)} \u4e2a\u4ea4\u6613\u5bf9\uff0c\u6309 Ctrl+C \u505c\u6b62...\")\n\n    try:\n        # \u76d1\u63a7 1 \u5206\u949f\uff08\u751f\u4ea7\u73af\u5883\u4e2d\u53ef\u80fd\u4f1a\u66f4\u957f\uff09\n        await asyncio.sleep(60)\n    except KeyboardInterrupt:\n        print(\"\\n\u6536\u5230\u4e2d\u65ad\u4fe1\u53f7\uff0c\u6b63\u5728\u505c\u6b62...\")\n    finally:\n        await client.close_streams()\n        print(\"\u6295\u8d44\u7ec4\u5408\u76d1\u63a7\u5df2\u505c\u6b62\")\n\nif __name__ == \"__main__\":\n    asyncio.run(portfolio_monitor())\n</code></pre>"},{"location":"zh/getting-started/#_10","title":"\u8fc7\u6ee4\u66f4\u65b0","text":"<p>\u4f7f\u7528\u8fc7\u6ee4\u5668\u63a7\u5236\u4f55\u65f6\u89e6\u53d1\u56de\u8c03\uff0c\u51cf\u5c11\u4e0d\u5fc5\u8981\u7684\u901a\u77e5\uff1a</p> <pre><code>from dexscreen import FilterPresets\n\n# 1. \u4ec5\u5728\u4ef7\u683c\u663e\u8457\u53d8\u5316\u65f6\u89e6\u53d1\uff081% \u9608\u503c\uff09\nawait client.subscribe_pairs(\n    chain_id=\"ethereum\",\n    pair_addresses=[\"0x88e6a0c2ddd26feeb64f039a2c41296fcb3f5640\"],\n    callback=handle_update,\n    filter=FilterPresets.significant_price_changes(0.01),  # 1% \u4ef7\u683c\u53d8\u5316\n    interval=0.5  # \u6bcf 0.5 \u79d2\u68c0\u67e5\n)\n\n# 2. \u9650\u5236\u66f4\u65b0\u9891\u7387\u4ee5\u907f\u514d\u8fc7\u8f7d\nawait client.subscribe_pairs(\n    chain_id=\"ethereum\",\n    pair_addresses=[\"0x88e6a0c2ddd26feeb64f039a2c41296fcb3f5640\"],\n    callback=handle_update,\n    filter=FilterPresets.rate_limited(1.0),  # \u6bcf\u79d2\u6700\u591a 1 \u6b21\u66f4\u65b0\n    interval=0.2  # \u5feb\u901f\u8f6e\u8be2\u4f46\u9650\u5236\u56de\u8c03\u9891\u7387\n)\n\n# 3. UI \u53cb\u597d\u7684\u8fc7\u6ee4\uff08\u5e73\u8861\u66f4\u65b0\u9891\u7387\u548c\u6709\u7528\u6027\uff09\nawait client.subscribe_pairs(\n    chain_id=\"ethereum\",\n    pair_addresses=[\"0x88e6a0c2ddd26feeb64f039a2c41296fcb3f5640\"],\n    callback=handle_update,\n    filter=FilterPresets.ui_friendly(),  # \u9884\u914d\u7f6e\u7684 UI \u4f18\u5316\u8bbe\u7f6e\n    interval=1.0\n)\n</code></pre>"},{"location":"zh/getting-started/#_11","title":"\u9519\u8bef\u5904\u7406","text":"<p>\u5728\u751f\u4ea7\u73af\u5883\u4e2d\uff0c\u59cb\u7ec8\u5728\u56de\u8c03\u4e2d\u5904\u7406\u9519\u8bef\u4ee5\u907f\u514d\u8ba2\u9605\u4e2d\u65ad\uff1a</p> <pre><code>import logging\n\n# \u8bbe\u7f6e\u65e5\u5fd7\u8bb0\u5f55\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\nasync def safe_callback(pair):\n    try:\n        # \u60a8\u7684\u4e1a\u52a1\u903b\u8f91\n        if pair.price_usd and pair.price_usd &gt; 100:\n            print(f\"\u9ad8\u4ef7\u503c\u4ee3\u5e01: {pair.base_token.symbol} = ${pair.price_usd:,.2f}\")\n\n        # \u68c0\u67e5\u4ef7\u683c\u5f02\u5e38\u53d8\u5316\n        if abs(pair.price_change.h24) &gt; 50:  # 24\u5c0f\u65f6\u53d8\u5316\u8d85\u8fc750%\n            logger.warning(f\"\u4ef7\u683c\u5f02\u5e38\u53d8\u5316: {pair.base_token.symbol} {pair.price_change.h24:+.2f}%\")\n\n    except AttributeError as e:\n        logger.error(f\"\u6570\u636e\u5b57\u6bb5\u7f3a\u5931: {e}\")\n    except TypeError as e:\n        logger.error(f\"\u6570\u636e\u7c7b\u578b\u9519\u8bef: {e}\")\n    except Exception as e:\n        logger.error(f\"\u5904\u7406\u66f4\u65b0\u65f6\u51fa\u73b0\u672a\u77e5\u9519\u8bef: {e}\")\n        # \u91cd\u8981\uff1a\u4e0d\u8981\u91cd\u65b0\u629b\u51fa\u5f02\u5e38\uff0c\u907f\u514d\u8ba2\u9605\u4e2d\u65ad\n\n# \u4f7f\u7528\u5b89\u5168\u56de\u8c03\nasync def robust_monitoring():\n    client = DexscreenerClient()\n\n    try:\n        await client.subscribe_pairs(\n            chain_id=\"ethereum\",\n            pair_addresses=[\"0x88e6a0c2ddd26feeb64f039a2c41296fcb3f5640\"],\n            callback=safe_callback,\n            interval=1.0\n        )\n\n        await asyncio.sleep(30)\n\n    except Exception as e:\n        logger.error(f\"\u8ba2\u9605\u8bbe\u7f6e\u5931\u8d25: {e}\")\n    finally:\n        await client.close_streams()\n        logger.info(\"\u76d1\u63a7\u4f1a\u8bdd\u7ed3\u675f\")\n</code></pre>"},{"location":"zh/getting-started/#vs","title":"\u540c\u6b65 vs \u5f02\u6b65","text":"<p>Dexscreen \u652f\u6301\u4e24\u79cd\u6a21\u5f0f\uff1a</p>"},{"location":"zh/getting-started/#_12","title":"\u540c\u6b65\u6a21\u5f0f","text":"<pre><code># \u7b80\u5355\u76f4\u63a5\uff0c\u9002\u7528\u4e8e\u811a\u672c\u548c\u4e00\u6b21\u6027\u67e5\u8be2\nclient = DexscreenerClient()\n\n# \u540c\u6b65\u641c\u7d22\npairs = client.search_pairs(\"PEPE\")\nprint(f\"\u627e\u5230 {len(pairs)} \u4e2a PEPE \u4ea4\u6613\u5bf9\")\n\n# \u540c\u6b65\u83b7\u53d6\u7279\u5b9a\u4ea4\u6613\u5bf9\npair = client.get_pair_by_pair_address(\"ethereum\", \"0x88e6...\")\nif pair:\n    print(f\"\u5f53\u524d\u4ef7\u683c: ${pair.price_usd}\")\n</code></pre>"},{"location":"zh/getting-started/#_13","title":"\u5f02\u6b65\u6a21\u5f0f","text":"<pre><code># \u66f4\u9002\u5408\u5e76\u53d1\u64cd\u4f5c\u3001\u5b9e\u65f6\u76d1\u63a7\u548c\u9ad8\u6027\u80fd\u5e94\u7528\nasync def fetch_multiple_tokens():\n    client = DexscreenerClient()\n\n    # \u5b9a\u4e49\u8981\u641c\u7d22\u7684\u4ee3\u5e01\n    tokens = [\"PEPE\", \"SHIB\", \"DOGE\", \"FLOKI\"]\n\n    print(\"\u5e76\u53d1\u641c\u7d22\u591a\u4e2a\u4ee3\u5e01...\")\n\n    # \u5e76\u53d1\u8fd0\u884c\u591a\u4e2a\u67e5\u8be2\uff08\u66f4\u5feb\uff09\n    tasks = [client.search_pairs_async(token) for token in tokens]\n    results = await asyncio.gather(*tasks)\n\n    # \u5904\u7406\u7ed3\u679c\n    for token, token_pairs in zip(tokens, results):\n        if token_pairs:\n            best_pair = max(token_pairs, key=lambda p: p.volume.h24 or 0)\n            print(f\"{token}: \u627e\u5230 {len(token_pairs)} \u4e2a\u4ea4\u6613\u5bf9\uff0c\"\n                  f\"\u6700\u9ad8\u4ea4\u6613\u91cf: ${best_pair.volume.h24:,.0f}\")\n        else:\n            print(f\"{token}: \u672a\u627e\u5230\u4ea4\u6613\u5bf9\")\n\n# \u8fd0\u884c\u5f02\u6b65\u51fd\u6570\nif __name__ == \"__main__\":\n    asyncio.run(fetch_multiple_tokens())\n</code></pre>"},{"location":"zh/getting-started/#_14","title":"\u4e0b\u4e00\u6b65","text":""},{"location":"zh/getting-started/#_15","title":"\ud83d\udcda \u6df1\u5165\u5b66\u4e60","text":"<ol> <li>\u67e5\u8be2 API - \u4e86\u89e3\u6240\u6709\u53ef\u7528\u7684\u6570\u636e\u83b7\u53d6\u65b9\u6cd5</li> <li>\u6d41\u5f0f API - \u638c\u63e1\u5b9e\u65f6\u6570\u636e\u76d1\u63a7\u6280\u672f</li> <li>\u6570\u636e\u6a21\u578b - \u7406\u89e3 API \u8fd4\u56de\u7684\u6570\u636e\u7ed3\u6784</li> <li>\u8fc7\u6ee4\u5668 - \u5b66\u4e60\u9ad8\u7ea7\u8fc7\u6ee4\u6280\u672f\u4f18\u5316\u6027\u80fd</li> <li>\u793a\u4f8b - \u67e5\u770b\u5b8c\u6574\u7684\u751f\u4ea7\u5c31\u7eea\u4ee3\u7801\u793a\u4f8b</li> </ol>"},{"location":"zh/getting-started/#_16","title":"\ud83d\ude80 \u5b9e\u9645\u9879\u76ee\u601d\u8def","text":"<ul> <li>\u4ef7\u683c\u8b66\u62a5\u673a\u5668\u4eba: \u76d1\u63a7\u4ee3\u5e01\u4ef7\u683c\u53d8\u5316\u5e76\u53d1\u9001\u901a\u77e5</li> <li>\u5957\u5229\u626b\u63cf\u5668: \u8de8\u4e0d\u540c DEX \u548c\u94fe\u5bfb\u627e\u5957\u5229\u673a\u4f1a</li> <li>\u6295\u8d44\u7ec4\u5408\u4eea\u8868\u677f: \u5b9e\u65f6\u8ddf\u8e2a\u60a8\u7684 DeFi \u6295\u8d44\u7ec4\u5408</li> <li>\u65b0\u4ee3\u5e01\u53d1\u73b0\u5de5\u5177: \u81ea\u52a8\u53d1\u73b0\u548c\u5206\u6790\u65b0\u4e0a\u5e02\u7684\u4ee3\u5e01</li> <li>\u6d41\u52a8\u6027\u76d1\u63a7\u7cfb\u7edf: \u8ddf\u8e2a\u5927\u989d\u6d41\u52a8\u6027\u53d8\u5316</li> </ul>"},{"location":"zh/getting-started/#_17","title":"\u5e38\u89c1\u95ee\u9898\u8be2\u9635","text":""},{"location":"zh/getting-started/#_18","title":"\ud83d\udea6 \u901f\u7387\u9650\u5236","text":"<p>\u95ee\u9898: \u9047\u5230\u901f\u7387\u9650\u5236\u9519\u8bef \u89e3\u51b3\u65b9\u6848:</p> <ul> <li>SDK \u81ea\u52a8\u5904\u7406\u901f\u7387\u9650\u5236\uff0c\u4f1a\u81ea\u52a8\u9000\u907f\u91cd\u8bd5</li> <li>\u5982\u679c\u9891\u7e41\u9047\u5230\u9650\u5236\uff0c\u8003\u8651\u589e\u52a0\u8f6e\u8be2\u95f4\u9694</li> <li>\u4f7f\u7528\u6279\u91cf\u65b9\u6cd5\uff08\u5982 <code>get_pairs_by_pairs_addresses</code>\uff09\u800c\u4e0d\u662f\u591a\u6b21\u5355\u72ec\u8c03\u7528</li> </ul>"},{"location":"zh/getting-started/#_19","title":"\ud83d\udcca \u6ca1\u6709\u8fd4\u56de\u6570\u636e","text":"<p>\u5e38\u89c1\u539f\u56e0:</p> <ul> <li>\u274c \u9519\u8bef\u7684 chain_id\uff1a\u4f7f\u7528 <code>\"ethereum\"</code> \u800c\u4e0d\u662f <code>\"eth\"</code></li> <li>\u274c \u65e0\u6548\u7684\u5408\u7ea6\u5730\u5740\uff1a\u786e\u4fdd\u5730\u5740\u683c\u5f0f\u6b63\u786e\u4e14\u7ecf\u8fc7\u6821\u9a8c\u548c</li> <li>\u274c \u4ee3\u5e01\u4e0d\u5b58\u5728\uff1a\u67d0\u4e9b\u4ee3\u5e01\u53ef\u80fd\u5728\u7279\u5b9a\u94fe\u4e0a\u6ca1\u6709\u4ea4\u6613\u5bf9</li> <li>\u274c \u65b0\u4ee3\u5e01\uff1a\u521a\u53d1\u5e03\u7684\u4ee3\u5e01\u53ef\u80fd\u8fd8\u672a\u88ab\u7d22\u5f15</li> </ul> <p>\u89e3\u51b3\u65b9\u6cd5:</p> <pre><code># \u9a8c\u8bc1\u5730\u5740\u683c\u5f0f\nfrom web3 import Web3\naddress = \"0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\"\nif Web3.isAddress(address):\n    pairs = client.get_pairs_by_token_address(\"ethereum\", address)\nelse:\n    print(\"\u65e0\u6548\u7684\u4ee5\u592a\u574a\u5730\u5740\")\n</code></pre>"},{"location":"zh/getting-started/#_20","title":"\ud83d\udd04 \u8ba2\u9605\u672a\u66f4\u65b0","text":"<p>\u8bca\u65ad\u6b65\u9aa4:</p> <ol> <li>\u68c0\u67e5\u8fc7\u6ee4\u5668\u914d\u7f6e\uff1a\u786e\u4fdd\u8fc7\u6ee4\u5668\u4e0d\u4f1a\u8fc7\u6ee4\u6389\u6240\u6709\u66f4\u65b0</li> </ol> <pre><code># \u4e34\u65f6\u7981\u7528\u8fc7\u6ee4\u5668\u8fdb\u884c\u6d4b\u8bd5\nawait client.subscribe_pairs(..., filter=False)\n</code></pre> <ol> <li>\u9a8c\u8bc1\u4ea4\u6613\u5bf9\u6d3b\u8dc3\u5ea6\uff1a\u786e\u4fdd\u4ea4\u6613\u5bf9\u6709\u5b9e\u9645\u7684\u4ea4\u6613\u6d3b\u52a8</li> </ol> <pre><code>pair = client.get_pair_by_pair_address(chain_id, pair_address)\nif pair and pair.volume.h24 &gt; 0:\n    print(\"\u4ea4\u6613\u5bf9\u6d3b\u8dc3\")\nelse:\n    print(\"\u4ea4\u6613\u5bf9\u53ef\u80fd\u4e0d\u6d3b\u8dc3\")\n</code></pre> <ol> <li>\u68c0\u67e5\u56de\u8c03\u9519\u8bef\uff1a\u786e\u4fdd\u56de\u8c03\u51fd\u6570\u6ca1\u6709\u629b\u51fa\u5f02\u5e38</li> </ol> <pre><code>async def debug_callback(pair):\n    try:\n        print(f\"\u6536\u5230\u66f4\u65b0: {pair.base_token.symbol}\")\n        # \u60a8\u7684\u903b\u8f91...\n    except Exception as e:\n        print(f\"\u56de\u8c03\u9519\u8bef: {e}\")\n</code></pre>"},{"location":"zh/getting-started/#_21","title":"\ud83d\udd27 \u8fde\u63a5\u95ee\u9898","text":"<p>\u95ee\u9898: \u65e0\u6cd5\u8fde\u63a5\u5230 Dexscreener API</p> <p>\u89e3\u51b3\u65b9\u6848:</p> <pre><code># \u542f\u7528\u6d4f\u89c8\u5668\u6a21\u62df\u4ee5\u7ed5\u8fc7\u53cd\u673a\u5668\u4eba\u4fdd\u62a4\nclient = DexscreenerClient(impersonate=\"chrome136\")\n\n# \u6216\u8005\u8bbe\u7f6e\u8c03\u8bd5\u6a21\u5f0f\u67e5\u770b\u8be6\u7ec6\u9519\u8bef\nclient = DexscreenerClient(debug=True)\n</code></pre>"},{"location":"zh/getting-started/#_22","title":"\ud83d\udcbe \u5185\u5b58\u4f7f\u7528","text":"<p>\u95ee\u9898: \u957f\u65f6\u95f4\u8fd0\u884c\u540e\u5185\u5b58\u4f7f\u7528\u8fc7\u9ad8</p> <p>\u89e3\u51b3\u65b9\u6848:</p> <ul> <li>\u5b9a\u671f\u6e05\u7406\u4e0d\u9700\u8981\u7684\u8ba2\u9605</li> <li>\u4f7f\u7528\u9002\u5f53\u7684\u8fc7\u6ee4\u5668\u51cf\u5c11\u6570\u636e\u5904\u7406</li> <li>\u5b9e\u73b0\u6570\u636e\u8f6e\u6362\u7b56\u7565</li> </ul> <pre><code># \u5b9a\u671f\u6e05\u7406\u793a\u4f8b\nimport asyncio\nfrom datetime import datetime, timedelta\n\nclass ManagedClient:\n    def __init__(self):\n        self.client = DexscreenerClient()\n        self.last_cleanup = datetime.now()\n\n    async def periodic_cleanup(self):\n        while True:\n            await asyncio.sleep(3600)  # \u6bcf\u5c0f\u65f6\u68c0\u67e5\n            if datetime.now() - self.last_cleanup &gt; timedelta(hours=6):\n                print(\"\u6267\u884c\u5b9a\u671f\u6e05\u7406...\")\n                await self.client.close_streams()\n                self.client = DexscreenerClient()  # \u521b\u5efa\u65b0\u5b9e\u4f8b\n                self.last_cleanup = datetime.now()\n</code></pre>"},{"location":"zh/getting-started/#_23","title":"\ud83c\udd98 \u83b7\u53d6\u5e2e\u52a9","text":"\u8d44\u6e90\u7c7b\u578b \u94fe\u63a5 \u9002\u7528\u60c5\u51b5 \ud83d\udcd6 \u5b8c\u6574\u793a\u4f8b \u793a\u4f8b\u9875\u9762 \u9700\u8981\u5de5\u4f5c\u4ee3\u7801\u53c2\u8003 \ud83d\udccb API \u53c2\u8003 \u67e5\u8be2 API \u4e86\u89e3\u5177\u4f53\u65b9\u6cd5\u7528\u6cd5 \ud83d\udc1b \u9519\u8bef\u62a5\u544a GitHub Issues \u53d1\u73b0 bug \u6216\u95ee\u9898 \ud83d\udca1 \u529f\u80fd\u5efa\u8bae GitHub Discussions \u5efa\u8bae\u65b0\u529f\u80fd \ud83d\udcac \u793e\u533a\u8ba8\u8bba GitHub Discussions \u4e00\u822c\u95ee\u9898\u548c\u8ba8\u8bba"},{"location":"zh/getting-started/#_24","title":"\ud83d\udd0d \u5bfb\u6c42\u5e2e\u52a9\u65f6\u7684\u6700\u4f73\u5b9e\u8df5","text":"<ol> <li>\u63d0\u4f9b\u5b8c\u6574\u7684\u9519\u8bef\u4fe1\u606f\u548c\u76f8\u5173\u7684\u4ee3\u7801\u7247\u6bb5</li> <li>\u8bf4\u660e\u60a8\u7684\u4f7f\u7528\u573a\u666f\u548c\u671f\u671b\u7684\u884c\u4e3a</li> <li>\u5305\u542b\u7cfb\u7edf\u4fe1\u606f\uff08Python \u7248\u672c\u3001\u64cd\u4f5c\u7cfb\u7edf\u7b49\uff09</li> <li>\u5148\u68c0\u67e5\u73b0\u6709\u7684 Issues \u770b\u662f\u5426\u5df2\u6709\u89e3\u51b3\u65b9\u6848</li> </ol> <p>\ud83d\udca1 \u63d0\u793a: \u5927\u591a\u6570\u95ee\u9898\u90fd\u53ef\u4ee5\u901a\u8fc7\u67e5\u770b\u793a\u4f8b\u4e2d\u7684\u5b8c\u6574\u4ee3\u7801\u5f97\u5230\u89e3\u7b54\uff01</p> <p>\ud83c\udf89 \u606d\u559c\uff01 \u60a8\u73b0\u5728\u5df2\u7ecf\u638c\u63e1\u4e86 Dexscreen \u7684\u57fa\u7840\u77e5\u8bc6\u3002\u7ee7\u7eed\u63a2\u7d22\u793a\u4f8b\u4ee5\u4e86\u89e3\u66f4\u591a\u9ad8\u7ea7\u7528\u6cd5\uff0c\u6216\u76f4\u63a5\u5f00\u59cb\u6784\u5efa\u60a8\u7684\u7b2c\u4e00\u4e2a DeFi \u76d1\u63a7\u5e94\u7528\uff01</p>"},{"location":"zh/api/data-models/","title":"\u6570\u636e\u6a21\u578b\u53c2\u8003","text":"<p>Dexscreen \u4e2d\u7684\u6240\u6709\u6570\u636e\u6a21\u578b\u90fd\u662f Pydantic \u6a21\u578b\uff0c\u63d0\u4f9b\u81ea\u52a8\u9a8c\u8bc1\u548c\u7c7b\u578b\u5b89\u5168\u3002</p>"},{"location":"zh/api/data-models/#_2","title":"\u6838\u5fc3\u6a21\u578b","text":""},{"location":"zh/api/data-models/#tokenpair","title":"TokenPair","text":"<p>\u8868\u793a\u4ea4\u6613\u5bf9\u7684\u4e3b\u8981\u6a21\u578b\u3002\u5927\u591a\u6570\u67e5\u8be2\u548c\u6d41\u5f0f\u65b9\u6cd5\u90fd\u4f1a\u8fd4\u56de\u6b64\u6a21\u578b\u3002</p> <pre><code>class TokenPair(BaseModel):\n    chain_id: str                      # \u533a\u5757\u94fe\u6807\u8bc6\u7b26\n    dex_id: str                        # DEX \u6807\u8bc6\u7b26\n    url: str                           # DEXScreener URL\n    pair_address: str                  # \u4ea4\u6613\u5bf9\u5408\u7ea6\u5730\u5740\n    base_token: BaseToken              # \u57fa\u7840\u4ee3\u5e01\u4fe1\u606f\n    quote_token: BaseToken             # \u62a5\u4ef7\u4ee3\u5e01\u4fe1\u606f\n    price_native: float                # \u539f\u751f\u4ee3\u5e01\u4ef7\u683c\n    price_usd: Optional[float]         # USD \u4ef7\u683c\n    transactions: PairTransactionCounts # \u4ea4\u6613\u7edf\u8ba1\n    volume: VolumeChangePeriods        # \u4ea4\u6613\u91cf\u6570\u636e\n    price_change: PriceChangePeriods   # \u4ef7\u683c\u53d8\u5316\n    liquidity: Optional[Liquidity]     # \u6d41\u52a8\u6027\u4fe1\u606f\n    fdv: Optional[float]               # \u5b8c\u5168\u7a00\u91ca\u4f30\u503c\n    pair_created_at: Optional[datetime] # \u521b\u5efa\u65f6\u95f4\u6233\n</code></pre> <p>\u4f7f\u7528\u793a\u4f8b\uff1a</p> <pre><code>pair = client.get_pair_by_pair_address(\"ethereum\", \"0x88e6...\")\nif pair:\n    print(f\"\u4ea4\u6613\u5bf9: {pair.base_token.symbol}/{pair.quote_token.symbol}\")\n    print(f\"\u4ef7\u683c: ${pair.price_usd:,.4f}\")\n    print(f\"24\u5c0f\u65f6\u4ea4\u6613\u91cf: ${pair.volume.h24:,.0f}\")\n    print(f\"24\u5c0f\u65f6\u53d8\u5316: {pair.price_change.h24:+.2f}%\")\n</code></pre>"},{"location":"zh/api/data-models/#basetoken","title":"BaseToken","text":"<p>\u4ea4\u6613\u5bf9\u4e2d\u7684\u57fa\u672c\u4ee3\u5e01\u4fe1\u606f\u3002</p> <pre><code>class BaseToken(BaseModel):\n    address: str    # \u5408\u7ea6\u5730\u5740\n    name: str       # \u4ee3\u5e01\u540d\u79f0\n    symbol: str     # \u4ee3\u5e01\u7b26\u53f7\n</code></pre> <p>\u4f7f\u7528\u793a\u4f8b\uff1a</p> <pre><code># \u8bc6\u522b\u4ea4\u6613\u5bf9\u4e2d\u54ea\u4e2a\u662f USDC\nif pair.base_token.symbol == \"USDC\":\n    other_token = pair.quote_token\nelse:\n    other_token = pair.base_token\n\nprint(f\"\u4ea4\u6613 {other_token.symbol} \u5bf9 USDC\")\n</code></pre>"},{"location":"zh/api/data-models/#_3","title":"\u4ea4\u6613\u7edf\u8ba1","text":""},{"location":"zh/api/data-models/#transactioncount","title":"TransactionCount","text":"<p>\u4e70\u5165\u548c\u5356\u51fa\u4ea4\u6613\u8ba1\u6570\u3002</p> <pre><code>class TransactionCount(BaseModel):\n    buys: int      # \u4e70\u5165\u4ea4\u6613\u6570\u91cf\n    sells: int     # \u5356\u51fa\u4ea4\u6613\u6570\u91cf\n</code></pre>"},{"location":"zh/api/data-models/#pairtransactioncounts","title":"PairTransactionCounts","text":"<p>\u4e0d\u540c\u65f6\u95f4\u6bb5\u7684\u4ea4\u6613\u7edf\u8ba1\u3002</p> <pre><code>class PairTransactionCounts(BaseModel):\n    m5: TransactionCount    # 5 \u5206\u949f\n    h1: TransactionCount    # 1 \u5c0f\u65f6\n    h6: TransactionCount    # 6 \u5c0f\u65f6\n    h24: TransactionCount   # 24 \u5c0f\u65f6\n</code></pre> <p>\u4f7f\u7528\u793a\u4f8b\uff1a</p> <pre><code># \u5206\u6790\u4e70\u5356\u538b\u529b\nbuy_pressure = pair.transactions.h1.buys / (pair.transactions.h1.buys + pair.transactions.h1.sells)\nprint(f\"\u4e70\u5165\u538b\u529b (1\u5c0f\u65f6): {buy_pressure:.1%}\")\n\n# \u68c0\u67e5\u6700\u8fd1\u6d3b\u52a8\ntotal_5m = pair.transactions.m5.buys + pair.transactions.m5.sells\nprint(f\"\u6700\u8fd1 5 \u5206\u949f\u4ea4\u6613\u6570: {total_5m}\")\n</code></pre>"},{"location":"zh/api/data-models/#_4","title":"\u5e02\u573a\u6570\u636e","text":""},{"location":"zh/api/data-models/#volumechangeperiods","title":"VolumeChangePeriods","text":"<p>\u8de8\u65f6\u95f4\u6bb5\u7684 USD \u4ea4\u6613\u91cf\u3002</p> <pre><code>class VolumeChangePeriods(BaseModel):\n    m5: Optional[float] = 0.0    # 5 \u5206\u949f\u4ea4\u6613\u91cf\n    h1: Optional[float] = 0.0    # 1 \u5c0f\u65f6\u4ea4\u6613\u91cf\n    h6: Optional[float] = 0.0    # 6 \u5c0f\u65f6\u4ea4\u6613\u91cf\n    h24: Optional[float] = 0.0   # 24 \u5c0f\u65f6\u4ea4\u6613\u91cf\n</code></pre>"},{"location":"zh/api/data-models/#pricechangeperiods","title":"PriceChangePeriods","text":"<p>\u8de8\u65f6\u95f4\u6bb5\u7684\u4ef7\u683c\u53d8\u5316\u767e\u5206\u6bd4\u3002</p> <pre><code>class PriceChangePeriods(BaseModel):\n    m5: Optional[float] = 0.0    # 5 \u5206\u949f\u53d8\u5316 %\n    h1: Optional[float] = 0.0    # 1 \u5c0f\u65f6\u53d8\u5316 %\n    h6: Optional[float] = 0.0    # 6 \u5c0f\u65f6\u53d8\u5316 %\n    h24: Optional[float] = 0.0   # 24 \u5c0f\u65f6\u53d8\u5316 %\n</code></pre> <p>\u4f7f\u7528\u793a\u4f8b\uff1a</p> <pre><code># \u627e\u51fa\u8d8b\u52bf\u4ea4\u6613\u5bf9\nif pair.price_change.h1 &gt; 5 and pair.volume.h1 &gt; 100_000:\n    print(f\"\u4e0a\u5347\u8d8b\u52bf: {pair.base_token.symbol}\")\n\n# \u4ea4\u6613\u91cf\u5206\u6790\nvolume_acceleration = pair.volume.h1 / (pair.volume.h6 / 6)\nif volume_acceleration &gt; 2:\n    print(\"\u68c0\u6d4b\u5230\u4ea4\u6613\u91cf\u6fc0\u589e\uff01\")\n</code></pre>"},{"location":"zh/api/data-models/#liquidity","title":"Liquidity","text":"<p>\u4ea4\u6613\u5bf9\u7684\u6d41\u52a8\u6027\u4fe1\u606f\u3002</p> <pre><code>class Liquidity(BaseModel):\n    usd: Optional[float]    # USD \u603b\u6d41\u52a8\u6027\n    base: float             # \u57fa\u7840\u4ee3\u5e01\u6d41\u52a8\u6027\n    quote: float            # \u62a5\u4ef7\u4ee3\u5e01\u6d41\u52a8\u6027\n</code></pre> <p>\u4f7f\u7528\u793a\u4f8b\uff1a</p> <pre><code># \u6309\u6700\u4f4e\u6d41\u52a8\u6027\u8fc7\u6ee4\nif pair.liquidity and pair.liquidity.usd &gt; 50_000:\n    print(f\"\u6d41\u52a8\u6027\u5145\u8db3\u7684\u4ea4\u6613\u5bf9: ${pair.liquidity.usd:,.0f}\")\n\n# \u8ba1\u7b97\u4ee3\u5e01\u6570\u91cf\nprint(f\"\u6c60\u4e2d\u5305\u542b: {pair.liquidity.base:,.2f} {pair.base_token.symbol}\")\nprint(f\"\u6c60\u4e2d\u5305\u542b: {pair.liquidity.quote:,.2f} {pair.quote_token.symbol}\")\n</code></pre>"},{"location":"zh/api/data-models/#_5","title":"\u4ee3\u5e01\u4fe1\u606f","text":""},{"location":"zh/api/data-models/#tokeninfo","title":"TokenInfo","text":"<p>\u8be6\u7ec6\u7684\u4ee3\u5e01\u6863\u6848\u4fe1\u606f\u3002</p> <pre><code>class TokenInfo(BaseModel):\n    url: str                        # DEXScreener URL\n    chain_id: str                   # \u533a\u5757\u94fe\u6807\u8bc6\u7b26\n    token_address: str              # \u4ee3\u5e01\u5408\u7ea6\u5730\u5740\n    amount: float = 0.0             # \u63a8\u5e7f\u91d1\u989d\n    total_amount: float = 0.0       # \u603b\u63a8\u5e7f\u91d1\u989d\n    icon: Optional[str]             # \u56fe\u6807 URL\n    header: Optional[str]           # \u5934\u90e8\u56fe\u7247 URL\n    description: Optional[str]      # \u4ee3\u5e01\u63cf\u8ff0\n    links: List[TokenLink] = []     # \u76f8\u5173\u94fe\u63a5\n</code></pre>"},{"location":"zh/api/data-models/#tokenlink","title":"TokenLink","text":"<p>\u4e0e\u4ee3\u5e01\u76f8\u5173\u7684\u94fe\u63a5\u3002</p> <pre><code>class TokenLink(BaseModel):\n    type: Optional[str]     # \u94fe\u63a5\u7c7b\u578b\uff08website\u3001twitter \u7b49\uff09\n    label: Optional[str]    # \u663e\u793a\u6807\u7b7e\n    url: Optional[str]      # \u94fe\u63a5 URL\n</code></pre> <p>\u4f7f\u7528\u793a\u4f8b\uff1a</p> <pre><code># \u83b7\u53d6\u4ee3\u5e01\u6863\u6848\nprofiles = client.get_latest_token_profiles()\n\nfor token in profiles:\n    print(f\"\u4ee3\u5e01: {token.token_address}\")\n    print(f\"\u94fe: {token.chain_id}\")\n\n    if token.description:\n        print(f\"\u63cf\u8ff0: {token.description}\")\n\n    # \u663e\u793a\u793e\u4ea4\u94fe\u63a5\n    for link in token.links:\n        if link.type == \"twitter\":\n            print(f\"Twitter: {link.url}\")\n</code></pre>"},{"location":"zh/api/data-models/#orderinfo","title":"OrderInfo","text":"<p>\u4ee3\u5e01\u7684\u8ba2\u5355/\u652f\u4ed8\u4fe1\u606f\u3002</p> <pre><code>class OrderInfo(BaseModel):\n    type: str               # \u8ba2\u5355\u7c7b\u578b\n    status: str             # \u8ba2\u5355\u72b6\u6001\n    payment_timestamp: int  # \u652f\u4ed8\u65f6\u95f4\u6233\uff08\u6beb\u79d2\uff09\n</code></pre> <p>\u4f7f\u7528\u793a\u4f8b\uff1a</p> <pre><code>orders = client.get_orders_paid_of_token(\"ethereum\", token_address)\n\nfor order in orders:\n    timestamp = datetime.fromtimestamp(order.payment_timestamp / 1000)\n    print(f\"\u8ba2\u5355 {order.type}: {order.status} \u4e8e {timestamp}\")\n</code></pre>"},{"location":"zh/api/data-models/#_6","title":"\u5904\u7406\u53ef\u9009\u5b57\u6bb5","text":"<p>\u8bb8\u591a\u5b57\u6bb5\u662f\u53ef\u9009\u7684\uff0c\u53ef\u80fd\u4e3a None\u3002\u4f7f\u7528\u524d\u59cb\u7ec8\u68c0\u67e5\uff1a</p> <pre><code># \u5b89\u5168\u8bbf\u95ee\u6a21\u5f0f\nif pair.price_usd:\n    print(f\"\u4ef7\u683c: ${pair.price_usd}\")\nelse:\n    print(\"USD \u4ef7\u683c\u4e0d\u53ef\u7528\")\n\n# \u4f7f\u7528\u9ed8\u8ba4\u503c\nvolume_24h = pair.volume.h24 or 0\nliquidity_usd = pair.liquidity.usd if pair.liquidity else 0\n\n# \u94fe\u5f0f\u53ef\u9009\u68c0\u67e5\nif pair.liquidity and pair.liquidity.usd and pair.liquidity.usd &gt; 100_000:\n    print(\"\u9ad8\u6d41\u52a8\u6027\u4ea4\u6613\u5bf9\")\n</code></pre>"},{"location":"zh/api/data-models/#ide","title":"\u7c7b\u578b\u63d0\u793a\u548c IDE \u652f\u6301","text":"<p>\u6240\u6709\u6a21\u578b\u90fd\u6709\u5b8c\u6574\u7684\u7c7b\u578b\u63d0\u793a\uff0c\u63d0\u4f9b\u51fa\u8272\u7684 IDE \u652f\u6301\uff1a</p> <pre><code>from dexscreen import TokenPair, DexscreenerClient\n\ndef analyze_pair(pair: TokenPair) -&gt; dict:\n    \"\"\"\u5206\u6790\u4ea4\u6613\u5bf9\"\"\"\n    return {\n        \"symbol\": pair.base_token.symbol,\n        \"price\": pair.price_usd,\n        \"volume_24h\": pair.volume.h24,\n        \"liquidity\": pair.liquidity.usd if pair.liquidity else 0,\n        \"buy_pressure\": calculate_buy_pressure(pair.transactions)\n    }\n\ndef calculate_buy_pressure(txns: PairTransactionCounts) -&gt; float:\n    \"\"\"\u4ece\u4ea4\u6613\u4e2d\u8ba1\u7b97\u4e70\u5165\u538b\u529b\"\"\"\n    total = txns.h24.buys + txns.h24.sells\n    return txns.h24.buys / total if total &gt; 0 else 0.5\n</code></pre>"},{"location":"zh/api/data-models/#_7","title":"\u6a21\u578b\u9a8c\u8bc1","text":"<p>Pydantic \u81ea\u52a8\u9a8c\u8bc1\u6570\u636e\uff1a</p> <pre><code>from pydantic import ValidationError\n\ntry:\n    # \u8fd9\u5c06\u9a8c\u8bc1\u5931\u8d25\n    token = BaseToken(\n        address=\"invalid\",  # \u5e94\u8be5\u662f\u6709\u6548\u5730\u5740\n        name=\"\",           # \u4e0d\u5e94\u4e3a\u7a7a\n        symbol=\"\"          # \u4e0d\u5e94\u4e3a\u7a7a\n    )\nexcept ValidationError as e:\n    print(f\"\u9a8c\u8bc1\u9519\u8bef: {e}\")\n</code></pre>"},{"location":"zh/api/data-models/#json","title":"JSON \u5e8f\u5217\u5316","text":"<p>\u6240\u6709\u6a21\u578b\u90fd\u53ef\u4ee5\u8f7b\u677e\u5e8f\u5217\u5316\uff1a</p> <pre><code># \u8f6c\u6362\u4e3a\u5b57\u5178\npair_dict = pair.model_dump()\n\n# \u8f6c\u6362\u4e3a JSON \u5b57\u7b26\u4e32\npair_json = pair.model_dump_json()\n\n# \u6392\u9664 None \u503c\npair_dict = pair.model_dump(exclude_none=True)\n\n# \u4fdd\u5b58\u5230\u6587\u4ef6\nimport json\nwith open(\"pair_data.json\", \"w\") as f:\n    json.dump(pair.model_dump(), f, indent=2)\n</code></pre>"},{"location":"zh/api/filtering/","title":"\u8fc7\u6ee4\u914d\u7f6e","text":"<p>\u8fc7\u6ee4\u5141\u8bb8\u60a8\u63a7\u5236\u4f55\u65f6\u89e6\u53d1\u6d41\u5f0f\u56de\u8c03\uff0c\u51cf\u5c11\u566a\u97f3\u5e76\u4e13\u6ce8\u4e8e\u6709\u610f\u4e49\u7684\u53d8\u5316\u3002</p>"},{"location":"zh/api/filtering/#_2","title":"\u6982\u8ff0","text":"<p>\u8fc7\u6ee4\u7cfb\u7edf\u63d0\u4f9b\uff1a</p> <ul> <li>\u53d8\u5316\u68c0\u6d4b - \u4ec5\u5728\u5b9e\u9645\u6570\u636e\u53d8\u5316\u65f6\u89e6\u53d1</li> <li>\u9608\u503c\u8fc7\u6ee4 - \u4ec5\u5728\u663e\u8457\u53d8\u5316\u65f6\u89e6\u53d1</li> <li>\u901f\u7387\u9650\u5236 - \u63a7\u5236\u6700\u5927\u66f4\u65b0\u9891\u7387</li> <li>\u5b57\u6bb5\u9009\u62e9 - \u4ec5\u76d1\u63a7\u7279\u5b9a\u5b57\u6bb5</li> </ul>"},{"location":"zh/api/filtering/#filterconfig","title":"FilterConfig \u7c7b","text":"<p>\u7528\u4e8e\u7cbe\u786e\u63a7\u5236\u7684\u81ea\u5b9a\u4e49\u8fc7\u6ee4\u914d\u7f6e\u3002</p> <pre><code>from dataclasses import dataclass, field\nfrom typing import List, Optional\n\n@dataclass\nclass FilterConfig:\n    # \u8981\u76d1\u63a7\u53d8\u5316\u7684\u5b57\u6bb5\n    change_fields: List[str] = field(default_factory=lambda: [\n        \"price_usd\", \"price_native\", \"volume.h24\", \"liquidity.usd\"\n    ])\n\n    # \u53d8\u5316\u9608\u503c\uff08None = \u4efb\u4f55\u53d8\u5316\u90fd\u89e6\u53d1\uff09\n    price_change_threshold: Optional[float] = None      # \u4ef7\u683c\u53d8\u5316 %\uff08\u5982 0.01 = 1%\uff09\n    volume_change_threshold: Optional[float] = None     # \u4ea4\u6613\u91cf\u53d8\u5316 %\uff08\u5982 0.10 = 10%\uff09\n    liquidity_change_threshold: Optional[float] = None  # \u6d41\u52a8\u6027\u53d8\u5316 %\uff08\u5982 0.05 = 5%\uff09\n\n    # \u901f\u7387\u9650\u5236\n    max_updates_per_second: Optional[float] = None      # \u6700\u5927\u66f4\u65b0/\u79d2\uff08\u5982 1.0 = 1/\u79d2\uff09\n</code></pre>"},{"location":"zh/api/filtering/#_3","title":"\u53c2\u6570","text":"<ul> <li><code>change_fields</code>\uff1a\u8981\u76d1\u63a7\u7684\u5b57\u6bb5\u5217\u8868\u3002\u53ea\u6709\u8fd9\u4e9b\u5b57\u6bb5\u7684\u53d8\u5316\u624d\u80fd\u89e6\u53d1\u66f4\u65b0\u3002\u652f\u6301\u5d4c\u5957\u5b57\u6bb5\uff08\u5982 \"volume.h24\"\uff09</li> <li><code>price_change_threshold</code>\uff1a\u4ef7\u683c\u53d8\u5316\u767e\u5206\u6bd4\u9608\u503c\u3002\u8bbe\u7f6e\u4e3a 0.01 \u8868\u793a 1% \u7684\u53d8\u5316</li> <li><code>volume_change_threshold</code>\uff1a\u4ea4\u6613\u91cf\u53d8\u5316\u767e\u5206\u6bd4\u9608\u503c\u3002\u8bbe\u7f6e\u4e3a 0.10 \u8868\u793a 10% \u7684\u53d8\u5316</li> <li><code>liquidity_change_threshold</code>\uff1a\u6d41\u52a8\u6027\u53d8\u5316\u767e\u5206\u6bd4\u9608\u503c\u3002\u8bbe\u7f6e\u4e3a 0.05 \u8868\u793a 5% \u7684\u53d8\u5316</li> <li><code>max_updates_per_second</code>\uff1a\u9650\u5236\u66f4\u65b0\u9891\u7387\u4ee5\u907f\u514d\u56de\u8c03\u8fc7\u8f7d</li> </ul>"},{"location":"zh/api/filtering/#_4","title":"\u81ea\u5b9a\u4e49\u914d\u7f6e\u793a\u4f8b","text":"<pre><code>from dexscreen.utils import FilterConfig\n\n# \u9ad8\u9891\u4ea4\u6613\u914d\u7f6e\nhft_config = FilterConfig(\n    change_fields=[\"price_usd\"],           # \u4ec5\u76d1\u63a7\u4ef7\u683c\n    price_change_threshold=0.0001,         # 0.01% \u53d8\u5316\n    max_updates_per_second=10.0            # \u5141\u8bb8\u9891\u7e41\u66f4\u65b0\n)\n\n# \u957f\u671f\u76d1\u63a7\u914d\u7f6e\nhodl_config = FilterConfig(\n    change_fields=[\"price_usd\", \"liquidity.usd\"],\n    price_change_threshold=0.05,           # 5% \u53d8\u5316\n    liquidity_change_threshold=0.20,       # 20% \u6d41\u52a8\u6027\u53d8\u5316\n    max_updates_per_second=0.1             # \u6bcf 10 \u79d2\u6700\u591a\u4e00\u6b21\n)\n\n# \u4ea4\u6613\u91cf\u6fc0\u589e\u68c0\u6d4b\nvolume_config = FilterConfig(\n    change_fields=[\"volume.h24\", \"volume.h1\", \"transactions.m5.buys\", \"transactions.m5.sells\"],\n    volume_change_threshold=0.15,          # 15% \u4ea4\u6613\u91cf\u53d8\u5316\n    max_updates_per_second=0.5             # \u6bcf 2 \u79d2\u6700\u591a\u4e00\u6b21\n)\n</code></pre>"},{"location":"zh/api/filtering/#filterpresets","title":"FilterPresets","text":"<p>\u5e38\u89c1\u7528\u4f8b\u7684\u9884\u914d\u7f6e\u8fc7\u6ee4\u5668\u3002</p>"},{"location":"zh/api/filtering/#simple_change_detection","title":"simple_change_detection()","text":"<pre><code>config = FilterPresets.simple_change_detection()\n</code></pre> <p>\u57fa\u672c\u53d8\u5316\u68c0\u6d4b\uff08\u9ed8\u8ba4\u884c\u4e3a\uff09- \u4efb\u4f55\u76d1\u63a7\u5b57\u6bb5\u7684\u53d8\u5316\u90fd\u4f1a\u89e6\u53d1\u66f4\u65b0\u3002</p> <p>\u7528\u4e8e\uff1a\u9700\u8981\u6240\u6709\u53d8\u5316\u7684\u4e00\u822c\u76d1\u63a7</p>"},{"location":"zh/api/filtering/#significant_price_changesthreshold","title":"significant_price_changes(threshold)","text":"<pre><code>config = FilterPresets.significant_price_changes(0.01)  # 1% \u9608\u503c\n</code></pre> <p>\u4ec5\u5728\u4ef7\u683c\u53d8\u5316\u8d85\u8fc7\u9608\u503c\u65f6\u89e6\u53d1\u3002</p> <p>\u7528\u4e8e\uff1a\u4ef7\u683c\u8b66\u62a5\u3001\u4ea4\u6613\u4fe1\u53f7</p>"},{"location":"zh/api/filtering/#significant_all_changesprice_threshold-volume_threshold-liquidity_threshold","title":"significant_all_changes(price_threshold, volume_threshold, liquidity_threshold)","text":"<pre><code>config = FilterPresets.significant_all_changes(\n    price_threshold=0.005,      # 0.5% \u4ef7\u683c\u53d8\u5316\n    volume_threshold=0.10,      # 10% \u4ea4\u6613\u91cf\u53d8\u5316\n    liquidity_threshold=0.05    # 5% \u6d41\u52a8\u6027\u53d8\u5316\n)\n</code></pre> <p>\u6240\u6709\u6307\u6807\u5fc5\u987b\u6ee1\u8db3\u5176\u9608\u503c\u624d\u80fd\u89e6\u53d1\u3002</p> <p>\u7528\u4e8e\uff1a\u9700\u8981\u591a\u91cd\u786e\u8ba4\u7684\u9ad8\u7f6e\u4fe1\u5ea6\u4fe1\u53f7</p>"},{"location":"zh/api/filtering/#rate_limitedmax_per_second","title":"rate_limited(max_per_second)","text":"<pre><code>config = FilterPresets.rate_limited(1.0)  # \u6bcf\u79d2\u6700\u591a 1 \u6b21\u66f4\u65b0\n</code></pre> <p>\u9650\u5236\u66f4\u65b0\u9891\u7387\uff0c\u65e0\u8bba\u53d8\u5316\u5982\u4f55\u3002</p> <p>\u7528\u4e8e\uff1aUI \u66f4\u65b0\u3001\u51cf\u5c11\u56de\u8c03\u8d1f\u8f7d</p>"},{"location":"zh/api/filtering/#ui_friendly","title":"ui_friendly()","text":"<pre><code>config = FilterPresets.ui_friendly()\n</code></pre> <p>\u9488\u5bf9\u7528\u6237\u754c\u9762\u4f18\u5316\uff1a</p> <ul> <li>\u4ef7\u683c\u53d8\u5316\u9608\u503c\uff1a0.1%</li> <li>\u4ea4\u6613\u91cf\u53d8\u5316\u9608\u503c\uff1a5%</li> <li>\u6bcf\u79d2\u6700\u591a 2 \u6b21\u66f4\u65b0</li> </ul> <p>\u7528\u4e8e\uff1a\u4eea\u8868\u677f\u663e\u793a\u3001\u5b9e\u65f6\u56fe\u8868</p>"},{"location":"zh/api/filtering/#monitoring","title":"monitoring()","text":"<pre><code>config = FilterPresets.monitoring()\n</code></pre> <p>\u9488\u5bf9\u76d1\u63a7\u7cfb\u7edf\u4f18\u5316\uff1a</p> <ul> <li>\u4ef7\u683c\u53d8\u5316\u9608\u503c\uff1a1%</li> <li>\u4ea4\u6613\u91cf\u53d8\u5316\u9608\u503c\uff1a10%</li> <li>\u6d41\u52a8\u6027\u53d8\u5316\u9608\u503c\uff1a5%</li> <li>\u6bcf\u79d2\u6700\u591a 0.2 \u6b21\u66f4\u65b0\uff08\u6bcf 5 \u79d2\u4e00\u6b21\uff09</li> </ul> <p>\u7528\u4e8e\uff1a\u8b66\u62a5\u7cfb\u7edf\u3001\u540e\u53f0\u76d1\u63a7</p>"},{"location":"zh/api/filtering/#_5","title":"\u4f7f\u7528\u793a\u4f8b","text":""},{"location":"zh/api/filtering/#_6","title":"\u57fa\u672c\u8fc7\u6ee4","text":"<pre><code># \u9ed8\u8ba4\u8fc7\u6ee4\uff08\u4ec5\u53d8\u5316\uff09\nawait client.subscribe_pairs(\n    chain_id=\"ethereum\",\n    pair_addresses=[\"0x88e6...\"],\n    callback=handle_update,\n    filter=True  # \u9ed8\u8ba4\n)\n\n# \u65e0\u8fc7\u6ee4\uff08\u6240\u6709\u66f4\u65b0\uff09\nawait client.subscribe_pairs(\n    chain_id=\"ethereum\",\n    pair_addresses=[\"0x88e6...\"],\n    callback=handle_update,\n    filter=False\n)\n\n# \u9884\u8bbe\u8fc7\u6ee4\nawait client.subscribe_pairs(\n    chain_id=\"ethereum\",\n    pair_addresses=[\"0x88e6...\"],\n    callback=handle_update,\n    filter=FilterPresets.significant_price_changes(0.02)  # 2%\n)\n</code></pre>"},{"location":"zh/api/filtering/#_7","title":"\u9ad8\u7ea7\u8fc7\u6ee4","text":"<pre><code># \u591a\u6307\u6807\u76d1\u63a7\ncomprehensive_config = FilterConfig(\n    change_fields=[\"price_usd\", \"volume.h24\", \"liquidity.usd\", \"price_change.h24\"],\n    price_change_threshold=0.02,           # 2% \u4ef7\u683c\u53d8\u5316\n    volume_change_threshold=0.25,          # 25% \u4ea4\u6613\u91cf\u53d8\u5316\n    liquidity_change_threshold=0.10,       # 10% \u6d41\u52a8\u6027\u53d8\u5316\n    max_updates_per_second=1.0             # \u6bcf\u79d2\u6700\u591a\u4e00\u6b21\n)\n\nawait client.subscribe_pairs(\n    chain_id=\"ethereum\",\n    pair_addresses=addresses,\n    callback=comprehensive_handler,\n    filter=comprehensive_config\n)\n</code></pre>"},{"location":"zh/api/filtering/#_8","title":"\u6761\u4ef6\u8fc7\u6ee4","text":"<p>\u5c06\u8fc7\u6ee4\u4e0e\u56de\u8c03\u903b\u8f91\u7ed3\u5408\uff1a</p> <pre><code># \u663e\u8457\u53d8\u5316\u7684\u8fc7\u6ee4\u914d\u7f6e\nconfig = FilterConfig(\n    change_fields=[\"price_usd\", \"volume.h1\"],\n    price_change_threshold=0.001  # 0.1%\n)\n\n# \u56de\u8c03\u4e2d\u7684\u9644\u52a0\u903b\u8f91\ndef smart_callback(pair: TokenPair):\n    # \u8fc7\u6ee4\u5668\u5df2\u786e\u4fdd\u663e\u8457\u53d8\u5316\n    # \u6dfb\u52a0\u66f4\u591a\u6761\u4ef6\n    if pair.volume.h1 &gt; 10_000:  # \u6700\u5c0f\u4ea4\u6613\u91cf\n        if pair.liquidity and pair.liquidity.usd &gt; 50_000:  # \u6700\u5c0f\u6d41\u52a8\u6027\n            process_significant_update(pair)\n</code></pre>"},{"location":"zh/api/filtering/#_9","title":"\u53ef\u76d1\u63a7\u5b57\u6bb5","text":"<p>\u60a8\u53ef\u4ee5\u5728 <code>change_fields</code> \u4e2d\u76d1\u63a7\u7684\u5b57\u6bb5\uff1a</p>"},{"location":"zh/api/filtering/#_10","title":"\u4ef7\u683c\u5b57\u6bb5","text":"<ul> <li><code>price_usd</code> - USD \u4ef7\u683c</li> <li><code>price_native</code> - \u539f\u751f\u4ee3\u5e01\u4ef7\u683c</li> </ul>"},{"location":"zh/api/filtering/#_11","title":"\u4ea4\u6613\u91cf\u5b57\u6bb5","text":"<ul> <li><code>volume.h24</code> - 24\u5c0f\u65f6\u4ea4\u6613\u91cf</li> <li><code>volume.h6</code> - 6\u5c0f\u65f6\u4ea4\u6613\u91cf</li> <li><code>volume.h1</code> - 1\u5c0f\u65f6\u4ea4\u6613\u91cf</li> <li><code>volume.m5</code> - 5\u5206\u949f\u4ea4\u6613\u91cf</li> </ul>"},{"location":"zh/api/filtering/#_12","title":"\u6d41\u52a8\u6027\u5b57\u6bb5","text":"<ul> <li><code>liquidity.usd</code> - USD \u6d41\u52a8\u6027</li> <li><code>liquidity.base</code> - \u57fa\u7840\u4ee3\u5e01\u6d41\u52a8\u6027</li> <li><code>liquidity.quote</code> - \u62a5\u4ef7\u4ee3\u5e01\u6d41\u52a8\u6027</li> </ul>"},{"location":"zh/api/filtering/#_13","title":"\u4ea4\u6613\u5b57\u6bb5","text":"<ul> <li><code>transactions.m5.buys</code> - 5\u5206\u949f\u4e70\u5165\u6570</li> <li><code>transactions.m5.sells</code> - 5\u5206\u949f\u5356\u51fa\u6570</li> <li><code>transactions.h1.buys</code> - 1\u5c0f\u65f6\u4e70\u5165\u6570</li> <li><code>transactions.h1.sells</code> - 1\u5c0f\u65f6\u5356\u51fa\u6570</li> <li><code>transactions.h6.buys</code> - 6\u5c0f\u65f6\u4e70\u5165\u6570</li> <li><code>transactions.h6.sells</code> - 6\u5c0f\u65f6\u5356\u51fa\u6570</li> <li><code>transactions.h24.buys</code> - 24\u5c0f\u65f6\u4e70\u5165\u6570</li> <li><code>transactions.h24.sells</code> - 24\u5c0f\u65f6\u5356\u51fa\u6570</li> </ul>"},{"location":"zh/api/filtering/#_14","title":"\u4ef7\u683c\u53d8\u5316\u5b57\u6bb5","text":"<ul> <li><code>price_change.m5</code> - 5\u5206\u949f\u4ef7\u683c\u53d8\u5316 %</li> <li><code>price_change.h1</code> - 1\u5c0f\u65f6\u4ef7\u683c\u53d8\u5316 %</li> <li><code>price_change.h6</code> - 6\u5c0f\u65f6\u4ef7\u683c\u53d8\u5316 %</li> <li><code>price_change.h24</code> - 24\u5c0f\u65f6\u4ef7\u683c\u53d8\u5316 %</li> </ul>"},{"location":"zh/api/filtering/#_15","title":"\u5176\u4ed6\u5b57\u6bb5","text":"<ul> <li><code>fdv</code> - \u5b8c\u5168\u7a00\u91ca\u4f30\u503c</li> </ul> <p>\u6ce8\u610f\uff1a\u5bf9\u5d4c\u5957\u5b57\u6bb5\u4f7f\u7528\u70b9\u8868\u793a\u6cd5\uff08\u5982 <code>volume.h24</code>\u3001<code>transactions.m5.buys</code>\uff09</p>"},{"location":"zh/api/filtering/#_16","title":"\u6027\u80fd\u8003\u8651","text":""},{"location":"zh/api/filtering/#_17","title":"\u8fc7\u6ee4\u5668\u6548\u7387","text":"<p>\u8fc7\u6ee4\u5668\u5728\u83b7\u53d6\u6570\u636e\u540e\u5728\u5ba2\u6237\u7aef\u5e94\u7528\uff1a</p> <ol> <li>\u6570\u636e\u83b7\u53d6\uff1a\u5728\u6307\u5b9a\u95f4\u9694\u53d1\u751f</li> <li>\u53d8\u5316\u68c0\u6d4b\uff1a\u4e0e\u4e4b\u524d\u7684\u6570\u636e\u6bd4\u8f83</li> <li>\u9608\u503c\u68c0\u67e5\uff1a\u5e94\u7528\u914d\u7f6e\u7684\u9608\u503c</li> <li>\u901f\u7387\u9650\u5236\uff1a\u5f3a\u5236\u6267\u884c\u6700\u5927\u66f4\u65b0\u9891\u7387</li> <li>\u56de\u8c03\u6267\u884c\uff1a\u4ec5\u5728\u6240\u6709\u6761\u4ef6\u901a\u8fc7\u65f6</li> </ol>"},{"location":"zh/api/filtering/#_18","title":"\u4f18\u5316\u6280\u5de7","text":"<ol> <li>\u6700\u5c0f\u5316\u76d1\u63a7\u5b57\u6bb5\uff1a\u4ec5\u5305\u542b\u60a8\u5b9e\u9645\u9700\u8981\u7684\u5b57\u6bb5</li> </ol> <pre><code># \u597d - \u7279\u5b9a\u5b57\u6bb5\nchange_fields=[\"price_usd\", \"volume.h24\"]\n\n# \u574f - \u76d1\u63a7\u6240\u6709\u5185\u5bb9\nchange_fields=[\"price_usd\", \"price_native\", \"volume.h24\", \"volume.h6\", ...]\n</code></pre> <ol> <li>\u8bbe\u7f6e\u9002\u5f53\u7684\u9608\u503c\uff1a\u5728\u7075\u654f\u5ea6\u548c\u566a\u97f3\u4e4b\u95f4\u53d6\u5f97\u5e73\u8861</li> </ol> <pre><code># \u9ad8\u4ef7\u503c\u8d44\u4ea7 - \u8f83\u5927\u9608\u503c\neth_config = FilterConfig(price_change_threshold=0.01)  # 1%\n\n# \u4f4e\u4ef7\u503c/\u6ce2\u52a8\u8d44\u4ea7 - \u8f83\u5c0f\u9608\u503c\nmeme_config = FilterConfig(price_change_threshold=0.001)  # 0.1%\n</code></pre> <ol> <li>\u4f7f\u7528\u901f\u7387\u9650\u5236\uff1a\u9632\u6b62\u56de\u8c03\u8fc7\u8f7d</li> </ol> <pre><code># \u7528\u4e8e UI \u66f4\u65b0\nui_config = FilterConfig(max_updates_per_second=2.0)\n\n# \u7528\u4e8e\u65e5\u5fd7/\u6570\u636e\u5e93\ndb_config = FilterConfig(max_updates_per_second=0.1)  # \u6bcf 10 \u79d2\u4e00\u6b21\n</code></pre>"},{"location":"zh/api/filtering/#_19","title":"\u5e38\u89c1\u6a21\u5f0f","text":""},{"location":"zh/api/filtering/#_20","title":"\u4ef7\u683c\u8b66\u62a5\u7cfb\u7edf","text":"<pre><code># \u4e0d\u540c\u7684\u8b66\u62a5\u7ea7\u522b\nminor_alert = FilterConfig(\n    change_fields=[\"price_usd\"],\n    price_change_threshold=0.02,  # 2%\n    max_updates_per_second=1.0\n)\n\nmajor_alert = FilterConfig(\n    change_fields=[\"price_usd\"],\n    price_change_threshold=0.05,  # 5%\n    max_updates_per_second=None   # \u4e3b\u8981\u8b66\u62a5\u65e0\u901f\u7387\u9650\u5236\n)\n\n# \u4f7f\u7528\u4e0d\u540c\u7684\u56de\u8c03\u8ba2\u9605\nawait client.subscribe_pairs(chain_id, pairs, minor_callback, filter=minor_alert)\nawait client.subscribe_pairs(chain_id, pairs, major_callback, filter=major_alert)\n</code></pre>"},{"location":"zh/api/filtering/#_21","title":"\u591a\u7b56\u7565\u8fc7\u6ee4","text":"<pre><code>strategies = {\n    \"scalping\": FilterConfig(\n        change_fields=[\"price_usd\"],\n        price_change_threshold=0.0005,  # 0.05%\n        max_updates_per_second=10.0\n    ),\n    \"swing\": FilterConfig(\n        change_fields=[\"price_usd\", \"volume.h24\"],\n        price_change_threshold=0.02,    # 2%\n        volume_change_threshold=0.30,   # 30%\n        max_updates_per_second=0.2      # \u6bcf 5 \u79d2\u4e00\u6b21\n    ),\n    \"liquidity\": FilterConfig(\n        change_fields=[\"liquidity.usd\"],\n        liquidity_change_threshold=0.10,  # 10%\n        max_updates_per_second=0.1        # \u6bcf 10 \u79d2\u4e00\u6b21\n    )\n}\n\n# \u5bf9\u4e0d\u540c\u4ea4\u6613\u5bf9\u5e94\u7528\u4e0d\u540c\u7b56\u7565\nfor strategy_name, config in strategies.items():\n    pairs = get_pairs_for_strategy(strategy_name)\n    callback = create_strategy_callback(strategy_name)\n    await client.subscribe_pairs(\"ethereum\", pairs, callback, filter=config)\n</code></pre>"},{"location":"zh/api/query-api/","title":"\u67e5\u8be2 API \u53c2\u8003","text":"<p>\u67e5\u8be2 API \u63d0\u4f9b\u540c\u6b65\u548c\u5f02\u6b65\u65b9\u6cd5\u4ece Dexscreener \u83b7\u53d6\u6570\u636e\u3002\u6240\u6709\u65b9\u6cd5\u90fd\u6709\u540c\u6b65\u548c\u5f02\u6b65\u7248\u672c\u3002</p>"},{"location":"zh/api/query-api/#_1","title":"\u6982\u8ff0","text":"<p>\u67e5\u8be2\u65b9\u6cd5\u662f\u4e00\u6b21\u6027\u6570\u636e\u83b7\u53d6\uff0c\u7acb\u5373\u8fd4\u56de\u5f53\u524d\u6570\u636e\u3002\u5b83\u4eec\u9002\u7528\u4e8e\uff1a</p> <ul> <li>\u83b7\u53d6\u5f53\u524d\u4ef7\u683c</li> <li>\u641c\u7d22\u4ee3\u5e01</li> <li>\u83b7\u53d6\u4ea4\u6613\u5bf9\u4fe1\u606f</li> <li>\u68c0\u7d22\u4ee3\u5e01\u6863\u6848</li> </ul>"},{"location":"zh/api/query-api/#_2","title":"\u901f\u7387\u9650\u5236","text":"<ul> <li>\u4ea4\u6613\u5bf9\u67e5\u8be2\uff1a300 \u8bf7\u6c42/\u5206\u949f</li> <li>\u4ee3\u5e01\u6863\u6848/\u8ba2\u5355\uff1a60 \u8bf7\u6c42/\u5206\u949f</li> </ul> <p>SDK \u81ea\u52a8\u5904\u7406\u901f\u7387\u9650\u5236\u548c\u91cd\u8bd5\u903b\u8f91\u3002</p>"},{"location":"zh/api/query-api/#pair-queries","title":"\u4ea4\u6613\u5bf9\u67e5\u8be2 (Pair Queries)","text":""},{"location":"zh/api/query-api/#get_pair-get_pair_async","title":"get_pair / get_pair_async","text":"<pre><code>def get_pair(address: str) -&gt; Optional[TokenPair]\nasync def get_pair_async(address: str) -&gt; Optional[TokenPair]\n</code></pre> <p>\u83b7\u53d6\u5355\u4e2a\u4ea4\u6613\u5bf9\u4fe1\u606f\uff08\u901a\u8fc7\u641c\u7d22\u5b9e\u73b0\uff0c\u65e0\u9700\u6307\u5b9a\u94fe\uff09\u3002</p> <p>\u793a\u4f8b\uff1a</p> <pre><code># \u540c\u6b65\npair = client.get_pair(\"JUPyiwrYJFskUPiHa7hkeR8VUtAeFoSYbKedZNsDvCN\")\nif pair:\n    print(f\"{pair.base_token.symbol}: ${pair.price_usd}\")\n\n# \u5f02\u6b65\npair = await client.get_pair_async(\"JUPyiwrYJFskUPiHa7hkeR8VUtAeFoSYbKedZNsDvCN\")\n</code></pre>"},{"location":"zh/api/query-api/#get_pair_by_pair_address-get_pair_by_pair_address_async","title":"get_pair_by_pair_address / get_pair_by_pair_address_async","text":"<pre><code>def get_pair_by_pair_address(chain_id: str, pair_address: str) -&gt; Optional[TokenPair]\nasync def get_pair_by_pair_address_async(chain_id: str, pair_address: str) -&gt; Optional[TokenPair]\n</code></pre> <p>\u83b7\u53d6\u6307\u5b9a\u94fe\u4e0a\u7684\u4ea4\u6613\u5bf9\u4fe1\u606f\u3002</p> <p>\u53c2\u6570\uff1a</p> <ul> <li><code>chain_id</code>\uff1a\u533a\u5757\u94fe\u6807\u8bc6\u7b26\uff08\u5982 \"ethereum\"\u3001\"solana\"\u3001\"bsc\"\uff09</li> <li><code>pair_address</code>\uff1a\u4ea4\u6613\u5bf9\u5408\u7ea6\u5730\u5740</li> </ul> <p>\u793a\u4f8b\uff1a</p> <pre><code>pair = client.get_pair_by_pair_address(\n    \"ethereum\",\n    \"0x88e6a0c2ddd26feeb64f039a2c41296fcb3f5640\"  # USDC/WETH\n)\n</code></pre>"},{"location":"zh/api/query-api/#get_pairs_by_pairs_addresses-get_pairs_by_pairs_addresses_async","title":"get_pairs_by_pairs_addresses / get_pairs_by_pairs_addresses_async","text":"<pre><code>def get_pairs_by_pairs_addresses(chain_id: str, pair_addresses: List[str]) -&gt; List[TokenPair]\nasync def get_pairs_by_pairs_addresses_async(chain_id: str, pair_addresses: List[str]) -&gt; List[TokenPair]\n</code></pre> <p>\u6279\u91cf\u83b7\u53d6\u4ea4\u6613\u5bf9\u4fe1\u606f\uff08\u540c\u4e00\u94fe\uff09\u3002\u6700\u591a\u652f\u6301 30 \u4e2a\u5730\u5740\uff0c\u8d85\u8fc7\u5c06\u629b\u51fa ValueError\u3002</p> <p>\u793a\u4f8b\uff1a</p> <pre><code>pairs = client.get_pairs_by_pairs_addresses(\n    \"ethereum\",\n    [\n        \"0x88e6a0c2ddd26feeb64f039a2c41296fcb3f5640\",\n        \"0x11b815efb8f581194ae79006d24e0d814b7697f6\",\n        \"0x4e68ccd3e89f51c3074ca5072bbac773960dfa36\"\n    ]\n)\n</code></pre>"},{"location":"zh/api/query-api/#search_pairs-search_pairs_async","title":"search_pairs / search_pairs_async","text":"<pre><code>def search_pairs(query: str) -&gt; List[TokenPair]\nasync def search_pairs_async(query: str) -&gt; List[TokenPair]\n</code></pre> <p>\u641c\u7d22\u4ea4\u6613\u5bf9\uff08\u6309\u540d\u79f0\u3001\u7b26\u53f7\u6216\u5730\u5740\uff09\u3002</p> <p>\u793a\u4f8b\uff1a</p> <pre><code># \u6309\u7b26\u53f7\u641c\u7d22\nresults = client.search_pairs(\"PEPE\")\n\n# \u6309\u540d\u79f0\u641c\u7d22\nresults = client.search_pairs(\"Shiba Inu\")\n\n# \u6309\u5730\u5740\u641c\u7d22\nresults = client.search_pairs(\"0x88e6a0c2ddd26feeb64f039a2c41296fcb3f5640\")\n</code></pre>"},{"location":"zh/api/query-api/#get_pairs_by_token_address-get_pairs_by_token_address_async","title":"get_pairs_by_token_address / get_pairs_by_token_address_async","text":"<pre><code>def get_pairs_by_token_address(chain_id: str, token_address: str) -&gt; List[TokenPair]\nasync def get_pairs_by_token_address_async(chain_id: str, token_address: str) -&gt; List[TokenPair]\n</code></pre> <p>\u83b7\u53d6\u6307\u5b9a\u94fe\u4e0a\u5355\u4e2a\u4ee3\u5e01\u7684\u6240\u6709\u4ea4\u6613\u5bf9\u3002\u8fd4\u56de\u8be5\u4ee3\u5e01\u5728\u8be5\u94fe\u6240\u6709 DEX \u4e0a\u7684\u6240\u6709\u4ea4\u6613\u5bf9\u3002</p> <p>\u793a\u4f8b\uff1a</p> <pre><code># \u83b7\u53d6\u4ee5\u592a\u574a\u4e0a\u7684\u6240\u6709 USDC \u4ea4\u6613\u5bf9\nusdc_pairs = client.get_pairs_by_token_address(\n    \"ethereum\",\n    \"A0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\"  # USDC\n)\n\nfor pair in usdc_pairs:\n    other_token = pair.quote_token if pair.base_token.address.lower() == usdc_address.lower() else pair.base_token\n    print(f\"USDC/{other_token.symbol} \u5728 {pair.dex_id}: ${pair.price_usd}\")\n</code></pre>"},{"location":"zh/api/query-api/#get_pairs_by_token_addresses-get_pairs_by_token_addresses_async","title":"get_pairs_by_token_addresses / get_pairs_by_token_addresses_async","text":"<pre><code>def get_pairs_by_token_addresses(chain_id: str, token_addresses: List[str]) -&gt; List[TokenPair]\nasync def get_pairs_by_token_addresses_async(chain_id: str, token_addresses: List[str]) -&gt; List[TokenPair]\n</code></pre> <p>\u6279\u91cf\u83b7\u53d6\u6307\u5b9a\u94fe\u4e0a\u591a\u4e2a\u4ee3\u5e01\u7684\u6240\u6709\u4ea4\u6613\u5bf9\u3002\u8fd4\u56de\u6240\u6709\u5305\u542b\u4efb\u610f\u6307\u5b9a\u4ee3\u5e01\u7684\u4ea4\u6613\u5bf9\uff08\u53bb\u91cd\uff09\u3002</p> <p>\u6ce8\u610f\uff1a</p> <ul> <li>\u9700\u8981\u6307\u5b9a\u94fe ID\uff08\u5982 \"solana\"\u3001\"ethereum\" \u7b49\uff09</li> <li>\u6700\u591a\u652f\u6301 30 \u4e2a\u4ee3\u5e01\u5730\u5740\uff0c\u8d85\u8fc7\u5c06\u629b\u51fa ValueError</li> <li>API \u6700\u591a\u8fd4\u56de 30 \u4e2a\u4ea4\u6613\u5bf9\uff08\u6700\u76f8\u5173/\u6d3b\u8dc3\u7684\uff09</li> <li>\u8fd4\u56de\u7684\u662f\u6240\u6709\u5305\u542b\u8fd9\u4e9b\u4ee3\u5e01\u7684\u4ea4\u6613\u5bf9\u96c6\u5408\uff0c\u5982\u679c\u4e00\u4e2a\u4ea4\u6613\u5bf9\u5305\u542b\u591a\u4e2a\u6307\u5b9a\u7684\u4ee3\u5e01\uff08\u5982 USDC/SOL \u5bf9\u540c\u65f6\u5305\u542b USDC \u548c SOL\uff09\uff0c\u5b83\u53ea\u4f1a\u51fa\u73b0\u4e00\u6b21</li> </ul> <p>\u793a\u4f8b\uff1a</p> <pre><code># \u83b7\u53d6\u591a\u4e2a\u4ee3\u5e01\u7684\u4ea4\u6613\u5bf9\ntoken_addresses = [\n    \"A0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\",  # USDC\n    \"dac17f958d2ee523a2206206994597c13d831ec7\",  # USDT\n    \"6B175474E89094C44Da98b954EedeAC495271d0F\"   # DAI\n]\n\nstablecoin_pairs = client.get_pairs_by_token_addresses(\"ethereum\", token_addresses)\n</code></pre>"},{"location":"zh/api/query-api/#token-information","title":"\u4ee3\u5e01\u4fe1\u606f\u67e5\u8be2 (Token Information)","text":""},{"location":"zh/api/query-api/#get_latest_token_profiles-get_latest_token_profiles_async","title":"get_latest_token_profiles / get_latest_token_profiles_async","text":"<pre><code>def get_latest_token_profiles() -&gt; List[TokenInfo]\nasync def get_latest_token_profiles_async() -&gt; List[TokenInfo]\n</code></pre> <p>\u83b7\u53d6\u6700\u65b0\u4ee3\u5e01\u6863\u6848\u3002\u901f\u7387\u9650\u5236\uff1a60\u8bf7\u6c42/\u5206\u949f\u3002</p> <p>\u793a\u4f8b\uff1a</p> <pre><code>profiles = client.get_latest_token_profiles()\nfor token in profiles[:10]:\n    print(f\"{token.token_address}: {token.description}\")\n</code></pre>"},{"location":"zh/api/query-api/#get_latest_boosted_tokens-get_latest_boosted_tokens_async","title":"get_latest_boosted_tokens / get_latest_boosted_tokens_async","text":"<pre><code>def get_latest_boosted_tokens() -&gt; List[TokenInfo]\nasync def get_latest_boosted_tokens_async() -&gt; List[TokenInfo]\n</code></pre> <p>\u83b7\u53d6\u6700\u65b0\u63a8\u5e7f\u4ee3\u5e01\u3002\u901f\u7387\u9650\u5236\uff1a60\u8bf7\u6c42/\u5206\u949f\u3002</p> <p>\u793a\u4f8b\uff1a</p> <pre><code>boosted = client.get_latest_boosted_tokens()\nfor token in boosted:\n    print(f\"{token.chain_id}: {token.token_address} - \u63a8\u5e7f: {token.amount}\")\n</code></pre>"},{"location":"zh/api/query-api/#get_tokens_most_active-get_tokens_most_active_async","title":"get_tokens_most_active / get_tokens_most_active_async","text":"<pre><code>def get_tokens_most_active() -&gt; List[TokenInfo]\nasync def get_tokens_most_active_async() -&gt; List[TokenInfo]\n</code></pre> <p>\u83b7\u53d6\u6700\u6d3b\u8dc3\u63a8\u5e7f\u4ee3\u5e01\u3002\u901f\u7387\u9650\u5236\uff1a60\u8bf7\u6c42/\u5206\u949f\u3002</p>"},{"location":"zh/api/query-api/#pool-information","title":"\u6c60\u4fe1\u606f\u67e5\u8be2 (Pool Information)","text":""},{"location":"zh/api/query-api/#get_pools_by_token_address-get_pools_by_token_address_async","title":"get_pools_by_token_address / get_pools_by_token_address_async","text":"<pre><code>def get_pools_by_token_address(chain_id: str, token_address: str) -&gt; List[TokenPair]\nasync def get_pools_by_token_address_async(chain_id: str, token_address: str) -&gt; List[TokenPair]\n</code></pre> <p>\u4f7f\u7528 token-pairs/v1 \u7aef\u70b9\u83b7\u53d6\u6c60\u4fe1\u606f\u3002\u4e0e get_pairs_by_pairs_addresses \u7c7b\u4f3c\uff0c\u4f46\u4f7f\u7528\u4e0d\u540c\u7684 API \u7aef\u70b9\u3002\u901f\u7387\u9650\u5236\uff1a300\u8bf7\u6c42/\u5206\u949f\u3002</p>"},{"location":"zh/api/query-api/#order-queries","title":"\u8ba2\u5355\u67e5\u8be2 (Order Queries)","text":""},{"location":"zh/api/query-api/#get_orders_paid_of_token-get_orders_paid_of_token_async","title":"get_orders_paid_of_token / get_orders_paid_of_token_async","text":"<pre><code>def get_orders_paid_of_token(chain_id: str, token_address: str) -&gt; List[OrderInfo]\nasync def get_orders_paid_of_token_async(chain_id: str, token_address: str) -&gt; List[OrderInfo]\n</code></pre> <p>\u83b7\u53d6\u4ee3\u5e01\u4ed8\u8d39\u8ba2\u5355\u3002\u901f\u7387\u9650\u5236\uff1a60\u8bf7\u6c42/\u5206\u949f\u3002</p> <p>\u793a\u4f8b\uff1a</p> <pre><code>orders = client.get_orders_paid_of_token(\"ethereum\", token_address)\nfor order in orders:\n    print(f\"\u8ba2\u5355 {order.type}: {order.status} \u4e8e {order.payment_timestamp}\")\n</code></pre>"},{"location":"zh/api/query-api/#_3","title":"\u6700\u4f73\u5b9e\u8df5","text":""},{"location":"zh/api/query-api/#1","title":"1. \u591a\u67e5\u8be2\u4f7f\u7528\u5f02\u6b65","text":"<p>\u83b7\u53d6\u591a\u4e2a\u4ee3\u5e01/\u4ea4\u6613\u5bf9\u6570\u636e\u65f6\uff0c\u4f7f\u7528\u5f02\u6b65\u65b9\u6cd5\uff1a</p> <pre><code>import asyncio\n\nasync def fetch_multiple_tokens():\n    client = DexscreenerClient()\n\n    tokens = [\"address1\", \"address2\", \"address3\"]\n\n    # \u5e76\u53d1\u83b7\u53d6\n    tasks = [\n        client.get_pairs_by_token_address_async(\"ethereum\", addr)\n        for addr in tokens\n    ]\n\n    results = await asyncio.gather(*tasks)\n    return results\n</code></pre>"},{"location":"zh/api/query-api/#2","title":"2. \u5904\u7406\u901f\u7387\u9650\u5236","text":"<p>SDK \u81ea\u52a8\u5904\u7406\u901f\u7387\u9650\u5236\uff0c\u4f46\u60a8\u4e5f\u53ef\u4ee5\u4e3b\u52a8\u5904\u7406\uff1a</p> <pre><code># \u4e3a\u4ee3\u5e01\u6863\u6848\u8bf7\u6c42\u7559\u51fa\u95f4\u9694\uff0860/\u5206\u949f\u9650\u5236\uff09\nimport time\n\nfor token_address in large_token_list:\n    orders = client.get_orders_paid_of_token(\"ethereum\", token_address)\n    process_orders(orders)\n    time.sleep(1.1)  # \u5b89\u5168\u8d77\u89c1\u7ea6 54 \u8bf7\u6c42\u6bcf\u5206\u949f\n</code></pre>"},{"location":"zh/api/query-api/#3","title":"3. \u9519\u8bef\u5904\u7406","text":"<p>\u59cb\u7ec8\u5904\u7406\u6f5c\u5728\u7684 None \u8fd4\u56de\uff1a</p> <pre><code>pair = client.get_pair_by_pair_address(\"ethereum\", pair_address)\nif pair:\n    # \u5904\u7406\u4ea4\u6613\u5bf9\u6570\u636e\n    print(f\"\u4ef7\u683c: ${pair.price_usd}\")\nelse:\n    print(f\"\u672a\u627e\u5230\u4ea4\u6613\u5bf9 {pair_address}\")\n</code></pre>"},{"location":"zh/api/query-api/#4","title":"4. \u6279\u91cf\u64cd\u4f5c","text":"<p>\u5bf9\u4e8e\u540c\u4e00\u94fe\u4e0a\u7684\u591a\u4e2a\u5730\u5740\uff0c\u4f7f\u7528\u6279\u91cf\u65b9\u6cd5\uff1a</p> <pre><code># \u4e0d\u8981\u8fd9\u6837\u505a\uff1a\npairs = []\nfor address in addresses:\n    pair = client.get_pair_by_pair_address(\"ethereum\", address)\n    if pair:\n        pairs.append(pair)\n\n# \u5e94\u8be5\u8fd9\u6837\u505a\uff1a\npairs = client.get_pairs_by_pairs_addresses(\"ethereum\", addresses)\n</code></pre>"},{"location":"zh/api/query-api/#_4","title":"\u5e38\u89c1\u6a21\u5f0f","text":""},{"location":"zh/api/query-api/#_5","title":"\u5bfb\u627e\u5957\u5229\u673a\u4f1a","text":"<pre><code>async def find_arbitrage(token_address: str):\n    client = DexscreenerClient()\n\n    # \u83b7\u53d6\u591a\u6761\u94fe\u4e0a\u7684\u4ea4\u6613\u5bf9\n    chains = [\"ethereum\", \"bsc\", \"polygon\", \"arbitrum\"]\n\n    tasks = [\n        client.get_pairs_by_token_address_async(chain, token_address)\n        for chain in chains\n    ]\n\n    all_pairs = await asyncio.gather(*tasks)\n\n    # \u6241\u5e73\u5316\u5e76\u5206\u6790\n    prices_by_chain = {}\n    for chain, pairs in zip(chains, all_pairs):\n        if pairs:\n            # \u83b7\u53d6\u6d41\u52a8\u6027\u6700\u9ad8\u7684\u4ea4\u6613\u5bf9\n            best_pair = max(pairs, key=lambda p: p.liquidity.usd or 0)\n            prices_by_chain[chain] = best_pair.price_usd\n\n    # \u5bfb\u627e\u5957\u5229\u673a\u4f1a\n    if len(prices_by_chain) &gt; 1:\n        min_price = min(prices_by_chain.values())\n        max_price = max(prices_by_chain.values())\n        spread = ((max_price - min_price) / min_price) * 100\n\n        if spread &gt; 1:  # 1% \u9608\u503c\n            print(f\"\u5957\u5229\u673a\u4f1a: {spread:.2f}% \u4ef7\u5dee\")\n            return prices_by_chain\n</code></pre>"},{"location":"zh/api/query-api/#_6","title":"\u4ee3\u5e01\u53d1\u73b0","text":"<pre><code>def discover_new_tokens():\n    client = DexscreenerClient()\n\n    # \u83b7\u53d6\u6700\u65b0\u6863\u6848\n    profiles = client.get_latest_token_profiles()\n\n    # \u8fc7\u6ee4\u6709\u8da3\u7684\u4ee3\u5e01\n    interesting = []\n    for token in profiles:\n        # \u83b7\u53d6\u4ea4\u6613\u6570\u636e\n        pairs = client.get_pairs_by_token_address(token.chain_id, token.token_address)\n\n        if pairs:\n            total_volume = sum(p.volume.h24 for p in pairs if p.volume.h24)\n            total_liquidity = sum(p.liquidity.usd for p in pairs if p.liquidity and p.liquidity.usd)\n\n            if total_volume &gt; 100_000 and total_liquidity &gt; 50_000:\n                interesting.append({\n                    'token': token,\n                    'pairs': pairs,\n                    'volume': total_volume,\n                    'liquidity': total_liquidity\n                })\n\n    return interesting\n</code></pre>"},{"location":"zh/api/streaming-api/","title":"\u6d41\u5f0f API \u53c2\u8003","text":"<p>\u6d41\u5f0f API \u901a\u8fc7 HTTP \u8f6e\u8be2\u63d0\u4f9b\u5b9e\u65f6\u6570\u636e\u66f4\u65b0\uff0c\u652f\u6301\u52a8\u6001\u8ba2\u9605\u7ba1\u7406\u3001\u7075\u6d3b\u8fc7\u6ee4\u548c\u591a\u94fe\u76d1\u63a7\u3002</p>"},{"location":"zh/api/streaming-api/#_1","title":"\u6982\u8ff0","text":"<p>\u6d41\u5f0f\u65b9\u6cd5\u63d0\u4f9b\u4ef7\u683c\u53d8\u5316\u3001\u4ea4\u6613\u91cf\u3001\u6d41\u52a8\u6027\u548c\u5176\u4ed6\u6307\u6807\u7684\u6301\u7eed\u66f4\u65b0\u3002\u5b83\u4eec\u9002\u7528\u4e8e\uff1a</p> <ul> <li>\u5b9e\u65f6\u4ef7\u683c\u76d1\u63a7</li> <li>\u5957\u5229\u68c0\u6d4b</li> <li>\u6295\u8d44\u7ec4\u5408\u8ddf\u8e2a</li> <li>\u65b0\u4ea4\u6613\u5bf9\u53d1\u73b0</li> <li>\u8b66\u62a5\u7cfb\u7edf</li> </ul>"},{"location":"zh/api/streaming-api/#_2","title":"\u6838\u5fc3\u529f\u80fd","text":""},{"location":"zh/api/streaming-api/#_3","title":"\u52a8\u6001\u8ba2\u9605\u7ba1\u7406","text":"<pre><code># 1. \u521d\u59cb\u8ba2\u9605\nawait client.subscribe_pairs(\"ethereum\", [\"0xaaa...\"], callback)\n\n# 2. \u6dfb\u52a0\u66f4\u591a\u8ba2\u9605\uff08\u7d2f\u79ef\uff0c\u4e0d\u662f\u66ff\u6362\uff09\nawait client.subscribe_pairs(\"ethereum\", [\"0xbbb...\", \"0xccc...\"], callback)\n\n# 3. \u79fb\u9664\u7279\u5b9a\u8ba2\u9605\nawait client.unsubscribe_pairs(\"ethereum\", [\"0xaaa...\"])\n\n# 4. \u67e5\u770b\u6d3b\u52a8\u8ba2\u9605\nactive = client.get_active_subscriptions()\n</code></pre>"},{"location":"zh/api/streaming-api/#_4","title":"\u591a\u94fe\u652f\u6301","text":"<pre><code># \u4f7f\u7528\u72ec\u7acb\u914d\u7f6e\u540c\u65f6\u76d1\u63a7\u591a\u6761\u94fe\nawait client.subscribe_pairs(\"ethereum\", eth_pairs, eth_callback, interval=1.0)\nawait client.subscribe_pairs(\"solana\", sol_pairs, sol_callback, interval=0.2)\nawait client.subscribe_pairs(\"bsc\", bsc_pairs, bsc_callback, interval=0.5)\n</code></pre>"},{"location":"zh/api/streaming-api/#_5","title":"\u4e3b\u8981\u65b9\u6cd5","text":""},{"location":"zh/api/streaming-api/#subscribe_pairs","title":"subscribe_pairs","text":"<pre><code>async def subscribe_pairs(\n    chain_id: str,\n    pair_addresses: List[str],\n    callback: Callable[[TokenPair], None],\n    *,\n    filter: Union[bool, FilterConfig] = True,\n    interval: float = 0.2\n) -&gt; None\n</code></pre> <p>\u8ba2\u9605\u5b9e\u65f6\u4ea4\u6613\u5bf9\u66f4\u65b0\u3002\u652f\u6301\u52a8\u6001\u6dfb\u52a0 - \u591a\u6b21\u8c03\u7528\u4f1a\u7d2f\u79ef\u8ba2\u9605\u800c\u4e0d\u662f\u66ff\u6362\u3002</p> <p>\u53c2\u6570\uff1a</p> <ul> <li><code>chain_id</code>\uff1a\u533a\u5757\u94fe\u6807\u8bc6\u7b26\uff08\u5982 \"ethereum\"\u3001\"solana\"\uff09</li> <li><code>pair_addresses</code>\uff1a\u4ea4\u6613\u5bf9\u5408\u7ea6\u5730\u5740\u5217\u8868</li> <li><code>callback</code>\uff1a\u6bcf\u6b21\u66f4\u65b0\u65f6\u8c03\u7528\u7684\u51fd\u6570\uff0c\u63a5\u6536 TokenPair \u5bf9\u8c61</li> <li><code>filter</code>\uff1a\u8fc7\u6ee4\u914d\u7f6e\uff1a</li> <li><code>True</code>\uff08\u9ed8\u8ba4\uff09\uff1a\u4ec5\u5728\u6570\u636e\u53d8\u5316\u65f6\u89e6\u53d1</li> <li><code>False</code>\uff1a\u89e6\u53d1\u6240\u6709\u8f6e\u8be2\u7ed3\u679c</li> <li><code>FilterConfig</code> \u5bf9\u8c61\uff1a\u81ea\u5b9a\u4e49\u8fc7\u6ee4\u89c4\u5219</li> <li><code>interval</code>\uff1a\u8f6e\u8be2\u95f4\u9694\uff08\u79d2\uff09\uff08\u9ed8\u8ba4 0.2 \u79d2\uff09</li> </ul> <p>\u4f7f\u7528\u793a\u4f8b\uff1a</p> <pre><code># \u793a\u4f8b 1\uff1a\u5b9e\u65f6\u4ef7\u683c\u76d1\u63a7\nawait client.subscribe_pairs(\n    \"ethereum\",\n    [\"0x88e6a0c2ddd26feeb64f039a2c41296fcb3f5640\"],  # USDC/ETH\n    price_monitor_callback,\n    filter=FilterPresets.significant_price_changes(0.001),  # 0.1% \u53d8\u5316\n    interval=0.5\n)\n\n# \u793a\u4f8b 2\uff1a\u5957\u5229\u76d1\u63a7\uff08\u591a\u4e2a DEX\uff09\ndex_pairs = [\"0xaaa...\", \"0xbbb...\", \"0xccc...\"]  # \u4e0d\u540c DEX \u4e0a\u7684\u540c\u4e00\u4ee3\u5e01\nawait client.subscribe_pairs(\n    \"ethereum\",\n    dex_pairs,\n    arbitrage_callback,\n    filter=False,  # \u9700\u8981\u6240\u6709\u66f4\u65b0\n    interval=0.2   # \u6700\u5feb\u901f\u5ea6\n)\n\n# \u793a\u4f8b 3\uff1a\u6295\u8d44\u7ec4\u5408\u8ddf\u8e2a\nportfolio_config = FilterConfig(\n    change_fields=[\"price_usd\", \"volume.h24\"],\n    price_change_threshold=0.02,  # 2% \u53d8\u5316\u9608\u503c\n    max_updates_per_second=0.5    # \u6bcf 2 \u79d2\u6700\u591a 1 \u6b21\u66f4\u65b0\n)\nawait client.subscribe_pairs(\n    \"ethereum\",\n    portfolio_pairs,\n    portfolio_callback,\n    filter=portfolio_config,\n    interval=5.0  # \u6bcf 5 \u79d2\u68c0\u67e5\n)\n</code></pre>"},{"location":"zh/api/streaming-api/#subscribe_tokens","title":"subscribe_tokens","text":"<pre><code>async def subscribe_tokens(\n    chain_id: str,\n    token_addresses: List[str],\n    callback: Callable[[List[TokenPair]], None],\n    *,\n    filter: Union[bool, FilterConfig] = True,\n    interval: float = 0.2\n) -&gt; None\n</code></pre> <p>\u8ba2\u9605\u7279\u5b9a\u4ee3\u5e01\u7684\u6240\u6709\u4ea4\u6613\u5bf9\u3002\u81ea\u52a8\u53d1\u73b0\u65b0\u4ea4\u6613\u5bf9 - \u9002\u5408\u5168\u9762\u7684\u4ee3\u5e01\u76d1\u63a7\u3002</p> <p>\u53c2\u6570\uff1a</p> <ul> <li><code>chain_id</code>\uff1a\u533a\u5757\u94fe\u6807\u8bc6\u7b26</li> <li><code>token_addresses</code>\uff1a\u4ee3\u5e01\u5408\u7ea6\u5730\u5740\u5217\u8868</li> <li><code>callback</code>\uff1a\u63a5\u6536\u4ee3\u5e01\u6240\u6709\u4ea4\u6613\u5bf9\u5217\u8868\u7684\u51fd\u6570</li> <li><code>filter</code>\uff1a\u8fc7\u6ee4\u914d\u7f6e\uff08\u4e0e subscribe_pairs \u76f8\u540c\uff09</li> <li><code>interval</code>\uff1a\u8f6e\u8be2\u95f4\u9694\uff08\u79d2\uff09</li> </ul> <p>\u4f7f\u7528\u793a\u4f8b\uff1a</p> <pre><code># \u793a\u4f8b 1\uff1a\u76d1\u63a7\u65b0\u4ee3\u5e01\u53d1\u5e03\nawait client.subscribe_tokens(\n    \"solana\",\n    [\"NewTokenAddress...\"],\n    new_token_callback,\n    filter=False,  # \u83b7\u53d6\u6240\u6709\u66f4\u65b0\u4ee5\u53d1\u73b0\u65b0\u4ea4\u6613\u5bf9\n    interval=0.5\n)\n\n# \u793a\u4f8b 2\uff1a\u7a33\u5b9a\u5e01\u6d41\u52a8\u6027\u76d1\u63a7\nawait client.subscribe_tokens(\n    \"ethereum\",\n    [\"A0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\"],  # USDC\n    liquidity_callback,\n    filter=FilterConfig(\n        change_fields=[\"liquidity.usd\"],\n        liquidity_change_threshold=0.05  # 5% \u6d41\u52a8\u6027\u53d8\u5316\n    ),\n    interval=2.0\n)\n\n# \u793a\u4f8b 3\uff1a\u8de8 DEX \u4ef7\u683c\u6bd4\u8f83\ndef compare_prices_callback(pairs: List[TokenPair]):\n    # \u6309 DEX \u5206\u7ec4\u5e76\u67e5\u627e\u4ef7\u683c\u5dee\u5f02\n    by_dex = {}\n    for pair in pairs:\n        if pair.dex_id not in by_dex:\n            by_dex[pair.dex_id] = []\n        by_dex[pair.dex_id].append(pair)\n    # \u5206\u6790\u4ef7\u683c\u5dee\u5f02...\n\nawait client.subscribe_tokens(\"bsc\", [\"TokenAddress...\"], compare_prices_callback)\n</code></pre>"},{"location":"zh/api/streaming-api/#unsubscribe_pairs","title":"unsubscribe_pairs","text":"<pre><code>async def unsubscribe_pairs(chain_id: str, pair_addresses: List[str]) -&gt; None\n</code></pre> <p>\u79fb\u9664\u7279\u5b9a\u4ea4\u6613\u5bf9\u8ba2\u9605\u3002\u5fc5\u987b\u6307\u5b9a\u6b63\u786e\u7684 chain_id\u3002</p> <pre><code># \u79fb\u9664\u5355\u4e2a\u8ba2\u9605\nawait client.unsubscribe_pairs(\"ethereum\", [\"0xaaa...\"])\n\n# \u6279\u91cf\u79fb\u9664\nawait client.unsubscribe_pairs(\"ethereum\", [\"0xaaa...\", \"0xbbb...\", \"0xccc...\"])\n\n# \u6ce8\u610f\uff1achain_id \u5fc5\u987b\u5339\u914d\n# \u8fd9\u4e0d\u4f1a\u5f71\u54cd\u4efb\u4f55\u8ba2\u9605\uff08\u4e0d\u540c\u7684 chain_id\uff09\nawait client.unsubscribe_pairs(\"bsc\", [\"0xaaa...\"])\n</code></pre>"},{"location":"zh/api/streaming-api/#unsubscribe_tokens","title":"unsubscribe_tokens","text":"<pre><code>async def unsubscribe_tokens(chain_id: str, token_addresses: List[str]) -&gt; None\n</code></pre> <p>\u79fb\u9664\u7279\u5b9a\u4ee3\u5e01\u7684\u6240\u6709\u4ea4\u6613\u5bf9\u8ba2\u9605\u3002</p> <pre><code># \u505c\u6b62\u76d1\u63a7 USDC\nawait client.unsubscribe_tokens(\n    \"ethereum\",\n    [\"A0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\"]\n)\n</code></pre>"},{"location":"zh/api/streaming-api/#close_streams","title":"close_streams","text":"<pre><code>async def close_streams() -&gt; None\n</code></pre> <p>\u5173\u95ed\u6240\u6709\u8ba2\u9605\u548c\u6d41\u8fde\u63a5\u3002\u901a\u5e38\u5728\u7a0b\u5e8f\u9000\u51fa\u65f6\u8c03\u7528\u3002</p> <pre><code>try:\n    # \u8fd0\u884c\u8ba2\u9605...\n    await client.subscribe_pairs(...)\nfinally:\n    # \u786e\u4fdd\u6e05\u7406\n    await client.close_streams()\n</code></pre>"},{"location":"zh/api/streaming-api/#_6","title":"\u7ba1\u7406\u65b9\u6cd5","text":""},{"location":"zh/api/streaming-api/#get_active_subscriptions","title":"get_active_subscriptions","text":"<pre><code>def get_active_subscriptions() -&gt; List[Dict[str, Any]]\n</code></pre> <p>\u83b7\u53d6\u6240\u6709\u6d3b\u52a8\u8ba2\u9605\u7684\u8be6\u7ec6\u4fe1\u606f\u3002</p> <pre><code># \u67e5\u770b\u6240\u6709\u8ba2\u9605\nactive = client.get_active_subscriptions()\nfor sub in active:\n    if sub[\"type\"] == \"pair\":\n        print(f\"\u4ea4\u6613\u5bf9: {sub['chain_id']}:{sub['pair_address']}\")\n    else:\n        print(f\"\u4ee3\u5e01: {sub['chain_id']}:{sub['token_address']}\")\n\n# \u8fd4\u56de\u683c\u5f0f\u793a\u4f8b\n[\n    {\n        \"type\": \"pair\",\n        \"chain_id\": \"ethereum\",\n        \"pair_address\": \"0x88e6...\",\n        \"filter\": True,\n        \"interval\": 1.0\n    },\n    {\n        \"type\": \"token\",\n        \"chain_id\": \"solana\",\n        \"token_address\": \"EPjFW...\",\n        \"filter\": FilterConfig(...),\n        \"interval\": 0.2\n    }\n]\n</code></pre>"},{"location":"zh/api/streaming-api/#_7","title":"\u9ad8\u7ea7\u7528\u6cd5","text":""},{"location":"zh/api/streaming-api/#_8","title":"\u5b8c\u6574\u8ba2\u9605\u751f\u547d\u5468\u671f\u7ba1\u7406","text":"<pre><code>class PortfolioManager:\n    def __init__(self):\n        self.client = DexscreenerClient()\n        self.active_pairs = set()\n\n    async def add_pair(self, chain_id: str, pair_address: str):\n        \"\"\"\u52a8\u6001\u6dfb\u52a0\u4ea4\u6613\u5bf9\u5230\u6295\u8d44\u7ec4\u5408\"\"\"\n        if (chain_id, pair_address) not in self.active_pairs:\n            await self.client.subscribe_pairs(\n                chain_id,\n                [pair_address],\n                self.handle_update,\n                filter=FilterPresets.monitoring()\n            )\n            self.active_pairs.add((chain_id, pair_address))\n\n    async def remove_pair(self, chain_id: str, pair_address: str):\n        \"\"\"\u4ece\u6295\u8d44\u7ec4\u5408\u79fb\u9664\u4ea4\u6613\u5bf9\"\"\"\n        if (chain_id, pair_address) in self.active_pairs:\n            await self.client.unsubscribe_pairs(chain_id, [pair_address])\n            self.active_pairs.remove((chain_id, pair_address))\n\n    def handle_update(self, pair: TokenPair):\n        \"\"\"\u5904\u7406\u4ef7\u683c\u66f4\u65b0\"\"\"\n        # \u5b9e\u73b0\u60a8\u7684\u903b\u8f91\n        pass\n\n# \u4f7f\u7528\u793a\u4f8b\nmanager = PortfolioManager()\n\n# \u52a8\u6001\u7ba1\u7406\nawait manager.add_pair(\"ethereum\", \"0xaaa...\")\nawait manager.add_pair(\"ethereum\", \"0xbbb...\")\nawait manager.remove_pair(\"ethereum\", \"0xaaa...\")\n</code></pre>"},{"location":"zh/api/streaming-api/#_9","title":"\u591a\u7b56\u7565\u5e76\u884c\u76d1\u63a7","text":"<pre><code># \u4e3a\u4e0d\u540c\u76ee\u7684\u521b\u5efa\u4e0d\u540c\u7684\u76d1\u63a7\u7b56\u7565\nclient = DexscreenerClient()\n\n# \u7b56\u7565 1\uff1a\u9ad8\u9891\u4ea4\u6613\u76d1\u63a7\nawait client.subscribe_pairs(\n    \"solana\",\n    hft_pairs,\n    hft_callback,\n    filter=FilterConfig(\n        price_change_threshold=0.0001,  # 0.01%\n        max_updates_per_second=10.0\n    ),\n    interval=0.2\n)\n\n# \u7b56\u7565 2\uff1a\u6d41\u52a8\u6027\u63d0\u4f9b\u8005\u76d1\u63a7\nawait client.subscribe_pairs(\n    \"ethereum\",\n    lp_pairs,\n    lp_callback,\n    filter=FilterConfig(\n        change_fields=[\"liquidity.usd\", \"volume.h24\"],\n        liquidity_change_threshold=0.01,  # 1%\n        volume_change_threshold=0.20      # 20%\n    ),\n    interval=5.0\n)\n\n# \u7b56\u7565 3\uff1a\u4ef7\u683c\u8b66\u62a5\nalert_config = FilterConfig(\n    price_change_threshold=0.05  # 5% \u53d8\u5316\u89e6\u53d1\u8b66\u62a5\n)\nawait client.subscribe_pairs(\n    \"bsc\",\n    alert_pairs,\n    send_price_alert,\n    filter=alert_config,\n    interval=10.0\n)\n</code></pre>"},{"location":"zh/api/streaming-api/#_10","title":"\u56de\u8c03\u6700\u4f73\u5b9e\u8df5","text":""},{"location":"zh/api/streaming-api/#_11","title":"\u9519\u8bef\u5904\u7406","text":"<p>\u59cb\u7ec8\u5728 try-except \u4e2d\u5305\u88c5\u56de\u8c03\u903b\u8f91\uff1a</p> <pre><code>async def safe_callback(pair: TokenPair):\n    try:\n        # \u60a8\u7684\u903b\u8f91\n        if pair.price_usd &gt; threshold:\n            await send_alert(pair)\n    except Exception as e:\n        logger.error(f\"\u56de\u8c03\u9519\u8bef: {e}\")\n        # \u4e0d\u8981\u8ba9\u9519\u8bef\u5bfc\u81f4\u8ba2\u9605\u5d29\u6e83\n</code></pre>"},{"location":"zh/api/streaming-api/#_12","title":"\u5f02\u6b65\u56de\u8c03","text":"<p>\u56de\u8c03\u53ef\u4ee5\u662f\u540c\u6b65\u6216\u5f02\u6b65\u7684\uff1a</p> <pre><code># \u540c\u6b65\u56de\u8c03\ndef sync_handler(pair: TokenPair):\n    print(f\"\u4ef7\u683c: ${pair.price_usd}\")\n\n# \u5f02\u6b65\u56de\u8c03\nasync def async_handler(pair: TokenPair):\n    await database.save_price(pair)\n    await check_trading_conditions(pair)\n\n# \u4e24\u8005\u90fd\u53ef\u4ee5\u4e0e subscribe_pairs \u4e00\u8d77\u4f7f\u7528\nawait client.subscribe_pairs(\"ethereum\", addresses, sync_handler)\nawait client.subscribe_pairs(\"ethereum\", addresses, async_handler)\n</code></pre>"},{"location":"zh/api/streaming-api/#_13","title":"\u72b6\u6001\u7ba1\u7406","text":"<p>\u4f7f\u7528\u95ed\u5305\u6216\u7c7b\u6765\u5904\u7406\u6709\u72b6\u6001\u7684\u56de\u8c03\uff1a</p> <pre><code># \u4f7f\u7528\u95ed\u5305\ndef create_ma_calculator(period: int):\n    prices = []\n\n    def calculate_ma(pair: TokenPair):\n        prices.append(pair.price_usd)\n        if len(prices) &gt; period:\n            prices.pop(0)\n\n        if len(prices) == period:\n            ma = sum(prices) / period\n            print(f\"MA({period}): ${ma:.4f}\")\n\n    return calculate_ma\n\n# \u4f7f\u7528\u7c7b\nclass TradingStrategy:\n    def __init__(self):\n        self.positions = {}\n        self.alerts = []\n\n    async def process_update(self, pair: TokenPair):\n        # \u590d\u6742\u7684\u6709\u72b6\u6001\u903b\u8f91\n        if self.should_buy(pair):\n            await self.execute_buy(pair)\n</code></pre>"},{"location":"zh/api/streaming-api/#_14","title":"\u6027\u80fd\u4f18\u5316","text":""},{"location":"zh/api/streaming-api/#1","title":"1. \u8ba2\u9605\u9650\u5236","text":"<ul> <li>\u6bcf\u6761\u94fe\u6700\u591a 30 \u4e2a\u4ea4\u6613\u5bf9\u8ba2\u9605</li> <li>\u8d85\u8fc7\u9650\u5236\u5c06\u8bb0\u5f55\u8b66\u544a\u5e76\u5ffd\u7565\u989d\u5916\u8ba2\u9605</li> <li>\u4f7f\u7528 <code>subscribe_tokens</code> \u76d1\u63a7\u4ee3\u5e01\u7684\u6240\u6709\u4ea4\u6613\u5bf9\uff08\u65e0\u9650\u5236\uff09</li> </ul>"},{"location":"zh/api/streaming-api/#2","title":"2. \u8f6e\u8be2\u4f18\u5316","text":"<ul> <li>\u540c\u4e00\u94fe\u4e0a\u7684\u591a\u4e2a\u8ba2\u9605\u4f1a\u81ea\u52a8\u6279\u5904\u7406</li> <li>\u8f6e\u8be2\u95f4\u9694\u662f\u8be5\u94fe\u4e0a\u6240\u6709\u8ba2\u9605\u7684\u6700\u5c0f\u503c</li> <li>\u8fc7\u6ee4\u5668\u72ec\u7acb\u5e94\u7528\u4e8e\u6bcf\u4e2a\u8ba2\u9605</li> </ul>"},{"location":"zh/api/streaming-api/#3","title":"3. \u6700\u4f73\u5b9e\u8df5","text":"<ul> <li>\u8ba2\u9605\u524d\u68c0\u67e5 <code>get_active_subscriptions()</code> \u907f\u514d\u91cd\u590d</li> <li>\u4f7f\u7528\u9002\u5f53\u7684\u8fc7\u6ee4\u51cf\u5c11\u4e0d\u5fc5\u8981\u7684\u56de\u8c03</li> <li>\u7a0b\u5e8f\u9000\u51fa\u65f6\u59cb\u7ec8\u8c03\u7528 <code>close_streams()</code></li> <li>\u5e73\u8861\u8f6e\u8be2\u95f4\u9694\u4e0e\u5b9e\u65f6\u9700\u6c42</li> </ul>"},{"location":"zh/api/streaming-api/#_15","title":"\u5e38\u89c1\u6a21\u5f0f","text":""},{"location":"zh/api/streaming-api/#_16","title":"\u4ef7\u683c\u8b66\u62a5\u7cfb\u7edf","text":"<pre><code>class PriceAlertSystem:\n    def __init__(self, alert_thresholds: Dict[str, float]):\n        self.client = DexscreenerClient()\n        self.thresholds = alert_thresholds\n        self.last_prices = {}\n\n    async def start_monitoring(self):\n        for pair_address, threshold in self.thresholds.items():\n            await self.client.subscribe_pairs(\n                \"ethereum\",\n                [pair_address],\n                self.check_price,\n                filter=FilterConfig(\n                    price_change_threshold=threshold\n                )\n            )\n\n    def check_price(self, pair: TokenPair):\n        if pair.pair_address in self.last_prices:\n            old_price = self.last_prices[pair.pair_address]\n            change = abs(pair.price_usd - old_price) / old_price\n\n            if change &gt;= self.thresholds[pair.pair_address]:\n                self.send_alert(pair, old_price, pair.price_usd)\n\n        self.last_prices[pair.pair_address] = pair.price_usd\n</code></pre>"},{"location":"zh/api/streaming-api/#_17","title":"\u4ea4\u6613\u91cf\u6fc0\u589e\u68c0\u6d4b","text":"<pre><code>async def detect_volume_surges():\n    client = DexscreenerClient()\n\n    # \u8ddf\u8e2a\u4ea4\u6613\u91cf\u5386\u53f2\n    volume_history = defaultdict(list)\n\n    def volume_callback(pair: TokenPair):\n        history = volume_history[pair.pair_address]\n        history.append(pair.volume.m5 or 0)\n\n        # \u4fdd\u7559\u6700\u540e 12 \u4e2a\u5468\u671f\uff085 \u5206\u949f\u6570\u636e\u7684 1 \u5c0f\u65f6\uff09\n        if len(history) &gt; 12:\n            history.pop(0)\n\n        if len(history) &gt;= 6:\n            recent_avg = sum(history[-3:]) / 3\n            older_avg = sum(history[-6:-3]) / 3\n\n            if older_avg &gt; 0:\n                surge = recent_avg / older_avg\n                if surge &gt; 3:  # 3 \u500d\u4ea4\u6613\u91cf\u6fc0\u589e\n                    print(f\"\u68c0\u6d4b\u5230\u4ea4\u6613\u91cf\u6fc0\u589e: {pair.base_token.symbol} - {surge:.1f}x\")\n\n    # \u76d1\u63a7\u9ad8\u6d41\u52a8\u6027\u4ea4\u6613\u5bf9\n    pairs = await client.search_pairs_async(\"ETH\")\n    liquid_pairs = [p for p in pairs if p.liquidity and p.liquidity.usd &gt; 100_000]\n\n    addresses = [p.pair_address for p in liquid_pairs[:20]]\n    await client.subscribe_pairs(\n        \"ethereum\",\n        addresses,\n        volume_callback,\n        filter=FilterConfig(change_fields=[\"volume.m5\"]),\n        interval=0.5\n    )\n</code></pre>"}]}